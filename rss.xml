<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Ian Chu]]></title><description><![CDATA[我目前是前端工程師，曾有網路行銷相關工作經驗，這裡會有工作實戰經驗分享，擅長javascript、css、seo、google analytics等。]]></description><link>https://ianccy.com</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 16 May 2021 16:19:31 GMT</lastBuildDate><item><title><![CDATA[CSS animation Performance]]></title><description><![CDATA[前一篇介紹了關於 CSS DOM painting performance，再來分享個關於 CSS animation performance 相關資訊，後面會提到自己在專案上遇到相關的問題。 前一篇: cssperformance 先提一下，以下沒有要介紹 CSS…]]></description><link>https://ianccy.com/2021-05-cssanimation/</link><guid isPermaLink="false">https://ianccy.com/2021-05-cssanimation/</guid><pubDate>Sat, 08 May 2021 07:05:54 GMT</pubDate><content:encoded>&lt;p&gt;前一篇介紹了關於 CSS DOM painting performance，再來分享個關於 CSS animation performance 相關資訊，後面會提到自己在專案上遇到相關的問題。&lt;/p&gt;
&lt;p&gt;前一篇: &lt;a href=&quot;../cssperformance/&quot; title=&quot;cssperformance&quot;&gt;cssperformance&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先提一下，以下沒有要介紹 CSS animation 有哪些寫法，或是什麼炫砲特效的。&lt;/p&gt;
&lt;h2&gt;browser 60fps&lt;/h2&gt;
&lt;p&gt;先介紹一下何謂動畫卡頓感，人眼在 60 frames per seconds 更新下會是順暢感的，下方影片就是 60 fps vs 30 fps vs 24 fps 的比較，會明顯發現 fps 越低會越有卡頓感。&lt;/p&gt;
&lt;p&gt;避免 fps 太低的方法，大概是因為避免頻繁的更新畫面，例如 scroll 搭配複雜的更新 css，或是 javascript 過度的佔用資源，或是 setInterval 頻繁更新畫面等等。&lt;/p&gt;
&lt;p&gt;除非你用插件，否則畫面卡頓你通常會知道是為什麼，因為這些寫法都頗暴力。&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/_SzGQkI-IwM?start=19&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;h2&gt;避免使用過於負擔的 css style&lt;/h2&gt;
&lt;p&gt;一個頁面效果的更新，通常會有五個 thread， javascript 觸發變化，接下來會在執行 Style 計算，後面會執行 Layout 計算，再來執行 Paint 收集需要繪製的部分，最後會執行 Composite，如果前面有需要更新 paint，都收集起來更新到畫面上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JavaScript: 利用 javasScript 執行促使畫面產生變化，例如 onClick slide，或是拖拉 element

style: 透過 browser selector ( 例如 .article-content p )，計算出 element 最後應用的 css style。

Layout: 計算 element 因為 style 套用，而可能產生的位移，並且找出相互影響的 element，或是 dom tree 變化等等。

Paint: 搜集 element 所應用的 style，並且運算出 style 結果。

Composite: 將各個 layer 做組合，並渲染更新到畫面上。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;google 教學: &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/rendering&quot; title=&quot;performance rendering&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;performance rendering&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/css_render.png&quot; alt=&quot;render step&quot; title=&quot;render step&quot;&gt;&lt;/p&gt;
&lt;p&gt;CSS 執行部分主要分為 Layout、Paint、Composite 這三個。其中 Layout 付出的成本最高，會促使 CSSOM tree 更新重繪，至於 painting 也是高成本的計算，最節省資源的是 Composite，能幫助優化 GPU 效能。&lt;/p&gt;
&lt;p&gt;另外 CSS 每個屬性背後所要付出的成本其實不大相同，top 跟 transform 就不一樣。top 會造成整個畫面需要重新繪製位移，負擔較大，至於 transform 則是只需要 composite。詳細每個 style 在下方連結有列出。&lt;/p&gt;
&lt;p&gt;提醒如果你需要使用 animation 的話，盡量能用&lt;code&gt;只需要 composite 的 style&lt;/code&gt;，避免對畫面造成可能的負擔。&lt;/p&gt;
&lt;p&gt;文件: &lt;a href=&quot;https://csstriggers.com/visibility&quot; title=&quot;csstrigger&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;csstriggers&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;CSS animation 專案&lt;/h2&gt;
&lt;p&gt;最近完成一個有趣東西，是關於動畫效果的，需求就是要落下紅包雨，然後要讓 user 點擊開獎。在有開發時間壓力，其它種種因素之下，決定簡單用 css animation 簡單處理。&lt;/p&gt;
&lt;h4&gt;React reupdate 影響 animation&lt;/h4&gt;
&lt;p&gt;因為專案是全用 react 開發的，所以我也打算用 react 處理這個特效，在一開始是依賴 requestAnimationFrame 來針對每一組紅包 component 在動畫完成落下，再抹殺重建立產生新的動畫落下，不過因為更新過於頻繁，html dom 一直不斷在更新，造成畫面卡頓感嚴重。&lt;/p&gt;
&lt;p&gt;那時候發現 fps 在遭遇大量的 component update 時，fps 會落到 30~40 不等，後面就直接拋棄 react 處理，直接改用 react build component，後面就不盡量不依賴 javascript 去接觸 animation 更新，我這邊是直接用 animation-iteration-count infinite，再一開始 init 計算，用一些方式製造出時間差，讓落下有錯開的錯覺。&lt;/p&gt;
&lt;p&gt;結果就如下方，因為需求就是要多個紅包，設計還要有分離感，最後還是使用了多個 animation...。實務上務必能減少同時 animation 就減少，能減少大量效能負擔。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/red_envelope.gif&quot; alt=&quot;red envelope&quot; title=&quot;red envelope&quot;&gt;
壓縮 gif 後，有產生點卡頓感&lt;/p&gt;
&lt;h2&gt;Javascript 阻塞 rendering-queue&lt;/h2&gt;
&lt;p&gt;這是正在進行的專案，利用 canvas 處理圖片 (感謝同事 jason carry canvas 部分)。嘗試非常極端的情境，上傳超級大的圖片跟 webp，結果如下方 gif 畫面，有兩個 loading 引導，下方是用 css animation 的，上方是 loading gif，可以看得出來下方的 css animation 十分卡頓。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/animation-stuck.gif&quot; alt=&quot;animation stuck&quot; title=&quot;animation stuck&quot;&gt;&lt;/p&gt;
&lt;p&gt;於是打開 chrome devtool 的 performance 去錄製，由報告中可以發現到 scripting 幾乎佔滿了整個線程，導致我們頁面的 rendering 幾乎沒資源可以執行，&lt;/p&gt;
&lt;p&gt;另外也可以發現 CPU usage 直接跑到 100%。中間區塊的 Compositor 也像是幻燈片一樣，沒有連續的執行，很多執行中斷點。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/devtool_render_stuck.png&quot; alt=&quot;devtool render stuck&quot; title=&quot;devtool render stuck&quot;&gt;&lt;/p&gt;
&lt;p&gt;render 更新又與 render-queue 有關，這會牽涉到 event loop。如果不大理解 event loop 的話，可以看下方這段影片，激推、神清楚。&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/8aGhZQkoFbQ&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;google chrome update: &lt;a href=&quot;https://frarizzi.science/journal/web-engineering/browser-rendering-queue-in-depth&quot; title=&quot;browser-rendering-queue-in-depth&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;browser-rendering-queue-in-depth&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;卡頓問題的解法可以用 web worker api，讓我們執行序 (thread) 在背景運行，這樣就避免畫面中斷與 user 互動，還可以避免畫面 fps 爆炸產生卡頓感。&lt;/p&gt;
&lt;p&gt;但 web worker 沒支援 ie11...，也知道能不能撐受這麼大的執行運算，還在思考解法中。&lt;/p&gt;
&lt;p&gt;mdn: &lt;a href=&quot;https://developer.mozilla.org/zh-TW/docs/Web/API/Web_Workers_API/Using_web_workers&quot; title=&quot;mdn web workers&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;web workers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;google chrome update: &lt;a href=&quot;https://developers.google.com/web/updates/2018/08/offscreen-canvas&quot; title=&quot;web worker handle canvas&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;web worker handle canvas&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;這個議題是在專案上遇到的，才開始研究 css style animation，所以才會提到專案。畢竟由實務切入，比較能理解相關技術運用的地方，找問題，解決問題。&lt;/p&gt;
&lt;p&gt;以上有問題歡迎留言。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Critical Rendering Path 關鍵渲染路徑優化]]></title><description><![CDATA[CSS 常被認為簡單好學，我對它看法是易學但難精通，以前都只想過實現各種 UI、效果，但沒認真考慮過效能，怎樣的寫法最適合這個情境。假設你有針對 google page speed、lighthouse…]]></description><link>https://ianccy.com/2021-02-cssperformance/</link><guid isPermaLink="false">https://ianccy.com/2021-02-cssperformance/</guid><pubDate>Thu, 11 Feb 2021 05:30:44 GMT</pubDate><content:encoded>&lt;p&gt;CSS 常被認為簡單好學，我對它看法是易學但難精通，以前都只想過實現各種 UI、效果，但沒認真考慮過效能，怎樣的寫法最適合這個情境。假設你有針對 google page speed、lighthouse 優化過，應該會特別有感觸，該如何才能讓網頁載入更快。&lt;/p&gt;
&lt;p&gt;接下來討論如何讓畫面渲染載入更快，以及一些最佳化使用方式。&lt;/p&gt;
&lt;h2&gt;網頁渲染邏輯&lt;/h2&gt;
&lt;p&gt;首先介紹最基礎的 painting，瀏覽器的畫面產生，需要有幾個步驟，先是由上至下掃一遍 html，擷取內容後，先產生 HTML DOM tree，再來產生 CSSOM tree，&lt;/p&gt;
&lt;p&gt;經由上面步驟，轉譯樹狀結構，將 兩個 tree 合併起來產生 render tree，最後是關鍵的步驟，根據每個節點，依照 style 決定 layout 版面配置，或是決定樣式套用，並且繪製在畫面上，就是我們看到 div 並帶有 width 等樣式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/domcssom.png&quot; alt=&quot;html DOM CSSOM&quot; title=&quot;HTMLDOM CSSOM Render Tree (畫圖花了我三十分鐘...)&quot;&gt;&lt;/p&gt;
&lt;p&gt;Google: &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-tw&quot; title=&quot;轉譯樹狀結構的建構、版面配置和繪製&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;轉譯樹狀結構的建構、版面配置和繪製&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所謂的優化關鍵路徑，就是要縮短這整個流程的時間，擷取 HTML -&gt; DOM tree -&gt; CSSOM tree -&gt; render tree -&gt; painting。&lt;/p&gt;
&lt;h2&gt;避免使用影響載入&lt;/h2&gt;
&lt;p&gt;網頁載入速度快慢影響，首先是資源請求速度，網頁上的 CSS JS file 都會是需要發 http 請求的，遇到這狀況時，解析器都必須先停止解析 HTML 並執行該腳本，然後才能繼續解析。所以盡可能避免過多個資源請求，讓 css 或是 js print 到 html 上。&lt;/p&gt;
&lt;p&gt;針對 script file 推薦用 async 或是 defer，async 是不中斷 HTML parser 並當載入 js file 完成立刻執行，defer 則是當整體 HTML parser 完成，再回頭執行 js file。小提醒 async 代表在這邊操作 DOM 都是可能失敗的，因為你無法預知載入 file 時，DOM 有無產生。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/asyncdefer.png&quot; alt=&quot;async defer&quot; title=&quot;script async defer&quot;&gt;&lt;/p&gt;
&lt;p&gt;神圖介紹來源: &lt;a href=&quot;https://html.spec.whatwg.org/multipage/scripting.html&quot; title=&quot;whatwg製&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;whatwg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同時假設在 HTML parser 階段就開始執行 javascript，都會中斷 HTML parser 的，所以這邊要盡量避免在初始化執行大量 javascript，可以用事件監聽 DOM loaded 觸發執行。&lt;/p&gt;
&lt;p&gt;另外就是 CSS import font，實務上常常是這點卡住，這建議用 javascript 非同步方式載入，ps. 我們用過這方法大概推進 lighthouse 20 分左右。&lt;/p&gt;
&lt;p&gt;至於 http 2，目前還有滿多 cdn 尚未支援的，這邊就不多討論，大概概念就是這可以大幅加快 http 請求速度，實現同時多個 http 請求，並且不阻塞。&lt;/p&gt;
&lt;p&gt;最後假設 SPA 是純 client side render 又要追求載入速度的話，直接起跑點就輸了，比較建議考慮直接改 server side render，你用上面邏輯跑一遍，就大概知道這是 飛機 vs 機車的差距了。&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;我自己是覺得原理滿重要的，當初在學習前端時候，常常只是無腦跟著教學走，只是覺得瀏覽器真神奇，各種炫砲畫面，假設知道原理後，就更容易知道問題在哪裏，其實我原本是想寫 CSS animation 的，沒想到研究研究就覺得這應該也滿重要的，就先寫這篇了。&lt;/p&gt;
&lt;p&gt;下方內容滿推薦的，真心推薦前端都需要看過一遍，會對於效能這件事，有更深的了解。&lt;/p&gt;
&lt;p&gt;google 教學: &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path&quot; title=&quot;網頁渲染運作邏輯&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;網頁渲染運作邏輯&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一樣感謝閱讀，有問題歡迎留&lt;/p&gt;</content:encoded></item><item><title><![CDATA[30 歲的我]]></title><description><![CDATA[今天剛好滿 30 歲，今天也是小河馬的奴隸，在那邊挑草，清便盆，河馬是我女朋友養的兔子，可愛、知書達禮，不會咬人又愛乾淨，還會提醒我該餵他吃枸杞了，唯一缺點大概就是不愛被抱著。 30 歲，開始發現鬍子開始要每天刮，頭髮側邊長了幾根白頭髮，皮膚開始出現細紋，吃到飽大概 3…]]></description><link>https://ianccy.com/2020-12-thirtyyearsold/</link><guid isPermaLink="false">https://ianccy.com/2020-12-thirtyyearsold/</guid><pubDate>Mon, 28 Dec 2020 14:32:53 GMT</pubDate><content:encoded>&lt;p&gt;今天剛好滿 30 歲，今天也是小河馬的奴隸，在那邊挑草，清便盆，河馬是我女朋友養的兔子，可愛、知書達禮，不會咬人又愛乾淨，還會提醒我該餵他吃枸杞了，唯一缺點大概就是不愛被抱著。&lt;/p&gt;
&lt;p&gt;30 歲，開始發現鬍子開始要每天刮，頭髮側邊長了幾根白頭髮，皮膚開始出現細紋，吃到飽大概 30 分鐘陣亡，開始懷疑是不是喝水就會變胖，30 歲的我外在改變許多。&lt;/p&gt;
&lt;p&gt;我現在正坐在又熱、又吵，廁所還暫停使用的咖啡廳，背後流汗的敲鍵盤寫文章，看來部落客宣傳是騙人的，環境根本一點都不舒適。&lt;/p&gt;
&lt;p&gt;原本就想多寫一些輕鬆的東西，但今年開始研究投資之後，就連技術類文章也少寫了兩篇，不過留言或寄信問題，我能幫忙上的話，一定會幫忙的。曾想過寫一些股票研究的東西，但想一想怕我內容誤人子弟，那些東西還是留在我的 notion 就好吧。&lt;/p&gt;
&lt;p&gt;30 歲也算是人生重要時刻，總覺得該留下點什麼，所以就強迫自己寫這一篇文章了。&lt;/p&gt;
&lt;h2&gt;關於我&lt;/h2&gt;
&lt;p&gt;我是一個腦袋常常運轉的人，每天晚上洗澡時，會檢討一整天哪邊做對、哪邊做錯，我應該算是偏內向，雖然旁人總覺得我話滿多，講話又頗中二的。幼稚園、國小一、二年級時，我其實滿省話的，是後面才覺得透過聊天，多知道些什麼還滿有趣的。&lt;/p&gt;
&lt;p&gt;我很容易被外部影響心情，又是一個優柔寡斷的人。做事情喜歡計畫，但只要跟我計畫不一樣就會開始慌亂。&lt;/p&gt;
&lt;p&gt;優柔寡斷這點真的煩，在我投資的時候這缺點展露無遺，常常會亂腦補一些有的沒的，真的需要改善...。&lt;/p&gt;
&lt;h2&gt;14 歲的期待&lt;/h2&gt;
&lt;p&gt;我記得很深刻的是，國中某一次的班導課，就被老師強迫思考 30 歲，想成為怎樣的人，我其實只想著，常聽大人們說，錢可以解決很多問題，哎啊，那我就希望有百萬年薪好了。&lt;/p&gt;
&lt;p&gt;痾，很遺憾，我在這一天沒有達到 14 歲的我的期待，但不知道是不是通膨的關係，我現在覺得百萬年薪也沒解決太多問題...。&lt;/p&gt;
&lt;p&gt;身邊常常有朋友或同事問我，對於薪水的期待是多少，恩...這就是我這樣說的原因，非常白痴。不過現在覺得這期待非常務實啊！不愛作夢、又實際。&lt;/p&gt;
&lt;h2&gt;朋友、家人&lt;/h2&gt;
&lt;p&gt;最近參加幾場高中朋友的婚宴，跟以前的朋友聚聚聊著過去事情，很美好、又白爛、有趣。提醒我要多珍惜身邊朋友、家人。比較可惜是國中同學以前感情算濃厚，但現在都沒什麼聯絡，有空應該多聚聚聊聊的，真的好懷念啊。&lt;/p&gt;
&lt;p&gt;我個性算比較內斂吧，雖然我話滿多的，但我其實很少主動約人，但現在，我是滿珍惜身邊朋友約我的每一次聚會，看來我真的老了...。&lt;/p&gt;
&lt;p&gt;可能是住在家裡的關係，每天都能跟他們聊天講話，倒也沒有太多感觸，目前遺憾是爸媽沒有出過國，應該趁父母都還健康時候，有機會的話帶他們出國，不然我爸媽真的省錢省到爆。&lt;/p&gt;
&lt;p&gt;還要感謝我的女朋友 Linda，剛出社會時候，我真的找不到工作，我每天例行公事就是人力銀行打開來，一次全發應徵，然後全部已讀不回...，還面試過業務、行政，一度懷疑過我是不是有什麼問題。&lt;/p&gt;
&lt;p&gt;不過她那時候總還是鼓勵我：是你可以的，雖然最近問她那時候怎相信我可以的，她只是說：喔，就只是給你鼓勵的話啊。 她最近工作也轉換到新領域，但我是滿有信心她可以的 XD。&lt;/p&gt;
&lt;p&gt;最近才換掉那時候的手機桌布，上面寫著 fight for life，所以我一直很珍惜我的工作。&lt;/p&gt;
&lt;h2&gt;工作&lt;/h2&gt;
&lt;p&gt;可能摩羯座的關係，或是家庭文化影響，我還是覺得認真賺錢、工作吧，我媽常說：錢不是萬能的，但沒有錢萬萬不能，不管用什麼面向來看，還真的有幾分道理。&lt;/p&gt;
&lt;p&gt;希望投資這塊能找到自己的方法，未來，把更多時間挪來精進自己的工作專業。很多東西還想學，不管是行銷、或是網頁程式。&lt;/p&gt;
&lt;p&gt;也感謝現在工作的同事，大家都有各自擅長專業 ，也會互相 cover 幫忙，上班常常講一些幹話，雖然常常遇到很多煩人雜事，漸進式開發啊，無限滿足各種客戶詭異需求，bla...bla...，但工作氣氛多半是歡樂的。&lt;/p&gt;
&lt;p&gt;這是我進現在這間公司就期待的，團隊一群人一起向前進的感覺，真棒！&lt;/p&gt;
&lt;p&gt;感謝公司有生日假，雖然最近工作極度的忙，但這個假不休會對不起我自己。我很喜歡眾人上班，我休假的感覺，真的是舒服 XD。&lt;/p&gt;
&lt;p&gt;哎...過了快三小時，咖啡廳廁所還是暫停使用，聊天的聲音也變成大笑大叫，三小，膀胱要炸裂了。&lt;/p&gt;
&lt;p&gt;正面能量滿滿，怎麼整篇充滿傳直銷的味道...，最後看這篇的人，不管你是朋友、家人還是網友，都祝福你！&lt;/p&gt;
&lt;p&gt;還有提醒我一下我自己，保持好奇心。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JavaScript Closure 你一定有用過的閉包]]></title><description><![CDATA[JavsScript 的 closure (閉包) 是什麼？ 假設你有在寫 javascript 的話，你可能每天都在用，但你只是沒特別查覺而已。 Clousre 在 MDN 上解釋為 這個解釋是我看過比較簡單直白的。 而我自己對 closure…]]></description><link>https://ianccy.com/2020-06-closure/</link><guid isPermaLink="false">https://ianccy.com/2020-06-closure/</guid><pubDate>Sat, 27 Jun 2020 12:20:35 GMT</pubDate><content:encoded>&lt;p&gt;JavsScript 的 closure (閉包) 是什麼？ 假設你有在寫 javascript 的話，你可能每天都在用，但你只是沒特別查覺而已。&lt;/p&gt;
&lt;!--- ![javascript closure](../images/closure.png &quot;javascript closure&quot;) ---&gt;
&lt;p&gt;Clousre 在 MDN 上解釋為&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;A closure is the combination of a function bundled together (enclosed)
with references to its surrounding state (the lexical environment).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這個解釋是我看過比較簡單直白的。&lt;/p&gt;
&lt;p&gt;而我自己對 closure 白話解釋的話，就是利用 return 回傳值，並且做一個作用域環境封裝。&lt;/p&gt;
&lt;h2&gt;Closure 封裝變數&lt;/h2&gt;
&lt;p&gt;以下我建立一個變數 a，是一個 object value 是 { name: &apos;ian&apos;}，function getValueA 則會回傳 a，javascript 特性，會在 function 建立時，就以同層尋找變數，找不到就一層一層往外。接下來建立變數 assignA 賦予 getValueA() 回傳值。&lt;/p&gt;
&lt;p&gt;嘗試 log 出來後，會發現第一次會是 {name: &quot;ian&quot;}，但是接下來重新賦予 a 的值，神奇的事發生了，發現 assignA 的值並沒有被改變。但嘗試直接 log 回傳 getValueA() 會發現，a 是有成功被改變了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封裝 lexical environment ( 作用域環境 )&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var a = { name: &apos;ian&apos; };
function getValueA() {
    return a;
}
var assignA = getValueA();
console.log(assignA); // {name: &quot;ian&quot;}

a = 2;
console.log(assignA); // {name: &quot;ian&quot;}
console.log(getValueA()); // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這是因為 closure 幫我們做封裝記憶體，javascript 的記憶體管理機制，幫我們把第一次 return a 時，這個 { name: &apos;ian&apos; }，封裝起來避免被記憶體回收，假設要回收 { name: &apos;ian&apos; } 的方法就是讓 assignA 指向新的參考。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;javascript 記憶體回收&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;「沒有其他任何物件參考它」。如果一個物件不在被任何物件參考，它將被視為可回收記憶體的垃圾。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MDN: &lt;a href=&quot;https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Memory_Management&quot; title=&quot;記憶體生命週期&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;記憶體生命週期&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;JavaScript 作用域&lt;/h2&gt;
&lt;p&gt;下面的這個問題，相信大家面試的時候，都被問到爛了，聽到問題是 forLoop 跟 setTimeout 開頭都快可以直接反射背出答案 X Ｄ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;經典 (&lt;del&gt;面試&lt;/del&gt;) 問題&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;for (var i = 0; i &amp;#x3C; 3; i++) {
    setTimeout(function() {
        console.log(i);
    }, 0);
}
// 3
// 3
// 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這問題又與 javascript event loop 有關，setTimeout 是 web API，在 javascript 執行緒時，碰到 setTimeout 會被特別放到另一個 stack，等到最後才會來執行，邏輯上就是 i 已經被重新更新到 3 了，但是我才要來開始 log i，那結果當然是 3 出現三次。&lt;/p&gt;
&lt;p&gt;MDN: &lt;a href=&quot;https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/EventLoop&quot; title=&quot;Event Loop&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Event Loop&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;setTimeout 解法&lt;/h3&gt;
&lt;p&gt;還是簡單講一下，其中簡單的方法是 var 改用 let，讓每次 let 的作用域被包覆所以記憶起來。另一個就是利用記憶體封裝概念 ，同樣原理也與 let 差不多，利用 function logI(i) 傳入變數，來讓 i 當下的值被封裝。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;for (var i = 0; i &amp;#x3C; 3; i++) {
    function logI(i) {
        setTimeout(function() {
            console.log(i);
        }, 0);
    }
    logI(i);
}
// 0
// 1
// 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你將 logI function 的 argument 拿掉，又會出現三次的 3，因為沒有封裝變數 i。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;...
    function logI() {
        setTimeout(function() {
            console.log(i)
        }, 0);
    }
    logI();
...
// 3
// 3
// 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;稍微整理一下最近面試常會問的問題，順便整理一下自己對 closure 基本觀念。在找 setTimeout forLoop 除了 let、立即函示外的解法，才找到 function pass argument，也發現自己也不夠了解 function argument 對於 memory 機制這部分。&lt;/p&gt;
&lt;p&gt;雖然說 react 開發上，比較少會因為 closure 踩到雷，但相信&lt;code&gt;每多懂一點，未來雷就少踩一點&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;感謝閱讀，有錯誤或意見歡迎留言。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Immutable 對於 React 重要性]]></title><description><![CDATA[Immutable 是我想寫很久的主題，前一份工作時，就大大的踩到關於 immutable 的雷，那時候依靠 google…]]></description><link>https://ianccy.com/2020-04-immutable/</link><guid isPermaLink="false">https://ianccy.com/2020-04-immutable/</guid><pubDate>Wed, 29 Apr 2020 12:39:42 GMT</pubDate><content:encoded>&lt;p&gt;Immutable 是我想寫很久的主題，前一份工作時，就大大的踩到關於 immutable 的雷，那時候依靠 google 靠解掉這問題，但總該還債的，面試時候也被這個關內給卡到。現代網頁前端不只是要處理畫面更新，更多時間更會處理大量資料處理，不論是重複封裝 、更新等等。React 更是把 Imutable 視為重要的開發準則。&lt;/p&gt;
&lt;!--- ![react immutable](../images/immutable.png &quot;react immutable&quot;) ---&gt;
&lt;h2&gt;Immutable mutable data&lt;/h2&gt;
&lt;p&gt;什麼是 Immutable、mutable，Immutable 稱之不可改變的，mutable 則相反是可以改變的。string、number 都是 immutable 的，簡單講就是不可更改的，舉個例子來說&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string immutable&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let str = &apos;Hello, you!!&apos;;
let ianHello = str;
ianHello += &apos;ian&apos;;

// not changed
console.log(str); // Hello, you!!
console.log(ianHello); // Hello, you!!ian
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立 ianHello 並使用 str 賦值，之後 ianHello 再重新賦值，並不會更動到 str，但 array 就不是這樣了。array 以及 object 使用 call by reference，淺拷貝的做法實現，白話一點講，就是會指導同一個記憶體位置，當你改動資料的時間，是針對指向的那一個記憶體去改，所以才會有連動的狀況。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;array mutable&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let names = [&apos;ian&apos;];
let copyName = names;
copyName.push(&apos;peter&apos;);

// changed
console.log(names); // [ian, peter]
console.log(copyName); // [ian, peter]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;舉下方的例子來說，大致邏輯是依賴兩個陣列資料，驅使更新畫面更新的，呈現問題的使用方法是，點擊&lt;code&gt;複製按鈕&lt;/code&gt;，同步兩邊的資料，再點擊任意一個清單的刪除，會發現兩邊畫面居然會連動。&lt;/p&gt;
&lt;iframe src=&quot;//codepen.io/chu1228/embed/wvMaKYw/?height=265&amp;theme-id=light&amp;default-tab=result&quot; width=&quot;100%&quot; height=&quot;350&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;會產生問題的原因是，第一我複製資料的時候，讓兩個陣列變成指向同一個，所以才會兩邊連動畫面更新。&lt;/p&gt;
&lt;p&gt;這大致上就是簡單的介紹 immutable 跟 mutable。&lt;/p&gt;
&lt;h2&gt;React Immutable&lt;/h2&gt;
&lt;p&gt;React 有提到 state 的更新，都必須要是 immutable，當你有使用到 useState 或是 pureComponent、shouldComponentUpdate，你就會發現問題。下面範例就是 mutable 的更新 state。&lt;/p&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/elastic-flower-hlxd6?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot; width=&quot;100%&quot; height=&quot;350&quot;&gt;&lt;/iframe&gt;
&lt;ul&gt;
&lt;li&gt;mutable setState&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const value = ref.current.value;
names.push(value);
setNames(names);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;結果就是沒辦法觸發 update component，因為 useState 就有自帶了 shallowEqual，同一個記憶體位置去比較有無更新，當然恆等於，所以這個案例，你怎們加入都無法更新畫面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;immutable setState&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;setNames(names =&gt; [...names, value]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://reactjs.org/docs/optimizing-performance.html#the-power-of-not-mutating-data&quot; title=&quot;react optimizing-performance&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;react optimizing-performance&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://redux.js.org/recipes/structuring-reducers/beyond-combinereducers#using-slice-reducers-with-immutablejs-objects&quot; title=&quot;redux reducers immutablejs&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;redux reducers immutablejs&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;記得剛轉前端工作的時候，被這問題卡了一下午，最後是靠 stackoverflow &lt;code&gt;slice&lt;/code&gt;，來解決問題。以前遇到問題都是找到解法就結束了，但說實在沒搞懂原因，這樣遲早還是得回頭還債的。&lt;/p&gt;
&lt;p&gt;勉勵一下自己，要求慎解啊！&lt;/p&gt;
&lt;p&gt;一樣有問題、或是錯誤，歡迎留言，感謝閱讀。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Puppeteer End-to-End Test React]]></title><description><![CDATA[最近接觸某個重要專案，這專案很特別，每個狀態都會對應不同 config 有不同回應，網頁操作、業務邏輯十分之複雜，大概就像是 tree structure 一樣。我負責翻新頁面的 login flow…]]></description><link>https://ianccy.com/2020-02-reactpuppeteer/</link><guid isPermaLink="false">https://ianccy.com/2020-02-reactpuppeteer/</guid><pubDate>Fri, 28 Feb 2020 15:01:40 GMT</pubDate><content:encoded>&lt;p&gt;最近接觸某個重要專案，這專案很特別，每個狀態都會對應不同 config 有不同回應，網頁操作、業務邏輯十分之複雜，大概就像是 tree structure 一樣。我負責翻新頁面的 login flow，雖然我對改動邏輯掌握度高，但我滿擔心是否有沒看到的功能，會關聯到舊邏輯。&lt;/p&gt;
&lt;p&gt;因為 use case 實在太繁雜了，每次都需要請 PM 或工程師手動測試，但又常常漏掉某些特殊情境，讓我有感而發，如果有跑測試就好了。有剛好有時間就來研究一下，要如何在 react 專案上跑 End to End Test。&lt;/p&gt;
&lt;!--- ![react puppeteerjest](../images/puppeteerjest.png &quot;react puppeteerjest&quot;) ---&gt;
&lt;h2&gt;Puppeteer 介紹&lt;/h2&gt;
&lt;p&gt;Puppeteer 是由 Chrome DevTools team 團隊開發的，它是一個 node library 工具，提供 API 讓我們控制 chrome 或 Chromium，並能以 headless chrome(chrome without chrome) 或正常模式執行。相對於 Selenium 專注在跨瀏覽器測試，Puppeteer 則是專注依賴 Chromium 並使用相關的 API 測試。&lt;/p&gt;
&lt;h3&gt;主要功能&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;產生 pdf 網頁快照。&lt;/li&gt;
&lt;li&gt;render 頁面是基於 single page application 架構的頁面，並產生靜態內容。&lt;/li&gt;
&lt;li&gt;自動化測試，input、鍵盤、UI 測試。&lt;/li&gt;
&lt;li&gt;能夠使用最新的 chrome 環境進行測試。&lt;/li&gt;
&lt;li&gt;產生頁面優化診斷。&lt;/li&gt;
&lt;li&gt;測試 chrome extension。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/tools/puppeteer&quot; title=&quot;Puppeteer 官方介紹&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Puppeteer 官方介紹&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這個需要測試的頁面是以 React 開發，純 client side render，E2E 測試也需要處理 render SPA，適合我們的情境。&lt;/p&gt;
&lt;h2&gt;安裝環境&lt;/h2&gt;
&lt;p&gt;建立資料夾，並安裝 package.json 、 puppeteer 等相關設定，接下來建立 js 檔案來使用 node 測試 puppeteer。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir test-puppeteer
cd test-puppeteer
npm init -f
npm install --save-dev puppeteer dotenv
touch test.js
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;執行頁面載入 screenShot&lt;/h3&gt;
&lt;p&gt;接下來嘗試載入 google 頁面，並且自動輸入值來使用 google search。首先我們需要 引入 puppeteer，並執行 puppeteer.launch 啟動 puppeteer，再利用 goto 來載入 &lt;a href=&quot;https://google.com&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://google.com&lt;/a&gt; 頁面，接下來執行 screenshot 並命名 image 儲存位置，接下來 執行 node test，成功跑起來的話會發現新增了 screenshot_google.png ，打開來就是模擬 screenshot 的畫面。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pptr.dev/#?product=Puppeteer&amp;#x26;version=v2.1.1&amp;#x26;show=outline&quot; title=&quot;Puppeteer 文件&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Puppeteer 文件&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;google.js&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const puppeteer = require(&quot;puppeteer&quot;);

(async () =&gt; {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.goto(&quot;https://google.com&quot;);
  await page.screenshot({ path: &quot;./screenshot_google.png&quot; });
  await browser.close();
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;模擬網頁互動&lt;/h3&gt;
&lt;p&gt;使用 page.evaluate(function) 功能，可以讓我們執行 javascript，這邊我們會使用 javascript DOM selector 輸入搜尋框，並且點擊送出搜尋按鈕，再來 page.waitForNavigation() 等待頁面導覽完成，再來繼續執行 evaluate 點擊第一個搜尋結果的標題，最後執行 screenShot。&lt;/p&gt;
&lt;p&gt;簡單講就是用 JavaScript 模擬使用者互動操作，來促使畫面更新變動，再截圖存取畫面。&lt;/p&gt;
&lt;p&gt;page.evaluate 可以執行 javascript，直接以 selector 操作，這邊模擬輸入 coronavirus，並且執行 click submit，接下來 page.waitForNavigation 等待網頁導覽，接下來 page.evaluate 執行第一篇搜尋結果標題 click，最後執行 page.screenshot，截圖儲存並關閉。就完成了一個簡易的 puppeteer 測試。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;google.js&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;(async () =&gt; {
    ...
  await page.evaluate(() =&gt; {
    document.querySelector(&quot;input[type=&apos;search&apos;]&quot;).value = &quot;coronavirus&quot;;
    document.querySelector(&quot;button[jsaction=&apos;click:.CLIENT&apos;]&quot;).click();
  });
  await page.waitForNavigation();
  await page.evaluate(() =&gt; {
    document.querySelector(&apos;#rso div[role=&quot;heading&quot;]&apos;).click();
  });
  await page.waitForNavigation();
  await page.screenshot({ path: &quot;./screenshot_google_search.png&quot; });
  await browser.close();
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/googlecorona.gif&quot; alt=&quot;googlecorona&quot; title=&quot;googlecorona&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://puppeteersandbox.com/P0aWYvFO&quot; title=&quot;puppeteersandbox google Demo&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;puppeteersandbox google Demo&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;測試 facebook login&lt;/h2&gt;
&lt;p&gt;接下來測試一直想跑的 facebook login，曾經某天 facebook 偷偷改版 api，造成整個產品的 login 服務掛掉，或是前幾個月 facebook 連線就出問題了，但這都是在客戶端回報才發現到問題，所以期待這段以 cronjob 定時 run，來確保登入功能是正常的。&lt;/p&gt;
&lt;p&gt;首先載入頁面，假設是手機版，頁面會自動跳出登入按鈕，按鈕上有寫上特殊的 attribute id=&quot;e2e-login-button&quot;，接下來等待這個按鈕顯示，可以使用 page.waitForSelector 等待這個 element visible，執行 button click。&lt;/p&gt;
&lt;p&gt;倒轉到 facebook 網頁後，用 page.evaluate 執行 javascript，填入 facebook 帳號、密碼，再來點擊 facebook 登入按鈕，登入完成後會出現授權頁面，同樣點擊確認授權按鈕。&lt;/p&gt;
&lt;p&gt;倒轉回到原本網站，接下來就判斷是否顯示 登出按鈕，確保使用者有完成登入流程。&lt;/p&gt;
&lt;p&gt;核心邏輯大概就是 waitForSelector 等待 DOM render，並且 page.evaluate 執行互動，在等待 DOM render，執行互動 loop，達成我們所期待的畫面滾動。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fbLogin.js&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;require(&quot;dotenv&quot;).config();
const puppeteer = require(&quot;puppeteer&quot;);
const devices = require(&quot;puppeteer/DeviceDescriptors&quot;);

(async () =&gt; {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.emulate(devices[&quot;iPhone 7&quot;]);
  await page.goto(&quot;https://www.feversocial.com/promo/join?promoid=134364&quot;);

  await page.waitForSelector(&quot;#e2e-login-button&quot;, {
    visible: true
  });

  await page.click(&quot;#e2e-login-button&quot;);
  await page.waitForSelector(&quot;#email_input_container&quot;, {
    visible: true
  });

  await page.evaluate(
    (account, password) =&gt; {
      document.querySelector(&quot;#email_input_container input&quot;).value =
        process.env.FBACCOUNT;
      document.querySelector(&quot;input[type=&apos;password&apos;]&quot;).value =
        process.env.FBPASSWORD;
      document.querySelector(&quot;button[name=&apos;login&apos;]&quot;).click();
    },
    process.env.FBACCOUNT,
    process.env.FBPASSWORD
  );

  await page.waitForSelector(&quot;button[name=&apos;__CONFIRM__&apos;]&quot;, {
    visible: true
  });

  await page.evaluate(() =&gt; {
    document.querySelector(&quot;button[name=&apos;__CONFIRM__&apos;]&quot;).click();
  });

  await page.waitForSelector(&quot;div[type=&apos;0&apos;]&quot;, {
    visible: true
  });

  await page.waitForFunction(
    `document.querySelectorAll(&apos;div[type=&quot;0&quot;]&apos;)[1].textContent === &apos;登出&apos;`
  );
  await page.screenshot({ path: &quot;example.png&quot;, fullPage: true });

  await browser.close();
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/fever_fblogin.gif&quot; alt=&quot;fever fblogin&quot; title=&quot;fever fblogin&quot;&gt;&lt;/p&gt;
&lt;p&gt;提醒一下，這個測試情境只針對曾經給予過 facebook auth 權限，因為跑完每次還要 reset auth 非常不方便。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;記得修改 facebook 帳號密碼 ( 如果擔心線上測試有資安疑慮，就避免使用，我是都用專門測試的帳號 )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://puppeteersandbox.com/gThYhDA2&quot; title=&quot;puppeteersandbox facebook login Demo&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;puppeteersandbox facebook login Demo&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;搭配 Jest 測試&lt;/h2&gt;
&lt;p&gt;上述都是使用 puppeteer 建出流程，但實際上還需要搭配測試斷言工具，這樣才能讓判斷出測試 case 是不是正常，如果不正常的話是哪個流程有問題等等。&lt;/p&gt;
&lt;p&gt;這邊使用到 Jest，環境設定與之前 Jest 大同小異，主要是需要安裝支援 puppeteer 的工具，讓 Jest 能夠執行 puppeteer 環境，基本上沒有太大的難度。如果遇到問題的話 Jest 官網也有 source code 可以提供下載。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安裝 Jest&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;npm install --save-dev jest-puppeteer jest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立 jest.config.js, jest.setup.js&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jest.config.js&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;module.exports = {
  preset: &quot;jest-puppeteer&quot;,
  setupFilesAfterEnv: [&quot;./jest.setup.js&quot;]
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;設定環境以及應用 setup 設定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jest.setup.js&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;jest.setTimeout(10000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;延長 jest default 8000 msec 時間限制&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jestjs.io/docs/en/puppeteer&quot; title=&quot;Jest with Puppeteer&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Jest with Puppeteer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/checkly/puppeteer-examples&quot; title=&quot;Puppeteersandbox github sample code&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Puppeteersandbox github sample code&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;建立測試檔案&lt;/h2&gt;
&lt;p&gt;首先建立 &lt;code&gt;_test_&lt;/code&gt; folder，接下來建立 login.spec.js，針對整個登入流程做判斷，預期之外的狀況就截圖，並且拋出相對錯誤訊息。Jest 無法跳出瀏覽器模擬，所以直接設定 headless 即可。&lt;/p&gt;
&lt;p&gt;將上面的 fbLogin.js script 貼上來作為修改，waitForSelector 增加 timeout，避免卡在一個狀態過久浪費時間，增加 try catch，針對錯誤進行截圖，方便出問題時 debug。&lt;/p&gt;
&lt;p&gt;其餘與一般的 jest 差別不大，就是在預期發生錯誤增加斷言判斷等，這邊就不特別介紹了。實際內容再請觀看 github 上檔案。&lt;/p&gt;
&lt;p&gt;小雷，process 我卡了大概 30 分鐘，process.env.FBPASSWORD 要用 function 作為參數帶入，直接在 evaluate callback function 內，因為環境緣故，是無法取得 process.env 的值。還有其他 dom selector 怎樣寫比較不會出錯等等，這是最耗時的部分，因為是 side project，沒有直接去改 dom 的 tag attribute，因為滿多強硬的 selector 寫法，建議大家還是好好 naming 狀態。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;login.spec.js&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;...
beforeEach(async () =&gt; {
  await page.goto(
    &quot;https://www.feversocial.com/promo/join?promoid=134230&quot;
  );
});

describe(&quot;Login&quot;, () =&gt; {
  it(&quot;Fever Login Flow&quot;, async done =&gt; {
    await page.emulate(devices[&quot;iPhone 7&quot;]);
    await page.waitForSelector(&quot;#e2e-login-button&quot;, {
      visible: true,
      timeout: 1500
    });

    try {
      const buttonHref = await page.$eval(&apos;#e2e-login-button&apos;, el =&gt; el.href);
      await expect(buttonHref).not.toBe(&apos;&apos;);
    } catch (error) {
      await page.screenshot({ path: &quot;./promo_button_href_error.png&quot; });
    }

    await page.click(&quot;#e2e-login-button&quot;);
...
    await page.evaluate((account, password) =&gt; {
      document.querySelector(&quot;#email_input_container input&quot;).value = account;
      document.querySelector(&quot;input[type=&apos;password&apos;]&quot;).value = password;
      document.querySelector(&quot;button[name=&apos;login&apos;]&quot;).click();
    }, process.env.FBACCOUNT, process.env.FBPASSWORD);
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Source Code : &lt;a href=&quot;https://github.com/Ianpig/puppeteer-jest-example&quot; title=&quot;puppeteer-jest-example&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;puppeteer-jest-example&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;這些看起來很簡單，但這些我大概花了 3 天時間，雖然撥出來的時間零零碎碎，剛好某天開發時間有多出時間，就來嘗試用 puppeteer 寫一個測試登入，實際上未來要在搭配 docker 部署上去並以專案 release 時自動觸發，然後出現錯誤要 alarm，這有空再嘗試研究...。&lt;/p&gt;
&lt;p&gt;以上如果有問題歡迎留言，感謝。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[阻擋第三方(Block third-party) Cookie，各瀏覽器狀態]]></title><description><![CDATA[來分享個 cookie 相關的內容，是前陣子合作專案測試階段遇到的問題，發生情境是，合作廠商的手機瀏覽器會無法登入會員，主要都是 IOS 用戶。 提一下目前頁面會放置在對方網站上以 iframe 使用，用戶會點擊 iframe 內登入按鈕，轉導頁面，載入對應的登入 line…]]></description><link>https://ianccy.com/2019-12-iframeblockcookie/</link><guid isPermaLink="false">https://ianccy.com/2019-12-iframeblockcookie/</guid><pubDate>Wed, 11 Dec 2019 23:34:01 GMT</pubDate><content:encoded>&lt;p&gt;來分享個 cookie 相關的內容，是前陣子合作專案測試階段遇到的問題，發生情境是，合作廠商的手機瀏覽器會無法登入會員，主要都是 IOS 用戶。&lt;/p&gt;
&lt;p&gt;提一下目前頁面會放置在對方網站上以 iframe 使用，用戶會點擊 iframe 內登入按鈕，轉導頁面，載入對應的登入 line、facebook 網頁等等，完成登入。&lt;/p&gt;
&lt;!--- ![block cookie](../images/blockcookie.png &quot;block cookie&quot;) ---&gt;
&lt;h3&gt;桌機、手機版 登入流程&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;Desktop:
website (parent) =&gt; click Login =&gt; open window (child)
=&gt; login success =&gt; postMessage to parent ( child close )
=&gt; parent reload =&gt; done

Mobile:
website (parent) =&gt; click Login
=&gt; redirect =&gt; login success =&gt; done
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;登入流程 (簡易版)
&lt;img src=&quot;../images/loginflow.png&quot; alt=&quot;login flow&quot; title=&quot;login flow&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;登入是依賴 cookie，cookie 再交由後端驗證登入與否。經由測試後發現這些驗證請求都不會帶有 cookie，也就是說經由登入流程過後，cookie 沒有正確的存取到用戶的瀏覽器上。&lt;/p&gt;
&lt;p&gt;但合作方希望能跳過以上這些步驟，載入頁面時，直接 call 後端取得 token，直接塞入頁面。&lt;/p&gt;
&lt;p&gt;實際測試發現後端有正確建立這個 token，但就是前端 save cookie 那步驟有問題，於是開始轉向思考前端問題。&lt;/p&gt;
&lt;h2&gt;Block third-party cookie&lt;/h2&gt;
&lt;p&gt;IOS 11 開始預設開啟 prevent cross-site tracking 的設定，這會導致第三方 cookie 無法設置，例如 google analytics、facebook pixel 等等，另外也包括了 iframe 內部網頁，這符合我們的情境。&lt;/p&gt;
&lt;p&gt;android 也同樣有這個設定，但目前沒有預設開啟。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;Privacy by default
Safari’s key privacy features are enabled by default.
For example, in iOS, Intelligent Tracking Prevention
(shown in Settings as Prevent Cross-Site Tracking)
is turned on by default. Camera, microphone,
and location are set to ask for permission before granting access.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;官方文件: &lt;a href=&quot;https://www.apple.com/safari/docs/Safari_White_Paper_Nov_2019.pdf&quot; title=&quot;Safari Privacy Overview &quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Safari Privacy Overview &lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解決 Block third-party Cookie&lt;/h2&gt;
&lt;p&gt;查了網路後，發現有個方法可以繞過 safari 阻擋 cookie，&lt;code&gt;就是要載入該 domain 並且設定一個 cookie 在該網域上&lt;/code&gt;，之後 iframe 就可以設定 cookie 了。&lt;/p&gt;
&lt;p&gt;ps.最新的 safari 13.1 擋掉了這個方法，ooxx...。&lt;/p&gt;
&lt;p&gt;但是在 chrome，就無法這樣處理了，android 實現阻擋的方法不一樣，它是讓 third-party 可以存 cookie，但是無法取出 cookie。&lt;/p&gt;
&lt;p&gt;若要完美處理 Block third-party Cookie 唯一解法就是改用 local Storage 或是 Session Storage，前幾天在 Line Liff 上看到也是用 Session Storage 來處理 token。&lt;/p&gt;
&lt;h2&gt;頁面無法倒轉情況&lt;/h2&gt;
&lt;p&gt;最近桌機 safari 的某個與 cookie 相關功能失效，就是因為 block third-party cookie 導致，那時同事 hotfix 做法非常簡單暴力，就是判斷 safari，直接轉導頁面過去 set cookie，再轉導回來。&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;寫這篇是希望有人遇到 cookie 無法設定的問題，提供一些解決的方法。&lt;/p&gt;
&lt;p&gt;另外還有 Web in app 時，也有很多狀態需要確認，每個 app 可能都有不一樣的設定，推薦大家一個 debug 工具，這工具可以會顯示 element、console、network、web storage，可以大量減少手機裝置 debug 的痛苦，web in app 無法連線桌機的 devTool 極高痛苦度。&lt;/p&gt;
&lt;p&gt;工具: &lt;a href=&quot;https://github.com/Tencent/vConsole&quot; title=&quot;Tencent vConsole&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Tencent vConsole&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前幾天 google 公告兩年後要全面阻擋第三方 cookie，這對於前端又是很大的考驗，看來未來要開發上，要多思考無法避免成為第三方狀況下，轉而使用 Session Storage、Local Storage。&lt;/p&gt;
&lt;p&gt;感謝閱讀!!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Redux multiple dispatch，batch redux-thunk]]></title><description><![CDATA[redux 核心更新 flow dispatch action => reducer => store，當你用 redux 運行多個 dispatch 時，每一個 dispatch 都會獨立更新下去的，這代表著你會 update component…]]></description><link>https://ianccy.com/2019-11-reduxdispatch/</link><guid isPermaLink="false">https://ianccy.com/2019-11-reduxdispatch/</guid><pubDate>Sat, 30 Nov 2019 11:31:35 GMT</pubDate><content:encoded>&lt;p&gt;redux 核心更新 flow &lt;code&gt;dispatch action =&gt; reducer =&gt; store&lt;/code&gt;，當你用 redux 運行多個 dispatch 時，每一個 dispatch 都會獨立更新下去的，這代表著你會 update component 多次，如果你的更新資料又彼此關聯，就可能會發生錯誤。&lt;/p&gt;
&lt;p&gt;目前執行的專案，資料都是 linked list，若沒有注意好 dispatch 更新執行順序的話，時常會遇到問題。&lt;/p&gt;
&lt;!--- ![redux-dispatch](../images/redux-dispatch.png &quot;redux-dispatch&quot;) ---&gt;
&lt;ul&gt;
&lt;li&gt;多個 dispatch 更新&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function initINFO (){
  fetch(`API_URL/getCommentList`)
    .then(res =&gt; res.json)
    .then(data =&gt;
      // if ADD_USERCOMMENT update component
      // and it depends userInfo data
      // component maybe happen error
      dispatch({type: ADD_USERCOMMENT, payload: data.list})
      if (data.userInfo) {
        dispatch({type: INIT_INFO, payload: data.userInfo})
      }
    )
    .catch(err =&gt; showError(err))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;處理的做法就是直接封裝整個 dispatch，讓每個 dispatch 都先不要往下執行 update component。&lt;/p&gt;
&lt;h2&gt;redux batch&lt;/h2&gt;
&lt;p&gt;react redux v7 有提供 batch，讓我們能直接封裝多個 dispatch，這是依賴 react 的 unstable&lt;em&gt;batchedUpdate，讓 rerender 這件事情能夠被卡住，react 實現方法大致上就是用 shouldBatchUpdates 變數搭配 fiber schedule 來判斷更新，讓更新這件事變成同步，詳細可直接看下方 react unstable&lt;/em&gt;batchedUpdates source code。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;batch 使用方法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { batch } from &apos;react-redux&apos;;
function myThunk() {
    return (dispatch, getState) =&gt; {
        // should only result in one combined re-render, not two
        batch(() =&gt; {
            dispatch(increment());
            dispatch(increment());
        });
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/reduxjs/redux/blob/a5739d9455afbed663a4ca1fcac002988c885fcb/docs/faq/Performance.md#how-can-i-reduce-the-number-of-store-update-events&quot; title=&quot;react redux github batch Q&amp;#x26;A&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;react redux github batch Q&amp;#x26;A&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react/commit/b41883fc708cd24d77dcaa767cde814b50b457fe&quot; title=&quot;react unstable_batchedUpdates source code&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;react unstable_batchedUpdates source code&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;redux thunk&lt;/h2&gt;
&lt;p&gt;redux thunk 同樣可以幫助我們處理多個 dispatch，但是與 batch 原理不大相同，redux thunk，是將 dispatch 往後延遲到最後一次執行。&lt;/p&gt;
&lt;p&gt;乍聽之下可能覺得這有點魔幻，但我貼上 redux thunk 的介紹你一定會恍然大悟。redux thunk 就是將 dispatch 封裝起來在最後一次真正執行 store.dispatch，所以你就只會觸發一次的 redux store update，進而達到只 rerender 一次。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// calculation of 1 + 2 is immediate
// x === 3
let x = 1 + 2;

// calculation of 1 + 2 is delayed
// foo can be called later to perform the calculation
// foo is a thunk!
let foo = () =&gt; 1 + 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;what is thunk&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// calculation of 1 + 2 is immediate
// x === 3
let x = 1 + 2;

// calculation of 1 + 2 is delayed
// foo can be called later to perform the calculation
// foo is a thunk!
let foo = () =&gt; 1 + 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Add thunk on redux middleWare&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { createStore, applyMiddleware } from &apos;redux&apos;;
import thunk from &apos;redux-thunk&apos;;
import reducers from &apos;../redux/reducers&apos;;

const store = createStore(reducers, applyMiddleware(thunk));

function fetchUser(data) {
    return (dispatch, getState) =&gt; {
        dispatch({ type: ADD_USERCOMMENT, payload: data.list });
        if (data.userInfo) {
            dispatch({ type: INIT_INFO, payload: data.userInfo });
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;extraArgument 不用理會，這是新功能讓使用者客製化增加 thunk 的參數，action 會是我們傳入的 action creator，當 action creator 是一個 function，就執行 action creator function，如果不是就執行 next 帶入 action creator，正常的執行 dispatch。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://redux.js.org/api/applymiddleware&quot; title=&quot;redux applymiddleware&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;redux applymiddleware&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;thunk source code&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function createThunkMiddleware(extraArgument) {
    return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {
        if (typeof action === &apos;function&apos;) {
            return action(dispatch, getState, extraArgument);
        }

        return next(action);
    };
}

const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

export default thunk;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/reduxjs/redux-thunk/blob/master/src/index.js&quot; title=&quot;redux thunk&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;redux thunk&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;舊版 applyMiddleWare (github 只剩 typescript...)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// middlewares argument is pass thunk
export default function(...middlewares) {
    return createStore =&gt; (reducers, initialState, enhancer) =&gt; {
        const store = createStore(reducers, initialState, enhancer);
        const dispatch = store.dispatch;
        const chain = [];
        const middleWareAPI = {
            getState: store.getState,
            dispatch: action =&gt; dispatch(action)
        };

        chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));
        dispatch = compose(...chain)(store.dispatch); // store.dispatch or dispatch both work
        // compose will do following thing:
        /*
         * a, b, c ==&gt; a(b(c())), indeed, it is just a reduce and store.dispatch will be an initial value
         */
        return {
            ...store,
            dispatch
        };
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;redux thunk code 很優美，完美的示範如何使用 redux 的 middleWare，邏輯清楚又不複雜。我一定不會說這篇文章是為了分享 redux thunk。&lt;/p&gt;
&lt;p&gt;改天再來研究、分享更優美的 redux。&lt;/p&gt;
&lt;p&gt;這兩個方法 &lt;code&gt;batch&lt;/code&gt;、&lt;code&gt;redux thunk&lt;/code&gt; 都是目前專案都有用到的方法，至於其他就改天再另外介紹。 batch 因為與 react fiber 更新 component 機制有關，這部分較複雜，我對這塊沒有特別研究...，無法提供太多看法。&lt;/p&gt;
&lt;p&gt;感謝閱讀，以上有錯誤再麻煩留言或私訊。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Unit Test with Jest 單元測試]]></title><description><![CDATA[Unit Test(單元測試)，針對程式的最小單位，進行測試，最小單位可能是一個 function，或一個 component、class…]]></description><link>https://ianccy.com/2019-09-jestunit/</link><guid isPermaLink="false">https://ianccy.com/2019-09-jestunit/</guid><pubDate>Sun, 29 Sep 2019 23:47:10 GMT</pubDate><content:encoded>&lt;p&gt;Unit Test(單元測試)，針對程式的最小單位，進行測試，最小單位可能是一個 function，或一個 component、class 等等，執行單元測試是為了確保每個功能都能夠正常執行，提早發現並找出問題所在。&lt;/p&gt;
&lt;p&gt;目前正在開發新專案，但又要兼顧維運另個舊專案，舊專案是公司核心產品，常常需要改動需求，因為新專案 deadline 緊迫，不大有時間詳細的測試改動，最近疊加太多功能，導致連動出現滿多 bug，因為這事件，更讓我們重視測試的重要性。&lt;/p&gt;
&lt;!--- ![react unit test](../images/reactunittest.png &quot;react unit test&quot;) ---&gt;
&lt;p&gt;接下來就來針對 react hooks 做 component testing。&lt;/p&gt;
&lt;h2&gt;安裝測試工具 Jest&lt;/h2&gt;
&lt;p&gt;Jest 是由 facebook 開源的工具，源自於 Jasmine 延伸開發，設定少、輕巧，官方文件非常清楚，提供斷言庫、mocking data 等，Jest 算是我們 test 的 runner，可以再搭配 enzyme、puppeteer 等等執行，讓 test 能更齊全。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;npm install --save-dev jest
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;編輯 package.json&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  &quot;scripts&quot;: {
    ...
    &quot;test&quot;: &quot;jest&quot;,
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行 Jest 會預設抓取 &lt;code&gt;__tests__&lt;/code&gt; folder 內 js、ts 檔案，或是 fileName 有 spec、test 的 js ts 檔案 來跑測試， 假設你有用到 babel，或是其他 css 編譯工具，則需要設定 jest config。&lt;/p&gt;
&lt;p&gt;規則預設&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;[&apos;**/__tests__/**/*.[jt]s?(x)&apos;, &apos;**/?(*.)+(spec|test).[jt]s?(x)&apos;];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;官方文件: &lt;a href=&quot;https://jestjs.io/docs/en/getting-started&quot; title=&quot;Jest starter guide&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Jest starter guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Jest 主要依賴幾個 function 執行測試，describe function 可以讓我們對這一個測試做命名，以便後面執行測試追蹤，test function 則是讓我們定義某個 test case，例如範例，我們用 describe 測試包覆多種狀況來測試，expect 則是讓我們丟入 function 做 return，toBe 就是預期測試結果是否符合預期。&lt;/p&gt;
&lt;p&gt;官方文件: &lt;a href=&quot;https://jestjs.io/docs/en/using-matchers&quot; title=&quot;Jest 斷言方式&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Jest 斷言方式&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Jest 使用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;describe(&apos;Test sum&apos;, () =&gt; {
    test(&apos;function return 0&apos;, () =&gt; {
        expect(sum(0)).toBe(0);
    });
    test(&apos;function sum 0, 1 return 1&apos;, () =&gt; {
        expect(sum(0, 1)).toBe(1);
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目前新專案是純倚賴 Jest 來測試，主要規劃會以 function test 以及 end to end 為主，主要先針對最重要的 function 做不同情境測試。&lt;/p&gt;
&lt;p&gt;安裝完成有遇到 react-script start 會有 jest error，依照提示移除 jest、node_modules、package-lock.json，並重新安裝即可解決。&lt;/p&gt;
&lt;h2&gt;react-test-renderer Snapshot Testing&lt;/h2&gt;
&lt;p&gt;剛好在 react test guide 看到，好奇順便研究一下，react-test-renderer 是 facebook 開發的工具，功能直覺簡單，是用來實現不需要依賴瀏覽器 render component 執行 test，首先會幫你 render compoent，並可讓你執行 toMatchSnapshot 匯出元件 render Snaphot，也可在依照 render component 模擬更新互動，更新後狀態也可匯出 snapshot，另外也可以純取值比較。&lt;/p&gt;
&lt;p&gt;如果你元件經常要更新，可想而知你這份 snapshot testing 會經常需要更新，但如果穩定，就可以直接測試出 component 與資料不同的更新樣貌。&lt;/p&gt;
&lt;p&gt;文件: &lt;a href=&quot;https://reactjs.org/docs/test-renderer.html#testrenderer&quot; title=&quot;react-test-renderer&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;react-test-renderer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是簡單的元件，主要測試是觸發 &lt;code&gt;&amp;#x3C;span&gt;&lt;/code&gt; 的 onClick 讓 state count 更新。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function TodoView() {
    const inputEl = useRef(null);
    const [todoList, addTodo, deleteToDo] = useTodoList([], inputEl);
    const [count, setCount] = useState(0);

    return (
        &amp;#x3C;div&gt;
            &amp;#x3C;span onClick={() =&gt; setCount(count + 1)}&gt;Counter : {count}&amp;#x3C;/span&gt;
            ...
        &amp;#x3C;/div&gt;
    );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下方為實際使用範例，主要邏輯就是使用 create render component，再把元件資料轉格式匯出 snapshot，並可以用 act 來調用 component function，直接拉 props function 用會有 error warning，主要用起來困難點會是在 selector，還是如何整理 snapshot 匯出格式，幫助我們日後測試。&lt;/p&gt;
&lt;p&gt;目前專案尚未導入 snapshot test，因為專案還在不斷改動中，評估 component test 維運成本過高先略過。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;src/&lt;strong&gt;testSnap&lt;/strong&gt;/TodoView.test.js&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React from &apos;react&apos;;
import { create, act } from &apos;react-test-renderer&apos;;
import TodoView from &apos;/container/TodoView&apos;;

describe(&apos;TodoView component&apos;, () =&gt; {
    test(&apos;it shows the expected text when clicked&apos;, () =&gt; {
        let component;
        act(() =&gt; {
            component = create(&amp;#x3C;TodoView /&gt;);
        });
        let tree = component.toJSON();
        expect(tree).toMatchSnapshot();
        const instance = component.root;

        const button = instance.findByType(&apos;span&apos;);
        act(() =&gt; button.props.onClick());
        expect(button.props.children.join()).toBe(&apos;Counter : ,1&apos;);
        expect(button.props.children).toMatchSnapshot();
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Component Testing @testing-library/react&lt;/h2&gt;
&lt;p&gt;React 官方範例是可以依賴內部 function act 去 render component，並依賴 dispatch event 去觸發事件，但若是複雜，官方更推薦使用 @testing-library/react，這是一套專注於測試 user interactive 的工具，可以讓我們模擬 select component -&gt; click，有別於 enzyme 依賴執行 function trigger 更新 component。&lt;/p&gt;
&lt;p&gt;這套工具是同事推薦的，react testing library 專注的方向符合我們的需要，更能貼近使用者實際的互動。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React 官方 test note&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;We recommend using React Testing Library which is designed to
enable and encourage writing tests that use your components
as the end users do.

Alternatively, Airbnb has released a testing utility called Enzyme,
which makes it easy to assert, manipulate, and traverse your
React Components’ output.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下方為 TypeInInput 的元件，預期當我們 pass text 會 render 出字串，並觸發 onChange event 傳遞 value，再來比較 input 內的 value 是否符合，接下來就來測試這個情境。&lt;/p&gt;
&lt;p&gt;@testing-library/react 主要依賴 render 來 render component，fireEvent 則讓我們可以觸發事件(click、change、dispatch Event)。&lt;/p&gt;
&lt;p&gt;主要流程大致為 render component，並接受返回的 function，各種 selector 都會在這時候取得，目前寫起來最順手是利用 getByTestId 搭配 data-testid，以往再寫 react component，會比較少寫 class or id，利用 tag 或是 string 來做選擇，難度更是麻煩，這些更常會因為需求更新。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TypeInInput Component&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React, { useState } from &apos;react&apos;;
import { render, fireEvent } from &apos;@testing-library/react&apos;;

function TypeInInput({ text }) {
    const [value, setValue] = useState(&apos;&apos;);
    const onChangeValue = e =&gt; {
        setValue(e.target.value);
    };
    return (
        &amp;#x3C;div&gt;
            &amp;#x3C;label&gt;{text}&amp;#x3C;/label&gt;
            &amp;#x3C;input data-testid=&quot;typeIn&quot; value={value} onChange={onChangeValue} /&gt;
        &amp;#x3C;/div&gt;
    );
}

describe(&apos;Test TypeInInput&apos;, () =&gt; {
    const text = &apos;email&apos;;
    test(&apos;change event&apos;, () =&gt; {
        const { getByText } = render(&amp;#x3C;TypeInInput text={text} /&gt;);
        const title = getByText(/email/);
        expect(title.textContent).toEqual(text);
    });
    test(&apos;change event&apos;, () =&gt; {
        const { getByTestId } = render(&amp;#x3C;TypeInInput text={text} /&gt;);
        const typeInElem = getByTestId(&apos;typeIn&apos;);
        const test = &apos;emample@gmail.com&apos;;
        fireEvent.change(typeInElem, { target: { value: test } });
        expect(typeInElem.value).toEqual(test);
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至於比較複雜的 async function api 的操作，記得要修改 babel config 執行非同步，以及安裝 @testing-library/jest-dom 執行 toHaveTextContent，讓斷言能更靈活。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;babel.config.js&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;[
    &apos;@babel/preset-env&apos;,
    {
        targets: {
            node: &apos;current&apos;
        }
    }
];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fetch 接受 url、axios (模擬 api call) 兩個 prop。Component 內用到 state、useCallback、建立 function fetchData，&lt;/p&gt;
&lt;p&gt;Component 預期狀態&lt;/p&gt;
&lt;p&gt;useEffect 會在元件 render 傳入 url 以及 apiCall function，並執行 click element 觸發 fetchData 調用 apiCall 更新 state。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React, { useState, useCallback } from &apos;react&apos;;
import axios from &apos;axios&apos;;
import { render, fireEvent, waitForElement } from &apos;@testing-library/react&apos;;

import &apos;@testing-library/jest-dom/extend-expect&apos;;

function Fetch({ url, apiCall }) {
    const [data, setDate] = useState();
    const fetchData = useCallback(async () =&gt; {
        const response = await apiCall.get(url);
        setDate(response.data);
    }, [apiCall, url]);
    return (
        &amp;#x3C;div&gt;
            &amp;#x3C;button onClick={fetchData}&gt;Fetch&amp;#x3C;/button&gt;
            {data ? &amp;#x3C;span data-testid=&quot;fetch&quot;&gt;{data.test}&amp;#x3C;/span&gt; : null}
        &amp;#x3C;/div&gt;
    );
}

test(&apos;Fetch makes an API call and displays the greeting&apos;, async () =&gt; {
    const fakeAxios = {
        get: jest.fn(() =&gt; Promise.resolve({ data: { test: &apos;hello world&apos; } }))
    };
    const url = &apos;https://example.com/get-hello-there&apos;;
    const { getByText, getByTestId } = render(&amp;#x3C;Fetch url={url} apiCall={fakeAxios} /&gt;);
    fireEvent.click(getByText(/fetch/i));

    const fetchNode = await waitForElement(() =&gt; getByTestId(&apos;fetch&apos;));

    expect(fetchNode).toHaveTextContent(&apos;hello world&apos;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更複雜例子也可以查閱作者在 codesandbox 寫的各種 sample code，&lt;/p&gt;
&lt;p&gt;作者範例: &lt;a href=&quot;https://codesandbox.io/s/github/kentcdodds/react-testing-library-examples&quot; title=&quot;kentcdodds codesandbox&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;kentcdodds codesandbox&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;單元測試在我剛寫程式時，認為測試 case 是自己預期的，還主觀的認為沒什麼用，因為開發者所預期的測試一定充滿盲點，沒太大用處。但我在實際寫幾個測試後，發現最大的功用在於程式的 clear，當你在寫某個功能時，能更專注在預期判斷 input output，也有助於你思考 function 架構更清楚。&lt;/p&gt;
&lt;p&gt;你可能會說每次測試都沒抓到真實發生的 bug，這時就要換個角度思考，為什麼測試 case 沒測試到，是不是情境 case 太過簡單、理想，是不是需要再擴展更多 case。&lt;/p&gt;
&lt;p&gt;新專案不幸的重構了大概兩次左右...，還是最重要的資料更新，運氣很好的在改動中有在測試階段發現問題，我大概被抓到兩次問題，當時心想這個 testing case 的時間成本回本了 XDD，不斷讓我佩服 unit test 發揮做用。&lt;/p&gt;
&lt;p&gt;內文這些實際範例，寫起來最卡的部分在環境設定，非同步測試...、編譯錯誤等等，還有熟悉 selector 與斷言方式，不像是 enzyme 有 cherrio 支援類似 jquery 的語法，剩下就是各種使用測試技巧，這個寫更多案例後會更熟悉。後續有 react-testing-library 實際導入專案會再多寫相關內容。&lt;/p&gt;
&lt;p&gt;以上若有錯誤，歡迎留言提醒，&lt;/p&gt;
&lt;p&gt;感謝閱讀。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[GA跨網域追蹤 google analytics cross-domain tracking]]></title><description><![CDATA[如果你有多個網站服務，每個服務又是各自在不同網域上，就會遇到一個棘手的問題，無法確切的追蹤使用者數據。或許你現在還沒遇到，但我來舉個例子讓你理解問題怎麼發生。 情境假設，你今天操作 google ads 的 landing page 是 example.com…]]></description><link>https://ianccy.com/2019-08-gacrossdomain/</link><guid isPermaLink="false">https://ianccy.com/2019-08-gacrossdomain/</guid><pubDate>Sun, 04 Aug 2019 14:28:23 GMT</pubDate><content:encoded>&lt;p&gt;如果你有多個網站服務，每個服務又是各自在不同網域上，就會遇到一個棘手的問題，無法確切的追蹤使用者數據。或許你現在還沒遇到，但我來舉個例子讓你理解問題怎麼發生。&lt;/p&gt;
&lt;p&gt;情境假設，你今天操作 google ads 的 landing page 是 example.com，但是使用者後續造訪頁面是 buyservice.com，你的 buyservice.com 上 google analytics 數據就會有問題，會在報表看到使用者的 &lt;code&gt;參考來源&lt;/code&gt; 會是 example.com，而不是 google ads ，這樣就會無法正確估算 example.com 帶給 buyservice.com 的廣告效益。&lt;/p&gt;
&lt;!--- ![google analytics cross domain tracking](../images/gacrossdomain.png &quot;google analytics cross domain tracking&quot;) ---&gt;
&lt;p&gt;這是因為 google analytics 數據是依賴 cookie 做定位使用者 (Client-ID)，但是 cookie 有個限制， 同一個 cookie 只能在同 domain 下共同享有，所以跨網域就會斷掉追蹤數據，但還好 google analytics 有提供 &lt;code&gt;跨網域追蹤&lt;/code&gt; 功能，讓我們解決這個問題。後面就來嘗試跨網域追蹤設定。&lt;/p&gt;
&lt;p&gt;官方教學: &lt;a href=&quot;https://support.google.com/analytics/answer/1034342?hl=zh-Hant&quot; title=&quot;設定跨網域追蹤 (analytics.js)&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;設定跨網域追蹤 (analytics.js)&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;google analytics 追蹤碼修改&lt;/h2&gt;
&lt;p&gt;需要找出你的 google analytics 設定追蹤碼，再針對 &lt;code&gt;ga(&apos;create&apos;, &apos;UA-XXXXXXX-Y&apos;, &apos;你的網址&apos;)&lt;/code&gt; 修改，需要改為 auto，並在後面加上 {&apos;allowLinker&apos;: true} 參數，後面再加上 ｀ ga(&apos;require&apos;, &apos;linker&apos;);｀ ，並加上 &lt;code&gt;ga(&apos;linker:autoLink&apos;, [&apos;相對應的 domain&apos;] )&lt;/code&gt;，這樣就完成了設定。&lt;/p&gt;
&lt;h3&gt;傳統追蹤碼&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;example.com 修改追蹤碼&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  ga(&apos;create&apos;, &apos;UA-XXXXXXX-Y&apos;, &apos;example.com&apos;);
  對這段程式碼進行下列變更 (紅色粗體文字是需要變更的部分)：

  ga(&apos;create&apos;, &apos;UA-XXXXXXX-Y&apos;, &apos;auto&apos;, {&apos;allowLinker&apos;: true});
  ga(&apos;require&apos;, &apos;linker&apos;);
  ga(&apos;linker:autoLink&apos;, [&apos;buyservice.com&apos;] );
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;buyservice.com 修改追蹤碼&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;ga(&apos;create&apos;, &apos;UA-XXXXXXX-Y&apos;, &apos;auto&apos;, { allowLinker: true });
ga(&apos;require&apos;, &apos;linker&apos;);
ga(&apos;linker:autoLink&apos;, [&apos;example.com&apos;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;tag manager 追蹤碼&lt;/h3&gt;
&lt;p&gt;如果你是用 tag manager 設定 google analytics 的話，在 google analaytics 追增設定內的欄位設定(Field)，再增加 allowLinker 值 true，自動連結網址就填上要連動的網域。這樣就完成 tag manager 的設定了。記得 tag manager 的改動要提交更新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/gacrossdomaintagmanager.png&quot; alt=&quot;google analytics cross domain tagmanager&quot; title=&quot;google analytics cross domain tagmanager&quot;&gt;&lt;/p&gt;
&lt;h3&gt;google analytics 設定排除參照連結&lt;/h3&gt;
&lt;p&gt;當一個網站到另一個網站時，google analytics 會自動建立新的工作階段，如果要跨多個網域追蹤單一工作階段，要把相對應網域加進參照連結網址排除清單。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/gacrossdomainsetting.png&quot; alt=&quot;google analytics cross domain setting&quot; title=&quot;google analytics cross domain setting&quot;&gt;&lt;/p&gt;
&lt;h2&gt;網址參數 _ga&lt;/h2&gt;
&lt;p&gt;完成設定之後，就可以測試看看效果如何，下方是完成設定的 demo ，如果你點擊連結 go to &lt;a href=&quot;https://thawing-stream-74537.herokuapp.com/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://thawing-stream-74537.herokuapp.com/&lt;/a&gt; 後，會發現網址多一段參數 ?_ga=2.189459235.924386874.1564911255-1438900564.1564911255 ，這就是 google analytics 傳遞 client_id 的參數，依賴這參數可以讓工作階段在跨網域下不中斷。&lt;/p&gt;
&lt;iframe src=&quot;https://test.ianccy.com/gacrossdomain.html&quot; width=&quot;100%&quot; height=&quot;400&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;共用 google analytics 追蹤代碼&lt;/h2&gt;
&lt;p&gt;如果你是分開兩個 google analytics 帳戶，還是會無法延續追蹤資訊，只能共用 client&lt;em&gt;id ，但這意義不大，因為通常 client&lt;/em&gt;id 都會設定成會員 id，所以網站通常都會共用 client_id，所以我們要再多額外開一個檢視資料，產生一組新的追蹤代碼，讓兩個互相跨 domain 網站共用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;載入 &lt;a href=&quot;https://test.ianccy.com/gacrossdomain.html?utm_source=google&amp;#x26;utm_medium=cpc&amp;#x26;utm_campaign=weekend_sale01&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://test.ianccy.com/gacrossdomain.html?utm_source=google&amp;#x26;utm_medium=cpc&amp;#x26;utm_campaign=weekend_sale01&lt;/a&gt; utm 數據
&lt;img src=&quot;../images/gacrossdomainview.png&quot; alt=&quot;google analytics cross domain view data&quot; title=&quot;google analytics cross domain setting&quot;&gt;&lt;/li&gt;
&lt;li&gt;載入連結後 &lt;a href=&quot;https://thawing-stream-74537.herokuapp.com&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://thawing-stream-74537.herokuapp.com&lt;/a&gt; 數據
&lt;img src=&quot;../images/gacrossdomainview2.png&quot; alt=&quot;google analytics cross domain view data&quot; title=&quot;google analytics cross domain setting&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這樣就發現我們把 utm 的追蹤資訊延續下去了，一般狀況沒設定 cross domain 共享 client_id 的話，會變成兩個 session，因為 cookie 無法共享，但這樣對於追蹤來說，就有非常大的幫助，我們不用在擔心數據掉落的問題。&lt;/p&gt;
&lt;h2&gt;報表檢視增加 domain&lt;/h2&gt;
&lt;p&gt;如果在檢視報表時，沒有顯示 domain 的話，會不方便直觀分辨網址的 domain 問題，因為 google analytics 預設不顯示 domain，我們要在設定增加顯示，以便我們觀看數據。&lt;/p&gt;
&lt;p&gt;點選篩選器 =&gt; 自訂 =&gt; 進階，分別在前兩個 選擇主機名稱 內容填上 &lt;code&gt;(.*)&lt;/code&gt;，這代表我們要取全部的 domain name，請求 URI 則是 填上 &lt;code&gt;(.*)&lt;/code&gt;，取用全部請求網址，後面 輸出至 -&gt; 建構函式 再分別選擇 URI，內容填上 &lt;code&gt;$A1$B1&lt;/code&gt;，取用前面兩個條件拿到全部值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;google analytics 篩選器設定
&lt;img src=&quot;../images/gacrossdomainsetting3.png&quot; alt=&quot;google analytics cross domain setting&quot; title=&quot;google analytics cross domain setting&quot;&gt;&lt;/li&gt;
&lt;li&gt;檢視報表
&lt;img src=&quot;../images/gacrossdomainview3.png&quot; alt=&quot;google analytics cross domain view data&quot; title=&quot;google analytics cross domain view data&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這樣就完成了整個設定，達到了跨網域追蹤的功能！&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;雖然這跨網域追蹤一直以來都存在著，以前擔任行銷時，可惜沒有使用到這個功能，公司網址包含 blog 的話大概有 6 個，如果都有設定的話，就更能了解轉換的流程。以往都只能在站內連結上加上 utm，被動地去追蹤數據，但假設是 google ads 進來的流量，但到第二個 domain 成效歸屬就被認為是站內連結，模糊了數據的焦點。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Context API 跨元件傳遞資料]]></title><description><![CDATA[React 是單向資料流，利用 React.createElement 建構出整個 element tree 結構，使用者利用 state 及 props 處理元件資料，並搭配觸發 react 更新元件。因為 props 是需要傳遞的，所以時常會遇到 props…]]></description><link>https://ianccy.com/2019-07-reactcontextapi/</link><guid isPermaLink="false">https://ianccy.com/2019-07-reactcontextapi/</guid><pubDate>Sun, 28 Jul 2019 22:40:54 GMT</pubDate><content:encoded>&lt;p&gt;React 是單向資料流，利用 React.createElement 建構出整個 element tree 結構，使用者利用 state 及 props 處理元件資料，並搭配觸發 react 更新元件。因為 props 是需要傳遞的，所以時常會遇到 props 需要傳很多層。React 為了解決這問題，建立了 context API 的功能，要功能就是跨元件傳遞資料，像是知名的 state 管理工具 react-redux 就是依賴 context 實現的。&lt;/p&gt;
&lt;p&gt;最近就遇到所有 API Error handle 都需要用到新欄位的值，這個值就幾乎傳到到所有元件，中間還不小心遺漏傳遞一個元件，發生些問題...。現在回過頭想想用 context 處理問題會少很多。&lt;/p&gt;
&lt;!--- ![React Context](../images/react.png &quot;React Context&quot;) ---&gt;
&lt;ul&gt;
&lt;li&gt;Pass props Hell&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;Header islogin={islogin}/&gt;
// inside Header Element
  &amp;#x3C;Navbar islogin={islogin} /&gt;
  // inside Navbar Element
    &amp;#x3C;Account islogin={islogin} /&gt;
    // inside Account Element
      &amp;#x3C;User islogin={islogin} /&gt;
        {islogin ?
          &amp;#x3C;Button onClick={Logout}&gt;Logout&amp;#x3C;/Button&gt;
        :

// Pass all props
// it will make child Components rerender by all props update
&amp;#x3C;Header {...props}/&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;createContext 建立資料&lt;/h2&gt;
&lt;p&gt;首先必須先在需要使用的元件內，先執行&lt;code&gt;React.createContext&lt;/code&gt;建立一個 context，其中參數 defaultValue 只會在沒有 Provider 傳遞 value 才會使用到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React.createContext return object&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// React.createContext(defaultValue);
const MyContext = React.createContext({isLogin: false});

$$typeof: Symbol(react.context)
Consumer: {$$typeof: Symbol(react.context), _context: {…}, _calculateChangedBits: null, …}
Provider: {$$typeof: Symbol(react.provider), _context: {…}}
_calculateChangedBits: null
_currentRenderer: {}
_currentRenderer2: null
_currentValue: {isLogin: false}
_currentValue2: {isLogin: false}
_threadCount: 0
__proto__: Object
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Provider 提供 value&lt;/h2&gt;
&lt;p&gt;調用 createContext 後，回傳的物件會帶有 Provider、Consumer 元件，Provider 可以提供 value，給相對應最接近的 Consumer 使用 value，最特別的是 Provider 更新 value 後，會觸發相對應的 Consumer 更新元件，並且無視 shouldComponentUpdate 限制 (這在舊版 Context 無法達到)。&lt;/p&gt;
&lt;p&gt;記得要 export React.createContext 回傳值，讓其他元件可以直接 import 使用 Consumer。還有提醒要注意 Provider 的 update 狀態，如果 Provider 的元件會頻繁更新，但 Provider 的 value 會每次都是新物件，會促使有 Cosumer 的元件每次都 update。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當元件 rerender 會同時更新 Consumer 調用的元件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// isLogin will forever new one
  render() {
    return (
      &amp;#x3C;MyContext.Provider value={{ isLogin: isLogin }}&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;傳遞的值保持同一參考 MyContext Provider&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;export const MyContext = React.createContext({ isLogin: false });

export default class Container extends Component {
  state = {
    isLoginStatus: { isLogin: true }
  };

  render() {
    const { isLoginStatus } = this.state;
    return (
      &amp;#x3C;MyContext.Provider value={isLoginStatus}&gt;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Consumer 提取 value&lt;/h2&gt;
&lt;p&gt;Consumer 元件可以獲取 context 資料，假設沒有最接近的 Provider 提供 value，Cosumer 會取到 createContext 的 defaultvalue。若有 Provider 提供值，則是會保持訂閱更新，也就是達到跨元件同步資料，並 update component。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React from &apos;react&apos;;
import { MyContext } from &apos;../Container&apos;;

export default function Account() {
    return (
        &amp;#x3C;div className=&quot;account&quot;&gt;
            &amp;#x3C;MyContext.Consumer&gt;
                {({ isLogin }) =&gt; {
                    return isLogin ? &apos;Logout&apos; : &apos;Login&apos;;
                }}
            &amp;#x3C;/MyContext.Consumer&gt;
        &amp;#x3C;/div&gt;
    );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://codesandbox.io/s/relaxed-banzai-su39f&quot; title=&quot;Consumer codesandbox&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Consumer codesandbox&lt;/a&gt;&lt;/p&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/relaxed-banzai-su39f?fontsize=12,result&quot; width=&quot;100%&quot; height=&quot;400&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;context 更新 rerender 取用元件&lt;/h2&gt;
&lt;p&gt;context 的 Provider 更新 value 時，會一起更新 context Consumer 的取用元件，並且無視於 shouldComponentUpdate。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codesandbox.io/s/happy-moon-ypeqm&quot; title=&quot;Consumer shouldComponentUpdate codesandbox&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Consumer shouldComponentUpdate codesandbox&lt;/a&gt;&lt;/p&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/happy-moon-ypeqm?fontsize=12,result&quot; width=&quot;100%&quot; height=&quot;400&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;contextType 取值&lt;/h2&gt;
&lt;p&gt;contextType 是直接在 react 的 component 的 instance 再加上 context，所以只能用在 class Component，一個元件只能使用一個 context。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React, { Component } from &apos;react&apos;;
import MyContext from &apos;../context/MyContext&apos;;

export default class Account extends Component {
    static contextType = MyContext;
    render() {
        const { isLogin, setLogin } = this.context;
        return (
            &amp;#x3C;div className=&quot;account&quot;&gt;
                &amp;#x3C;div&gt;
                    {isLogin ? &apos;Logout&apos; : &apos;Login&apos;}
                    &amp;#x3C;button onClick={setLogin}&gt;toggleLogin&amp;#x3C;/button&gt;
                &amp;#x3C;/div&gt;
            &amp;#x3C;/div&gt;
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我在這邊有遇到一個問題，在 Container component export context，並在 Account 引用 Container export 的 context 時，會發生我取不到值得問題，這是因為循環依賴的關係，在我們 Account 引用 Container 內的 MyContext 時，ES6 只會是 referrence MyContext undefined 狀態，實際在 Container 還尚未建立 createContext，這個 Account 又會再初始化階段就執行 MyContext，導致拿到 empty object。&lt;/p&gt;
&lt;p&gt;解法就是獨立建 MyContext ，解除與 Container 關係，就可以避免掉循環依賴的問題。至於 Consumer 會沒有問題，因為 Consumer 是在 render 時才會調用參考，所以會拿到正確的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Container File
import Account from &quot;./components/Account&quot;;
export const MyContext = React.createContext({
  isLogin: false
});
export default class Container extends Component {
  state = {
    isLogin: true
  };
...
      &amp;#x3C;MyContext.Provider value={{ isLogin: isLogin, setLogin: this.setLogin }}&gt;
        &amp;#x3C;Account /&gt;
      &amp;#x3C;/MyContextProvider&gt;
}

// Account File

import MyContext from &quot;../Container&quot;;

export default class Account extends Component {
  // MyContext undefined
  static contextType = MyContext;
  render() {
    // empty object
    console.log(this.context);
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dan 神表示: &lt;a href=&quot;https://github.com/facebook/react/issues/13969#issuecomment-474373021&quot; title=&quot;16.6 Context API not working in class component &quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React contextType undefined GitHub issue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://railsware.com/blog/how-to-analyze-circular-dependencies-in-es6/&quot; title=&quot;how-to-analyze es6 circular-dependencies&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;how-to-analyze es6 circular-dependencies&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;獨立建立引用 context
&lt;a href=&quot;https://codesandbox.io/s/relaxed-fermat-c097p&quot; title=&quot;file context codesandbox&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;file context codesandbox&lt;/a&gt;
{% iframe &lt;a href=&quot;https://codesandbox.io/embed/relaxed-fermat-c097p?fontsize=12,result&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://codesandbox.io/embed/relaxed-fermat-c097p?fontsize=12,result&lt;/a&gt; 100% 400px %}&lt;/p&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/relaxed-fermat-c097p?fontsize=12,result&quot; width=&quot;100%&quot; height=&quot;400&quot;&gt;&lt;/iframe&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Hooks useContext&lt;/h2&gt;
&lt;p&gt;React Hooks 有可以直接調用 Context 的方法，useContext 與 Consumer 特性相似，當沒有 Provider 提供 value，就會以 defaultValue 為值，提醒有用到 useContext 的元件當 value 更新時皆會 rerender，rerender 效能不好的話，建議搭配 Memo 來做 memorize。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const value = useContext(MyContext);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Preventing rerenders with React.memo and useContext hook.
&lt;a href=&quot;https://github.com/facebook/react/issues/15156#issuecomment-474590693&quot; title=&quot;Preventing rerenders with React.memo and useContext hook.&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Preventing rerenders with React.memo and useContext hook.&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React, { useContext, useMemo } from &apos;react&apos;;
import MyContext from &apos;../context/MyContext&apos;;

export default function Account() {
    const { isLogin, setLogin } = useContext(MyContext);
    return useMemo(() =&gt; {
        return (
            &amp;#x3C;div className=&quot;account&quot;&gt;
                &amp;#x3C;div&gt;
                    {isLogin ? &apos;Logout&apos; : &apos;Login&apos;}
                    &amp;#x3C;button onClick={setLogin}&gt;toggleLogin&amp;#x3C;/button&gt;
                &amp;#x3C;/div&gt;
            &amp;#x3C;/div&gt;
        );
    }, [isLogin, setLogin]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://codesandbox.io/s/gifted-wood-8ot48&quot; title=&quot;useContext with useMemo codesandbox&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;useContext with useMemo codesandbox&lt;/a&gt;&lt;/p&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/gifted-wood-8ot48?fontsize=12,result&quot; width=&quot;100%&quot; height=&quot;400&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;會特別研究寫關於 context API 內容，是因為目前專案幾乎都沒用到，多半還是以 redux 居多，redux 更新版 hooks 也有 useSelector，也是非常好用，雖然常聽到 useReucer、useContext 幾乎可以取代 redux。&lt;/p&gt;
&lt;p&gt;但 redux 有極好用的 debug 工具，devtool 觀看變化、history、dispatch，這些都是無法取代的功能。與夥伴討論過後，認為某些無狀態不需要更新值，我們才會考慮用 context API，因為不需要 update，也沒有隨之的監控更新需求。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Google Analytics 自訂UserId 追蹤數據]]></title><description><![CDATA[分享一個 google analytics 滿好用的功能，設定 User Id，可以讓你直接在報表上找出這個使用者的 flow，包括停留時間等等詳細數據，假設你搭配會員系統給予 id 的話，你也能夠跨裝置的追蹤數據。 Goolge 說明: 設定 User ID GA…]]></description><link>https://ianccy.com/2019-06-gauserid/</link><guid isPermaLink="false">https://ianccy.com/2019-06-gauserid/</guid><pubDate>Sat, 15 Jun 2019 16:29:52 GMT</pubDate><content:encoded>&lt;p&gt;分享一個 google analytics 滿好用的功能，設定 User Id，可以讓你直接在報表上找出這個使用者的 flow，包括停留時間等等詳細數據，假設你搭配會員系統給予 id 的話，你也能夠跨裝置的追蹤數據。&lt;/p&gt;
&lt;p&gt;Goolge 說明: &lt;a href=&quot;https://support.google.com/analytics/answer/3123666?hl=zh-Hant&quot; title=&quot;設定 User ID&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;設定 User ID&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;GA 設定 User ID&lt;/h2&gt;
&lt;p&gt;GA 點選左下角設定 =&gt; 點選 追蹤設定 =&gt; 點選 User Id =&gt; 點擊 同意條款 =&gt; 點選 下一步
&lt;img src=&quot;../images/gasettinguid.png&quot; alt=&quot;gasettinguid&quot; title=&quot;gasettinguid&quot;&gt;&lt;/p&gt;
&lt;p&gt;建立 User Id 報表
&lt;img src=&quot;../images/gasettinguid2.png&quot; alt=&quot;gasettinguid&quot; title=&quot;gasettinguid&quot;&gt;&lt;/p&gt;
&lt;p&gt;打開 顯示 User-id
&lt;img src=&quot;../images/gauserid3.png&quot; alt=&quot;gasettinguid&quot; title=&quot;gasettinguid&quot;&gt;&lt;/p&gt;
&lt;p&gt;這邊千萬千萬要記得要打開 UserId 的設定，否則你報表看不到客製化的 UserId 數據。我在這邊卡了 2 小時，查網路還找不到如何顯示的教學...。&lt;/p&gt;
&lt;h2&gt;針對使用者設定 UserId&lt;/h2&gt;
&lt;p&gt;接下來就需要定義使用者的 UserId，這邊有時候會用會員編號，不要使用敏感性個資去設定即可，能讓你在報表識別出這個人是誰就可以。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 全域網站代碼的追蹤程式碼 (gtag.js)：
gtag(&apos;set&apos;, { user_id: &apos;USER_ID&apos; }); // 使用已登入的 user_id 設定 User ID。

// 通用 Analytics (分析) 追蹤程式碼 (analytics.js)：
ga(&apos;set&apos;, &apos;userId&apos;, &apos;USER_ID&apos;); // 使用已登入的 user_id 設定 User ID。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Tag manager 設定流程&lt;/h3&gt;
&lt;p&gt;稍微提一下 tag manager 設定流程，首先我們需要建立一個變數，因為我 userId 是透過 cookie 傳遞的，所以我這邊先打開&lt;code&gt;變數&lt;/code&gt;，點選使用者自定義區塊 -&gt; 點選新增。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;選擇自訂 JavaScript
&lt;img src=&quot;../images/gtmuid.png&quot; alt=&quot;gtm uid&quot; title=&quot;gtm uid&quot;&gt;&lt;/li&gt;
&lt;li&gt;function return 代表的是這個變數的值。
&lt;img src=&quot;../images/gtmuidvar.png&quot; alt=&quot;gtm uid js&quot; title=&quot;gtm uid js&quot;&gt;&lt;/li&gt;
&lt;li&gt;點選 &lt;code&gt;代碼&lt;/code&gt; -&gt; 新增/編輯 GA pageView -&gt; 點選 覆蓋變數設定 -&gt; 點選 更多設定 -&gt; 填入 userId 還有剛剛設定的 變數名稱
&lt;img src=&quot;../images/gtmgauid.png&quot; alt=&quot;gtm ga uid&quot; title=&quot;gtm ga uid&quot;&gt;&lt;/li&gt;
&lt;li&gt;完成後 -&gt; 點選提交 (或是 預覽 測試後再提交)
&lt;img src=&quot;../images/gtmgauidsubmit.png&quot; alt=&quot;gtm ga uid submit&quot; title=&quot;gtm ga uid submit&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tag manager 非常好用，會用的話可以不透過修改線上程式碼，處理許多問題、功能。&lt;/p&gt;
&lt;h2&gt;實際模擬 UserId 設定&lt;/h2&gt;
&lt;p&gt;因為 blog 沒有會員系統，就先麻煩到我剛剛建好的頁面，是使用串接 facebook web sdk 登入。&lt;/p&gt;
&lt;p&gt;登入設定 userId : &lt;a href=&quot;https://work.ianccy.com/getuid.html&quot; title=&quot;登入facebook 設定 userId&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;登入 facebook 設定 userId&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;進入畫面點擊登入後，我會把 facebook uId 設定到 cookie，之後我會將 cookie 的這個值，設定到 Google analytics UserId 中。&lt;/p&gt;
&lt;p&gt;因為 cookie 沒設定時間所以關掉視窗就會自動清掉了，別怕 XD。&lt;/p&gt;
&lt;p&gt;UserId google 政策小提醒:
&lt;code&gt;您不會上傳任何能讓 Google 識別個人身分的資料 (例如姓名、身分證字號、電子郵件地址等任何類似資料)，或是可永久識別某裝置的資料 (例如無法重設的手機專屬裝置識別碼)。&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Google analytics 報表&lt;/h2&gt;
&lt;p&gt;接下來打開剛剛建立好的 GA 報表，點選 目標對象 -&gt; 客層管理，就可以看到剛剛設定好的 UserId。點擊 UserId 即可看到詳細數據。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UserId 清單
&lt;img src=&quot;../images/gauseridview.png&quot; alt=&quot;ga userid view&quot; title=&quot;ga userid view&quot;&gt;&lt;/li&gt;
&lt;li&gt;使用者紀錄
&lt;img src=&quot;../images/gauseridinfo.png&quot; alt=&quot;ga userid info&quot; title=&quot;ga userid info&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假設你再搭配資料庫存取會員，就可以直接的看到所有會員的使用路徑，例如說，我希望看到下單的使用者，都看過哪些頁面的路徑，那你就可以依靠這方式觀察。&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;滿詭異的，一開始報表沒出現 UserId，查網路解決方法查了很久，沒想到國外都說 ga 不會顯示 UserId...，滿臉問號。&lt;/p&gt;
&lt;p&gt;話說這功能我個人是覺得滿好用的，以前服務公司就有導入使用，可以更快理解、觀察出會員的需求，雖然聽起來滿沒有隱私，很怕被追蹤的話，記得開無痕登出瀏覽網站。&lt;/p&gt;
&lt;p&gt;感謝，有問題再歡迎留言詢問。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[第一份工作]]></title><description><![CDATA[回頭看第一份工作，我從充滿熱情、到充滿自信、最後充滿失望，總共兩年時光，離職前原本心中滿腹抱怨，但現在看只覺得感慨、感激，這就是人生啊。 第一份工作對我來說很重要，所以我到現在都還記得這些。 我的辦公桌 加入團隊 之前提過面試經過，就不多說了。我剛加入團隊時，總共只有…]]></description><link>https://ianccy.com/2019-06-firstjob/</link><guid isPermaLink="false">https://ianccy.com/2019-06-firstjob/</guid><pubDate>Sat, 08 Jun 2019 01:04:48 GMT</pubDate><content:encoded>&lt;p&gt;回頭看第一份工作，我從充滿熱情、到充滿自信、最後充滿失望，總共兩年時光，離職前原本心中滿腹抱怨，但現在看只覺得感慨、感激，這就是人生啊。&lt;/p&gt;
&lt;p&gt;第一份工作對我來說很重要，所以我到現在都還記得這些。&lt;/p&gt;
&lt;!--- ![first job](../images/firestjob.png &quot;first job&quot;) ---&gt;
&lt;ul&gt;
&lt;li&gt;我的辦公桌&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;加入團隊&lt;/h2&gt;
&lt;p&gt;之前提過面試經過，就不多說了。我剛加入團隊時，總共只有 4 個人，兩個業務、一個團隊主管，再加上我，團隊是隸屬在部門底下，部門共有約 15 個人。之前業務們是兼著行銷，我進去之後就開始接手粉絲團、部落格，喔對了，這時我們業務模式主要是依賴網路填表名單，再經由業務聯繫引導購買課程。&lt;/p&gt;
&lt;p&gt;我是被指派擴展新的產品線，跟轉學課程相關的， 當時手上資源就一個部落格、粉絲團，部落格每天大概 150 流量，粉絲團大概 400 個追蹤。每天填表大概 1、2 筆而已，可以說是非常慘澹。&lt;/p&gt;
&lt;p&gt;前三個月我的週報告數字都非常難看，有時候電話量大，業務都在忙線中，我還要幫忙接電話留資料，跟我同期還有一個女業務 Angile，她是應徵行銷被小主管遊說轉業務，我那時滿擔心，主管會不會哪天看不下去，要我轉業務。&lt;/p&gt;
&lt;p&gt;但幸好當時帶我的業務 Kelly，他對這塊領域非常精通，因為她是主要負責業務，能直接回饋我學生都在問什麼問題，另外團隊成員都有 SEO 的觀念，因為團隊前主管有特別專研關係。我那時候先從經營 blog 著手，每天有空就去看社群有沒有問題，記錄起來變成我文章的內容，大概一週兩篇文章，漸漸的流量成長起來。記得當時還爬上主要關鍵字第一名。&lt;/p&gt;
&lt;p&gt;她跟小主管都是我職場的貴人，讓我不斷地問問題，鼓勵我各種方法嘗試。常會說: 你的想法聽起來不錯，可以去試試看。&lt;/p&gt;
&lt;p&gt;但可惜，過沒多久，她就離職轉換其他職務了。&lt;/p&gt;
&lt;h2&gt;曖昧的業績&lt;/h2&gt;
&lt;p&gt;團隊每週會有週會，每月會有部門月會，週會主要在業績報告，月會則是各團隊主管報告業績或進度，團隊目前共兩名業務，其中有個老前輩業務阿基，他非常厲害，對公司產品很精通，也擅長跟學生聊天、溝通，所以他業績都是最高。另一個 Angile 則是還在摸索階段，同時，她也要經營部落格，還要做業績，所以還滿辛苦的。&lt;/p&gt;
&lt;p&gt;因為我是行銷職關係，我工作主要在產生名單給業務成交，也就是說一筆訂單成交會是業務分數字給行銷，但假設客戶來電詢問，業務也要分給行銷。總結來說就是，行銷業績的好與壞與業務息息相關。業績好壞又與薪水的額外加成有關。&lt;/p&gt;
&lt;p&gt;我是能夠理解這看法，因為主管希望團隊業績能總體成長，讓行銷與業務都一起好，行銷只有我狀況下，業務成交業績都會分給我，我每個月都有不少獎金，雖然我不太知道詳細數字，那時候底薪太少也不太去注意。&lt;/p&gt;
&lt;p&gt;但這方法在人多後就不一樣了，行銷職到後面人數擴張為業務兩倍，業務分給行銷方法是均分，也就是說大家行銷不管怎做都會是一樣的薪資。&lt;/p&gt;
&lt;p&gt;當團隊行銷出現 free rider，又沒人去介入的話，團隊容易整體擺爛，或是某個行銷表現特別好，卻沒拿到相對應報酬，未來他也不會這麼拼命去做了。&lt;/p&gt;
&lt;p&gt;雖然某方面來說薪水加成頂多幾千塊，但是業績未達標的話，需要每週寫檢討報告，這東西非常麻煩...，公司副總會看，看完會直接盯你狀況。但是沒達標原因，是團隊業績不夠我分，解決辦法團隊業績要整體向上，這問題又不是一個人能解決的。&lt;/p&gt;
&lt;p&gt;恩，這問題很嚴重，直到最後都沒解決。&lt;/p&gt;
&lt;h2&gt;團隊擴張&lt;/h2&gt;
&lt;p&gt;大概過了半年後，部門主管開始建議團隊要擴張人數，公司總有個神奇想法，就是兩倍的人數就要有兩倍的營業額，恩...，各種問號，沒把邊際效益算進來。&lt;/p&gt;
&lt;p&gt;後面新進同事 Austin，部門終於有第二個行銷職同事了，後續陸續補了行銷 Song，然後又把部門行政轉職成行銷，很迅速的成長到 7 人的規模。&lt;/p&gt;
&lt;p&gt;說實在那時候我對帶新人這件事滿沒看法的，幾乎都是教完各資源使用方法，就開始讓大家各自努力，被同事問問題，我還滿常白目的回答，啊就直接 Google xxxx 啊，幾乎沒有盡到帶人責任。外加團隊是新人就要開發新的產品線，一開始挫折感非常的重。&lt;/p&gt;
&lt;p&gt;這時候有趣的事發生，公司另外成立了網路行銷團隊，招募大概 6 個人，要與我們做業績競爭，每個月會招開會議，對我們數字做檢討。&lt;/p&gt;
&lt;h2&gt;兩團隊競爭&lt;/h2&gt;
&lt;p&gt;以往只會有副理每月參與開會，但往後會是兩個團隊一起開每月會議，參與會議的還有董事長、執行長、雙方部門主管。&lt;/p&gt;
&lt;p&gt;這時候，大家就開始戰戰兢兢的拼業績，因為業績只要不好、或比對方低，董事長就需要我們作出對應調整。&lt;/p&gt;
&lt;p&gt;每個月業績不足，大家報告中，各種方法解決問題，不乏是優化 SEO、網路廣告、提升文章曝光度、舉辦活動等等。&lt;/p&gt;
&lt;p&gt;一方面業績不夠，但董事長又希望雙方團隊能擴張人數，解決業績不足的問題。雖然人數提升，業績確實可能改善，但這是在新進人員能快速貢獻出產能前提下，公司在招募員工薪資預算較低，比較不容易找到有經驗的人才，人員進來還需要一段時間學習，需要時間才可能提升業績。&lt;/p&gt;
&lt;p&gt;這段時間新人還可能業績持續掛零，主管會持續關切，而讓新人備感壓力，轉而離職。這狀況輪迴大概看了好次。&lt;/p&gt;
&lt;p&gt;大概入職 7 個月後，也就是開始競爭幾個月，我們也補進 1 個行銷 Benny、2 個業務 Hu、惠仙。&lt;/p&gt;
&lt;p&gt;印象最深刻是，Benny 第一天上班，居然跟我 90 度鞠躬說: 請多多指教，我還真是第一次遇到同事跟我鞠躬，真特別。&lt;/p&gt;
&lt;h2&gt;公司文化&lt;/h2&gt;
&lt;p&gt;因為兩個團隊競爭，開始接觸到執行長、董事長，他們會不斷的鼓勵大家，要大家下班好好進修，然後要大家養成學習的習慣。副總也會如此，要大家多閱讀文章，增廣見聞。&lt;/p&gt;
&lt;p&gt;這是我覺得公司文化最棒的地方，會鼓勵員工進修學習，雖然沒有進修補助 XD。&lt;/p&gt;
&lt;p&gt;比較不好的地方在於全民皆兵，幾乎每個職務都要掛上業績，業績不夠就是檢討報告，非常業務導向的公司政策。&lt;/p&gt;
&lt;p&gt;還會有常態的教育訓練，會是專注在公司的產品介紹，沒有著墨在職能的教育，假設你是行銷相關，但是其他也很重要的網路廣告、經營社群、SEO 等等，在這邊的教育訓練是學習不到，這個點比較不太好。&lt;/p&gt;
&lt;p&gt;有點官僚的制度，常常會讓底下員工看不清公司政策方向。&lt;/p&gt;
&lt;h2&gt;下班時間增進專業&lt;/h2&gt;
&lt;p&gt;平時下班大概會花 3 小時研究與行銷相關的專業，有些是數據追蹤 google analytics，但主要是專注在 SEO 上，因為剛入職時，常常聽同事在講 SEO 的重要性，運氣很好的狀況下，我經營的部落格搜尋排名成長不少，開始想知道怎樣的文章會比較容易有好的排名。&lt;/p&gt;
&lt;p&gt;漸漸的在這時候養成下班學習的習慣。&lt;/p&gt;
&lt;p&gt;以前剛入職時，會在家裡自己加班處理公務，後面還接手經營某個外部社群，為了這件事情我花了不少時間，雖然是我自己選擇要去管理的，但過陣子發現，換來的只是主管單純的鼓勵，對我只是虛耗時間。&lt;/p&gt;
&lt;p&gt;如果你自主花費下班時間處理公務，但對你自己本身沒有幫助，就不要花時間了，轉去研究對你自己專業更有幫助的事情。&lt;/p&gt;
&lt;h2&gt;世界真大&lt;/h2&gt;
&lt;p&gt;入職後一年左右，某天剛好看到 awoo 宣傳講座，以前就有聽過這間專門做 SEO 的公司，講座又是免費參加的，我就跟 Austin、Benny 一起報名參加了。這是我第一次參加外部的講座，我才知道原來台灣也是滿多人在做 SEO，一直以為只有我們公司著重而已。&lt;/p&gt;
&lt;p&gt;大概是幾個團隊分享做 SEO 作法、感想，詳細內容不大記得了，只記得最後有去問阿吾問題，我問他 bing 要怎處理 SEO，沒記錯他當時是回答了處理上非常困難。他還順便歡迎大家去他們公司面試。&lt;/p&gt;
&lt;p&gt;那時候騎車回家路上，其實滿腔熱血，讓我知道，原來純粹 SEO 就會是個職務，想知道自己能力是多少，也覺得自己是井底之蛙，世界真大啊！&lt;/p&gt;
&lt;h2&gt;競爭部門重組解散&lt;/h2&gt;
&lt;p&gt;入職大概一年多，兩個團隊業績雖然有成長，但成長幅度與人數成長沒有成正比，公司不停的轉換經營網路的策略，曾經思考過是否要做個學生相關的平台，或是讓我們全部兼著業務做。&lt;/p&gt;
&lt;p&gt;跟我們競爭部門的同事整組換了一輪，後面甚至解散改組，現在回過頭來看，公司對兩個團隊的資源分配管理上，都有滿多問題，兩個團隊人數加起來大概是 18 人，因為公司產品就那些，雙方做的事情完完全全重疊，甚至還出現關鍵字廣告互相競爭的狀況，現在看起來滿荒謬的。但在那時光背景下，誰只要輸了就會被解散或被合併。&lt;/p&gt;
&lt;p&gt;還有人員的專業度問題，公司總認為每個新人都能快速吸收前輩的專業，但實際上不是這麼簡單的，新進員工常會呈現不知所措，然後業績持續掛零。&lt;/p&gt;
&lt;p&gt;或是前人離職，交接完作業流程後，忽略了最重要的轉移專業，導致員工一離職後，部門就直接損失這塊業績。應該要鼓勵員工舉辦類似 workshop，互相學習。&lt;/p&gt;
&lt;p&gt;也要分專業領域去組織團隊成員，假設這邊需要 SEO，那應該要找這塊專門的主管、或員工，如果需要關鍵字廣告，那也要找這塊專家，經營粉絲團同樣也是。但這前提條件是，因為要找專業度較高員工，所以要提高招募的預算，恩...，這問題幾乎無解。&lt;/p&gt;
&lt;h2&gt;同事一起學習&lt;/h2&gt;
&lt;p&gt;前面那位 Benny 是資工系的，他常常會問我 SEO 相關問題，不過我常常用很沒邏輯的答案回答他，因為 google 會這樣啊、因為我之前這樣寫排名就會好啊。這樣的回答常常被他質疑，我才漸漸覺得，其實 google 也只是程式，背後一定有它的邏輯，後面才開始用更邏輯的態度去面對 SEO。&lt;/p&gt;
&lt;p&gt;後面開始操作 google adword，我跟 Austin、Benny 還花了不少時間研究了 google adword 的機制，後面也有不錯的成效，記得那時候我邊在外面走路，還邊看 google 教學影片，只是希望能快速找出 google adword 操作訣竅。&lt;/p&gt;
&lt;p&gt;過了一年多，這時候剛好家裡招牌要架設網站，所以開始研究怎麼架網站、寫 CSS。我那時候是跟 Benny 一起學 CSS 的，各種研究怎排版、各種 style。還記得，Benny 第一天學了 CSS 後，就跑去 awoo 面試，雖然結果沒上，但這行動力著實讓我敬佩。&lt;/p&gt;
&lt;p&gt;話說很佩服小主管招募人員眼光，同事之間的相處、溝通都非常好，常會覺得這樣的同事是怎被騙進來的 XD。&lt;/p&gt;
&lt;h2&gt;Benny 大崩潰&lt;/h2&gt;
&lt;p&gt;因為太好笑了，我一定要提這件事情。部門內部開發行銷類進修課程，當天會先有個免費的講座，再引導購買課程，希望我們團隊負責推廣，負責的主要是 Austin、Benny，記得那時候每天看他們在開會，各種研究如何曝光、收名單，那時候與部門主管訂下了 KPI 門檻，大概是 70 筆名單。&lt;/p&gt;
&lt;p&gt;我也會參與他們討論，一起研究怎樣的課程會對網路行銷職務最有幫助，最後定案課程是 SEO、文案撰寫、社群經營。&lt;/p&gt;
&lt;p&gt;名單在講座舉辦前幾天達標了，大家都很期待當天講座會有多少人付費課程。我對這課程還滿有信心，連我都滿有興趣的。&lt;/p&gt;
&lt;p&gt;但講座當天結束後，才知道大概只有幾位報名...。&lt;/p&gt;
&lt;p&gt;聽 Benny 轉述，當天情況十分慘烈，講師是部門主管擔任，沒有特別去聘請外部講師。演講的內容不乏介紹電商營業額，網路趨勢或是大數據等等，甚至還講比爾蓋茲的女婿故事，演講內容幾乎沒有著墨網路行銷專業介紹。&lt;/p&gt;
&lt;p&gt;講座完，還有發回饋問卷，回饋內容幾乎都在評論講者的不專業，或是覺得浪費時間等等。當天，Benny 還跑去買啤酒喝，生氣到覺得自己太傻，居然忘記最重要環節是講座的講者。&lt;/p&gt;
&lt;p&gt;那次事件後，我們都對部門主管抱持一種失望、不信任態度。&lt;/p&gt;
&lt;h2&gt;轉職&lt;/h2&gt;
&lt;p&gt;入職一年半，我跟 Benny 花了 3、4 個月時間學了 javascript、HTML、CSS，我完成家裡招牌的網頁，他也離職去某公司擔任軟體工程師了，雖然他進去之後沒寫網頁，是寫 C#。&lt;/p&gt;
&lt;p&gt;他離職影響我滿大的，少了一起研究網頁技術的同事，後面滿多技術都只能自己摸索，後面幾個月確實進步幅度變小許多。我那時候對 javascript 還不是很熟悉，頂多做一些簡單的效果。&lt;/p&gt;
&lt;p&gt;那時候剛好遇到公司培訓主管計畫，但我並沒有參加，因為需要經過一段培訓，培訓需要大約半年到一年時間，還需要額外花時間參加教育訓練。前面有提到，我對公司教育訓練是比較不信任的。當下我也對我自己專業度抱持懷疑，我覺得在行銷上專業度還不夠擔任主管，我對主管看法就是，要能夠教學、帶領同仁成長。&lt;/p&gt;
&lt;p&gt;培訓幹部還有 Benny 離職，也讓我思考我人生下一步，要繼續行銷職，還是嘗試寫網頁轉換跑道。我那時候是覺得寫網頁很有趣、好玩，比起行銷來說，寫網頁更具創造力、成就感。&lt;/p&gt;
&lt;p&gt;寫的第一個程式: &lt;a href=&quot;https://work.ianccy.com/lunch.html&quot; title=&quot;午餐吃什麼&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;午餐吃什麼&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;過了幾個月，我剛好家裡親戚過世，讓我更覺得要把握時間，剛好翻到某個 ptt，後面有寫上，只要有前端求職上問題都可以找他。就打開 facebook messenger 敲他，原先只是想問問面試相關問題，沒想到他居然出功課要我完成，完成後再讓我拿作品去面試，大概就是網頁切版，還有串接 api 呈現畫面，是到後面才知道他是六角的創辦人。&lt;/p&gt;
&lt;p&gt;剛好入職兩年左右。&lt;/p&gt;
&lt;p&gt;我開始拿著這些作品面試，很幸運的，我就找到前端工程師的工作了。很感激六角的創辦人，他也是我入坑的貴人。&lt;/p&gt;
&lt;h2&gt;第一份工作重要性&lt;/h2&gt;
&lt;p&gt;雖然我第一份工作不是特別挑的，是只有這個有錄取，但很幸運，我的團隊主管是個好主管，善於傾聽，總是會鼓勵我嘗試新作法，也不太管我上班在做什麼，甚至後面還讓我寫了些網頁，這些面試都剛好當作作品集。&lt;/p&gt;
&lt;p&gt;團隊同事也非常好相處，雖然這裡的福利不太好，公司常常有很多怪異政策，或許是共患難精神，大家每天上班都很開心，幾乎都沒有鬥爭、隔閡。&lt;/p&gt;
&lt;p&gt;原本我對工作觀念就是，上班是同事，下班不認識，但後面被同事改變了我的看法，同事間不一定要特別疏遠，好相處的也可以當作朋友。&lt;/p&gt;
&lt;p&gt;沒有進這間公司，認識這些同事，或許我今天就不會轉換跑道了。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Hooks Performance 效能處理]]></title><description><![CDATA[React 發布了幾個月的 Hooks，最近也開始嘗試接觸，後面會稍微提一下 PureComponent，不會介紹 hooks 各種特殊用法，就只針對 hooks performance 優化做介紹，還有搭配 redux 的處理。 因為前陣子有處理過 React…]]></description><link>https://ianccy.com/2019-06-reacthooks/</link><guid isPermaLink="false">https://ianccy.com/2019-06-reacthooks/</guid><pubDate>Sat, 01 Jun 2019 13:46:57 GMT</pubDate><content:encoded>&lt;p&gt;React 發布了幾個月的 Hooks，最近也開始嘗試接觸，後面會稍微提一下 PureComponent，不會介紹 hooks 各種特殊用法，就只針對 hooks performance 優化做介紹，還有搭配 redux 的處理。&lt;/p&gt;
&lt;p&gt;因為前陣子有處理過 React 優化效能，對於這件事情也開始在意，讓人絕望的 google page speed...。&lt;/p&gt;
&lt;!--- ![react lifecycle](../images/reacthooks.png &quot;react lifecycle&quot;) ---&gt;
&lt;h2&gt;React PureComponent&lt;/h2&gt;
&lt;p&gt;如果有在注意效能的話，你應該會聽過 shouldComponentUpdate 或 PureComponent，這是較常見的處理方法，Purecomponent 只關注 state、props 並作 shallow equal 比較，當不同值才會觸發 rerender。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://reactjs.org/docs/shallow-compare.html&quot; title=&quot;shallow-compare&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React shallow-compare&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下是有無使用 Purecomponent 的比較，當我更新某個 state，而這個 state 沒有傳進作為 props，PureComponent 會過濾掉更新。&lt;/p&gt;
&lt;p&gt;使用教學: 你可以嘗試更新 input text，會發現 Purecomponent 數字不會增加，而一般 component 則是會增加。這數字增加代表著 react 嘗試 update Component 次數。&lt;/p&gt;
&lt;p&gt;這數字不代表是否真的更新 dom，因為 react 會比較 render 後 dom 結構的不同，再決定是否更新某節點 dom，但嚴格來說這也算是種浪費效能。&lt;/p&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/serene-murdock-t7ih2?fontsize=14,result&quot; width=&quot;100%&quot; height=&quot;400&quot;&gt;&lt;/iframe&gt;
&lt;ul&gt;
&lt;li&gt;PureComponent code&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React, { PureComponent } from &apos;react&apos;;

class CheckboxPure extends PureComponent {
    constructor(props) {
        super(props);
        this.state = {
            done: true
        };
        this.times = 0;
    }
    changeCheck = e =&gt; {
        this.setState({
            done: e.target.checked
        });
    };
    componentWillUpdate() {
        this.times = this.times + 1;
    }
    render() {
        const { done } = this.state;
        const { text } = this.props;
        return (
            &amp;#x3C;div&gt;
                &amp;#x3C;div&gt;PureComponent component Try Update time {this.times}&amp;#x3C;/div&gt;
                &amp;#x3C;div&gt;
                    &amp;#x3C;input onClick={this.changeCheck} type=&quot;checkbox&quot; checked={done} /&gt;
                    {text}
                &amp;#x3C;/div&gt;
            &amp;#x3C;/div&gt;
        );
    }
}

export default CheckboxPure;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ps. PureComponent 不是全部都用，需要注意 props 的更新關係。假設你上層的 update，一定會更動到 PureCompoent 的 props，那你應該避免使用 PureComponent，因為每次接受到 props 時，PureComponent 還會多做一次 shallow compare，那因為每次都一定更新 props，多做比較就等於浪費效能，比起用一般方法還不好。&lt;/p&gt;
&lt;h2&gt;React hooks functional&lt;/h2&gt;
&lt;p&gt;前面會提到 PureComponent，是因為 react hooks 是全面的使用 functional Component，這代表我們不會在使用 Class，以往 Class 使用是繼承 React 並讓我們建立 instance，有 instance 就代表有 memory 位置，可以讓我們處理資料比較。functional 代表我們只要調用一次更新，所有的 react hooks function 都會再被調用一次。&lt;/p&gt;
&lt;p&gt;舉例來說，將關注點變到更小，所以 useEffect 才能實現像是 componentDidUpdate 的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hooks like componentDidUpdate&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;useEffect(() =&gt; {
  document.title = `You clicked ${count} times`;
};
// it will setting title everytime when render function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;useEffect 就是一個例子，你看到 useEffect 的額外第二個參數，useEffect 會綁定 count 更新，才會調用 callback。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hooks useEffect bind count&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
}, [count]);
// Only setting title if count changes
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;React hooks 實現 todoList&lt;/h2&gt;
&lt;p&gt;嘗試建立一個 toDo List，方便我們來看怎樣讓 React hooks 實現 PureComponent 的特性。我們會需要建立三個檔案，分別是是 container/todoView、component/todoLis、hooks/useTodoList。&lt;/p&gt;
&lt;p&gt;假設你已經用過 react hooks，這部分可以直接略過。&lt;/p&gt;
&lt;p&gt;首先建立 container/TodoView，我們會需要建立 toDo 的 Array，這邊我們會用到 useState，還有 useRef，讓我們能夠取得 input value，剩下部份就是更新處理 todoList state。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React hooks function&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// toDo array
const [todoList, setTodoList] = useState([]);

// create inputRef
const inputEl = useRef(null);

// add Array
const addTodo = event =&gt; {
    event.preventDefault();
    if (!inputEl.current.value) {
        return;
    }
    const mergeArr = [...todoList, inputEl.current.value];
    inputEl.current.value = &apos;&apos;;
    return setTodoList(mergeArr);
};

// delete Array by index
const deleteToDo = index =&gt; {
    const newArr = [...todoList];
    newArr.splice(index, 1);
    return setTodoList(newArr);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立 hooks/useTodoList，並把上面這些 hooks function 移動過去。就完成了 todoList 的自製 hooks。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hooks/useTodoList.js&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { useState, useCallback } from &apos;react&apos;;

function useTodoList(value, inputEl) {
    const [todoList, setTodoList] = useState(value);
    const addTodo = event =&gt; {
        event.preventDefault();
        if (!inputEl.current.value) {
            return;
        }
        const mergeArr = [...todoList, inputEl.current.value];
        inputEl.current.value = &apos;&apos;;
        return setTodoList(mergeArr);
    };

    const deleteToDo = index =&gt; {
        const newArr = [...todoList];
        newArr.splice(index, 1);
        return setTodoList(newArr);
    };

    return [todoList, addTodo, deleteToDo];
}

export default useTodoList;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;會多建立一個 &lt;code&gt;const [count, setCount] = useState(0);&lt;/code&gt;，讓我們在這層 setState，並觀察 TodoList 更新狀況。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;container/TodoView.js&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React, { useState, useRef } from &apos;react&apos;;
import TodoList from &apos;../component/TodoList&apos;;
import useTodoList from &apos;../hooks/useTodoList&apos;;

function TodoView() {
    const inputEl = useRef(null);
    const [todoList, addTodo, deleteToDo] = useTodoList([], inputEl);

    // use to update TodoView
    // let us check TodoList update situation
    const [count, setCount] = useState(0);

    return (
        &amp;#x3C;&gt;
            &amp;#x3C;span&gt;Counter : {count}&amp;#x3C;/span&gt;
            &amp;#x3C;button onClick={() =&gt; setCount(count + 1)}&gt;Add Counter&amp;#x3C;/button&gt;
            &amp;#x3C;form className=&quot;input-container&quot; onSubmit={addTodo}&gt;
                &amp;#x3C;input ref={inputEl} placeholder=&quot;Type your to Do&quot; /&gt;
                &amp;#x3C;button className=&quot;add-button&quot;&gt;Create&amp;#x3C;/button&gt;
            &amp;#x3C;/form&gt;
            &amp;#x3C;TodoList todoList={todoList} deleteToDo={deleteToDo} /&gt;
        &amp;#x3C;/&gt;
    );
}

export default TodoView;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;額外再加上 toDoList.js 加上計算器，每次的 render function 都會加上 1，方便我們看 toDoList 重新 render 的次數。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;component/TodoList.js&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React from &apos;react&apos;;
let count = 0;

function TodoList(props) {
    const { todoList, deleteToDo } = props;
    count = count + 1;
    return (
        &amp;#x3C;div className=&quot;list&quot;&gt;
            TodoList render Times {count}
            {todoList.map((value, index) =&gt; (
                &amp;#x3C;li className=&quot;list-item&quot; key={`to_${index}`}&gt;
                    &amp;#x3C;div&gt;
                        {index + 1}. {value}
                    &amp;#x3C;/div&gt;
                    &amp;#x3C;span onClick={() =&gt; deleteToDo(index)}&gt;-&amp;#x3C;/span&gt;
                &amp;#x3C;/li&gt;
            ))}
        &amp;#x3C;/div&gt;
    );
}

export default TodoList;
&lt;/code&gt;&lt;/pre&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/fervent-gould-qyekg?fontsize=14,result&quot; width=&quot;100%&quot; height=&quot;400&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;React hooks 效能處理&lt;/h2&gt;
&lt;p&gt;我們已經完成了簡易版的 todoList，當你輸入 input 建立後，會發現 TodoList 會更新一次，但是你點擊 count 後，會發現 TodoList 居然也會更新，這是因為所有的 component 已經都是純 functional component，當我們最上層更新 state，都會一路往下更新到底層。&lt;/p&gt;
&lt;p&gt;這時候我們就必須依賴 React.memo，React.memo 是一個 high Order Component，功能就像是 PureComponent，讓我們擋住調用更新 function，但差異在於 memo 是用在於 function components，並會幫我們 memory 住 props，只在 props 更新才會往下更新。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://reactjs.org/docs/react-api.html#reactmemo&quot; title=&quot;React memo&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React memo&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;component/TodoList&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// use React memo for TodoList;
export default React.memo(TodoList);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新上去後，讓我們在嘗試點擊 count，觀察 TodoList 是否就卡住更新了。&lt;/p&gt;
&lt;p&gt;你會發現數字還是增加。&lt;/p&gt;
&lt;p&gt;查看上層傳進的 props 後，發現還有一個問題，就是傳進去的 function，每次都會是一個新的 function。因為沒有 function 沒有 memory 住，導致每次都會 render 後都會重新建立 addTodo、deleteToDo，所以對 toDoList 的 memo 來說，你每次都給我新的 props function，當然會每次都更新 component。&lt;/p&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/adoring-dream-j01do?fontsize=14,result&quot; width=&quot;100%&quot; height=&quot;400&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;幸好 react hooks 有提供 useCallback，讓我們可以把 function memory 起來，useCallback 會需要依賴第二個參數，讓他比較判斷是否要更新 function。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React hooks useCallback&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const memoizedCallback = useCallback(() =&gt; {
    doSomething(a, b);
}, [a, b]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://reactjs.org/docs/hooks-reference.html#usecallback&quot; title=&quot;React usecallback&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React hooks usecallback&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const addTodo = useCallback(
    event =&gt; {
        event.preventDefault();
        if (!inputEl.current.value) {
            return;
        }
        const mergeArr = [...todoList, inputEl.current.value];
        inputEl.current.value = &apos;&apos;;
        return setTodoList(mergeArr);
    },
    [todoList, inputEl]
);

const deleteToDo = useCallback(
    index =&gt; {
        const newArr = [...todoList];
        newArr.splice(index, 1);
        return setTodoList(newArr);
    },
    [todoList]
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新上去後，再嘗試點擊 count 看看，會發現 toDoList 終於沒有更新數字了。這樣就完成了 hooks 的 render 效能處理。使用 React.memo 實現了類似 PureComponent 的功能，再解決掉 function components 沒有 memory 的問題，讓我們 todo、delete function，都不會因為 function component 被更新而重新被建立。&lt;/p&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/floral-bash-dv708?fontsize=14,result&quot; width=&quot;100%&quot; height=&quot;400&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;增加 Redux&lt;/h2&gt;
&lt;p&gt;另外改用 redux 管理 todo 資料，沒有特別用最新 react-redux 的 hooks 版本，因為還在 alpha 階段。基本上就移除掉 useState，建立 store、reducer，再建立 Provider，還有 state、dispatch 傳遞到需要使用的元件上。&lt;/p&gt;
&lt;p&gt;不想偏離主題就直接貼上作法了。&lt;/p&gt;
&lt;p&gt;Source code: &lt;a href=&quot;https://github.com/Ianpig/hooks-try&quot; title=&quot;React hooks with redux&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React hooks with redux&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;因為準備要開始運用 hooks 在專案上，才發現 function components 要注意的問題，遠比我想像的還多。以往 react class 的寫法，react 處理了 component 的 rerender 問題，但改為 function components 後，多了處理 rerender 的問題。&lt;/p&gt;
&lt;p&gt;個人覺得用過 class 在轉用 hooks 後，lifeCycle 的部分最不習慣，感覺拉高了點 React 的學習門檻。hooks 讓 react 的複用單位拉到在更小，用得好確實能夠加速開發，期待日後實際運用 hooks 在專案上後能有更多心得分享。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Google Sheet RESTful API 試算表表單]]></title><description><![CDATA[嗨，接下來要來分享 google excel api 之前未完成的部分，前面介紹了建立 api，讓我們能在 google excel 新資料，但是透過 api 管理資料還差讀取、更新表單資料，簡單講就是 API 的 CRUD。 後面會完成 API…]]></description><link>https://ianccy.com/2019-05-googleformadv/</link><guid isPermaLink="false">https://ianccy.com/2019-05-googleformadv/</guid><pubDate>Sat, 11 May 2019 12:51:14 GMT</pubDate><content:encoded>&lt;p&gt;嗨，接下來要來分享 google excel api 之前未完成的部分，前面介紹了建立 api，讓我們能在 google excel 新資料，但是透過 api 管理資料還差讀取、更新表單資料，簡單講就是 API 的 CRUD。&lt;/p&gt;
&lt;p&gt;後面會完成 API 串接做查詢、更新資料，還有簡單的前端操作畫面。&lt;/p&gt;
&lt;p&gt;完成畫面: &lt;a href=&quot;https://work.ianccy.com/friedQuery.html&quot; title=&quot;鹹酥雞查詢訂單&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;鹹酥雞查詢訂單&lt;/a&gt;&lt;/p&gt;
&lt;!--- ![google sheetapiquery](../images/sheetapiquery.png &quot;google sheetapiquery&quot;) ---&gt;
&lt;ul&gt;
&lt;li&gt;前文章連結 : &lt;a href=&quot;https://ianccy.com/googleformapi/&quot; title=&quot;Google sheet 試算表表單串接api&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Google sheet 試算表表單串接 api &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Google 官方文件 &lt;a href=&quot;https://developers.google.com/apps-script/reference/spreadsheet/sheet&quot; title=&quot;google sheet api&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;spreadsheet method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://work.ianccy.com/%E7%82%B8%E9%9B%9E%E8%A8%82%E8%B3%BC&quot; title=&quot;鹹酥雞訂購 範例網頁&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;鹹酥雞訂購 範例網頁&lt;/a&gt;、&lt;a href=&quot;https://docs.google.com/spreadsheets/d/1JbXssixJaqTL_BMgnmOiMxLyAZm0jOkw173VdewqO9c/edit#gid=0&quot; title=&quot;鹹酥雞訂購 Excel&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;鹹酥雞訂購 Excel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;查詢訂單 api&lt;/h2&gt;
&lt;p&gt;鹹酥雞訂購的填表，還需要增加一個功能，就是客人需要查詢訂單的狀態，有沒有成功送出訂單，還有老闆有沒有幫我確認製作，不然跑去現場然後老闆忘記做餐...。&lt;/p&gt;
&lt;p&gt;會是用填表姓名還有電話查詢。這邊用比較特別的處理方法，我們直接拉出電話陣列，直接比對電話號碼是否存在，有存在號碼會再比對姓名是否相符。才會回拋出資料。我沒特別研究 BigQueryDataSourceSpecBuilder，貌似可以直接下 query 語法。&lt;/p&gt;
&lt;p&gt;這邊改用 doPost，首先起手一樣用 getSheets 先取得我們的 tab，使用 getSheetValues 來拿到整包資料。拿到的資料會是陣列，我們可以跑迴圈來找出每一筆的 name、phone，有沒有在陣列內，有的話才要增加到回傳的陣列。最後回傳資料會是一包陣列裡面會是{data: [ ], index: x}，index 方便我們後續做更新的操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getSheetValues(startRow, startColumn, numRows, numColumns)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ps.儲存發布記得要再新增版本，這邊我卡了 1 小時...。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function doPost(e) {
    var params = e.parameter;
    var name = params.name;
    var phone = params.phone;

    var SpreadSheet = SpreadsheetApp.openById(&apos;1JbXssixJaqTL_BMgnmOiMxLyAZm0jOkw173VdewqO9c&apos;);
    var Sheet = SpreadSheet.getSheets()[0];

    var LastRow = Sheet.getLastRow();
    var data = [];

    // get All data as Array
    // first row, first column, last row, seven columns
    var listAll = Sheet.getSheetValues(1, 1, LastRow, 7);

    // find phone and name mapping data and Push Array
    for (var i = 0; i &amp;#x3C; list.length; i++) {
        if (listAll[i].indexOf(phone) === 1 &amp;#x26;&amp;#x26; listAll[i].indexOf(name) === 0) {
            data.push({ data: listAll[i], index: i + 1 });
        }
    }
    // return data as JSON
    return ContentService.createTextOutput(JSON.stringify(data)).setMimeType(
        ContentService.MimeType.JSON
    );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.com/apps-script/reference/spreadsheet/sheet#getSheetValues(Integer,Integer,Integer,Integer)&quot; title=&quot;google sheet getSheetValues&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google sheet getSheetValues&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這樣就完成了查詢訂單的 api，當我們用 post 請求 api，並且帶上 name、phone 的參數，就會幫我們查詢並回傳符合比對的資料。&lt;/p&gt;
&lt;p&gt;建議安裝 postman，方便直接測試 api。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/postmanapipost.png&quot; alt=&quot;postmanapi post&quot; title=&quot;postmanapi post&quot;&gt;&lt;/p&gt;
&lt;h2&gt;更新訂單 api&lt;/h2&gt;
&lt;p&gt;客人送出訂單後，可能需要取消訂單，這時候就需要對資料更新了。我們可以搭配查詢 api，讓客人看到自己的訂單，再對訂單更新狀態。我們用前面做好的 doPost function，直接擴展增加更新的功能。&lt;/p&gt;
&lt;p&gt;增加 action，作為查詢、刪除的判斷，再稍微整理一下拆分共用的邏輯，把執行部分打包成 function。建立 updateData，專門更新訂單的狀態，我們取得 index，直接查詢這個 row 的資料，拿請求的 name、phone 直接比對是否符合，符合的話才讓使用者可以更新訂單狀態。&lt;/p&gt;
&lt;p&gt;另外我們定義處理狀態 0 代表訂單取消，1 代表完成訂單。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function doPost(e) {
    var params = e.parameter;
    var name = params.name;
    var phone = params.phone;
    var status = params.status;

    // add action filter post function
    var action = params.action;

    var SpreadSheet = SpreadsheetApp.openById(&apos;1JbXssixJaqTL_BMgnmOiMxLyAZm0jOkw173VdewqO9c&apos;);
    var Sheet = SpreadSheet.getSheets()[0];
    var data = &apos;&apos;;
    if (action === &apos;query&apos;) {
        data = queryData(Sheet, name, phone);
    } else if (action === &apos;delete&apos;) {
        data = updateData(Sheet, name, phone, status, index);
    }
    return ContentService.createTextOutput(JSON.stringify(data)).setMimeType(
        ContentService.MimeType.JSON
    );
}

function queryData(Sheet, name, phone) {
    var LastRow = Sheet.getLastRow();
    var data = [];
    var listAll = Sheet.getSheetValues(1, 1, LastRow, 7);
    for (var i = 0; i &amp;#x3C; listAll.length; i++) {
        if (listAll[i].indexOf(phone) === 1 &amp;#x26;&amp;#x26; listAll[i].indexOf(name) === 0) {
            data.push({ data: listAll[i], index: i });
        }
    }
    return data;
}
// update use function
function updateData(Sheet, name, phone, status, index) {
    var checkName = Sheet.getSheetValues(index, 1, 1, 1) == name;
    var checkPhone = Sheet.getSheetValues(index, 2, 1, 1) == phone;
    if (checkName &amp;#x26;&amp;#x26; checkPhone) {
        Sheet.getRange(index, 7).setValue(status);
        return &apos;success&apos;;
    }
    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;前端畫面&lt;/h2&gt;
&lt;p&gt;這樣就完成了查詢、更新訂單的 api 了，剩下就是網頁前端部分，網頁需求是讓使用者輸入姓名、電話查詢訂單，或是查詢後可以取消訂單。&lt;/p&gt;
&lt;p&gt;前端主要的 function 就這些，主要就是查詢拉資料，更新 List 清單，點擊取消訂單的按鈕，請求 API 更新狀態等等。&lt;/p&gt;
&lt;p&gt;前端畫面比起 API 來說，就比較單純這邊不多贅述了。要用 vanilla javascript、jquey、或 react、vue，看你喜歡都可以做到一樣功能。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;      &amp;#x3C;div class=&quot;col-lg-12 text-center&quot;&gt;
        &amp;#x3C;h1 class=&quot;mt-5&quot;&gt;查詢訂單&amp;#x3C;/h1&gt;
        &amp;#x3C;div class=&quot;form-group col-xs-12&quot;&gt;
          &amp;#x3C;label for=&quot;pwd&quot;&gt;姓名:&amp;#x3C;/label&gt;
          &amp;#x3C;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot;&gt;
        &amp;#x3C;/div&gt;
        &amp;#x3C;div class=&quot;form-group col-xs-12&quot;&gt;
          &amp;#x3C;label for=&quot;pwd&quot;&gt;電話:&amp;#x3C;/label&gt;
          &amp;#x3C;input type=&quot;number&quot; class=&quot;form-control&quot; id=&quot;phone&quot;&gt;
        &amp;#x3C;/div&gt;
        &amp;#x3C;div class=&quot;form-group col-xs-12&quot;&gt;
          &amp;#x3C;button type=&quot;button&quot; id=&quot;send&quot; class=&quot;btn btn-primary col-xs-12&quot;&gt;送出查詢&amp;#x3C;/button&gt;
        &amp;#x3C;/div&gt;
        &amp;#x3C;div class=&quot;form-group col-xs-12&quot;&gt;
          &amp;#x3C;table class=&quot;table table-striped&quot; style=&quot;display: none;&quot;&gt;
            &amp;#x3C;thead&gt;
              &amp;#x3C;tr&gt;
                &amp;#x3C;th&gt;Name&amp;#x3C;/th&gt;
                &amp;#x3C;th&gt;Phone&amp;#x3C;/th&gt;
                &amp;#x3C;th&gt;Time&amp;#x3C;/th&gt;
                &amp;#x3C;th&gt;Item&amp;#x3C;/th&gt;
                &amp;#x3C;th&gt;Price&amp;#x3C;/th&gt;
                &amp;#x3C;th&gt;Status&amp;#x3C;/th&gt;
                &amp;#x3C;th&gt;Update&amp;#x3C;/th&gt;
              &amp;#x3C;/tr&gt;
            &amp;#x3C;/thead&gt;
            &amp;#x3C;tbody id=&quot;dataView&quot;&gt;
            &amp;#x3C;/tbody&gt;
          &amp;#x3C;/table&gt;
        &amp;#x3C;/div&gt;
        &amp;#x3C;div class=&quot;col-xs-12 text-center&quot;&gt;純屬線上訂購 demo&amp;#x3C;/div&gt;
      &amp;#x3C;/div&gt;
...
  &amp;#x3C;script&gt;
    $(function(){
        $(&apos;#send&apos;).click(function(e){
            var status = true;
            var name = $(&apos;#name&apos;).val();
            var phone = $(&apos;#phone&apos;).val();
            $(&apos;input&apos;).focus(function(){
              $(this).css(&apos;border&apos;,&apos;&apos;);
            });
            if(name == &apos;&apos;){
              $(&apos;#name&apos;).css(&apos;border&apos;,&apos;1px solid #ff0000&apos;);
              status = false;
            }
            if(phone == &apos;&apos;){
              $(&apos;#phone&apos;).css(&apos;border&apos;,&apos;1px solid #ff0000&apos;);
              status = false;
            }

            if(status){
              var data = {
                &apos;name&apos; : name,
                &apos;phone&apos;:phone,
                &apos;action&apos;: &apos;query&apos;
              }
              sendQuery(data);
            }
      });
    });
    function handleData(response){
        var content = &apos;&apos;;
        response.forEach(element =&gt; {
          var [name, phone, time, item, price,, status] = element.data;
          var index = element.index;
          var statusWording = convertStatus(status);
          content +=
              `&amp;#x3C;tr&gt;
                &amp;#x3C;td&gt;${name}&amp;#x3C;/td&gt;
                &amp;#x3C;td&gt;${phone}&amp;#x3C;/td&gt;
                &amp;#x3C;td&gt;${new Date(time)}&amp;#x3C;/td&gt;
                &amp;#x3C;td&gt;${item}&amp;#x3C;/td&gt;
                &amp;#x3C;td&gt;${price}&amp;#x3C;/td&gt;
                &amp;#x3C;td class=&quot;status&quot;&gt;${statusWording}&amp;#x3C;/td&gt;
                &amp;#x3C;td&gt;
                  ${status !== &apos;&apos; ? &apos;-&apos; :
                    `&amp;#x3C;button type=&quot;button&quot; onclick=&quot;updateStatus(&apos;${name}&apos;, &apos;${phone}&apos;, ${index}, this)&quot; class=&quot;btn btn-primary&quot;&gt;取消訂單&amp;#x3C;/button&gt;`
                  }
                &amp;#x3C;/td&gt;
              &amp;#x3C;/tr&gt;`
        });
        if (content) {
          document.getElementsByClassName(&apos;table-striped&apos;)[0].style.display = &apos;table&apos;;
        } else {
          alert(&apos;查無資料&apos;);
        }
        var dataView = document.getElementById(&apos;dataView&apos;);
        dataView.innerHTML = content;
    }
    function convertStatus(status){
        var text = &apos;&apos;;
        switch (status) {
          case &apos;&apos;:
            text = &apos;尚未處理&apos;;
            break;
          case 0:
            text = &apos;訂單已取消&apos;;
            break;
          case 1:
            text = &apos;訂單處理中&apos;;
            break;
          case 2:
            text = &apos;完成製作&apos;;
            break;
          case 3:
            text = &apos;完成交易&apos;;
            break;
          default:
            break;
        }
        return text;
    }
    function sendQuery(data){
      $.ajax({
        type: &quot;post&quot;,
        url: &quot;https://script.google.com/macros/s/AKfycbz3fU3FVDmIQehtWX6ecKuV_A67lE64FEQ-ekmOZ_jZDyY96z0/exec&quot;,
        data: data,
        dataType: &quot;JSON&quot;,
        success: function (response) {
          handleData(response);
          $(&apos;#name&apos;).val(&apos;&apos;);
          $(&apos;#phone&apos;).val(&apos;&apos;);
        }
      });
    }
    function updateStatus(name, phone, index, that){
      var data = {
        name: name,
        phone: phone,
        action: &apos;delete&apos;,
        index: index,
        status: 0
      };
      $.ajax({
        type: &quot;post&quot;,
        url: &quot;https://script.google.com/macros/s/AKfycbz3fU3FVDmIQehtWX6ecKuV_A67lE64FEQ-ekmOZ_jZDyY96z0/exec&quot;,
        data: data,
        dataType: &quot;JSON&quot;,
        success: function (response) {
          if(response === &apos;success&apos;){
            $(that).parent().siblings(&apos;.status&apos;).text(convertStatus(0));
            $(that).remove();
          } else {
            alert(&apos;更新失敗！&apos;);
          }
        }
      });
    }
  &amp;#x3C;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://work.ianccy.com/friedQuery.html&quot; title=&quot;鹹酥雞查詢訂單 範例&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;鹹酥雞查詢訂單 範例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以直接右鍵，查看原始碼，直接看我怎麼寫前端畫面的。&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;會寫進階查詢的 API 是因為平常滿多網友有問我，所以乾脆直接寫一篇文章分享。現在工作就沒繼續接觸 sheet script API，所以前置花了點時間研究語法，我查詢資料的做法偏向暴力解，拉整包跑迴圈比對，如果有人研究出 select query 的作法，再麻煩跟我分享一下，感激不盡。&lt;/p&gt;
&lt;p&gt;對了，其實還缺老闆查詢全部資料、更新訂單狀態，這要再加上會員登入權限的 api，要擋有權限的帳號才可以查詢全部的資料，這個就讓我富奸一下下次再做吧 XD。&lt;/p&gt;
&lt;p&gt;api 那段寫得比較快，有問題再麻煩留言，感謝。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[lazy loading image 延後載入畫面外圖片]]></title><description><![CDATA[最近身邊朋友問到 google speedtest 分數優化處理，剛好處理完網頁優化專案，雖然分數尚有進步空間...，lazyload 幾乎是網站必備的優化處理，分享一點處理 lazyload 心得。 首先拿出一個網站，然後在google speedtest…]]></description><link>https://ianccy.com/2019-04-reactlazyload/</link><guid isPermaLink="false">https://ianccy.com/2019-04-reactlazyload/</guid><pubDate>Thu, 25 Apr 2019 23:06:08 GMT</pubDate><content:encoded>&lt;p&gt;最近身邊朋友問到 google speedtest 分數優化處理，剛好處理完網頁優化專案，雖然分數尚有進步空間...，lazyload 幾乎是網站必備的優化處理，分享一點處理 lazyload 心得。&lt;/p&gt;
&lt;!--- ![lazyloading](../images/lazyloading.png &quot;lazyloading&quot;) ---&gt;
&lt;p&gt;首先拿出一個網站，然後在&lt;a href=&quot;https://developers.google.com/speed/pagespeed/insights/&quot; title=&quot;google speedtest&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google speedtest&lt;/a&gt;輸入送出跑分，如果沒特別處理圖片的話，就會看到精美的項目出現 &lt;code&gt;延後載入畫面外圖片&lt;/code&gt;。這代表網站沒有處理延後載入圖片。假設網站有多圖片、或高畫質圖片，那 lazyload image 是不錯的優化處理。&lt;/p&gt;
&lt;p&gt;lazyload 範例 : &lt;a href=&quot;https://unsplash.com/&quot; title=&quot;unsplash&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;unsplash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面的 unsplash 是知名的免費圖庫網站，它就有做了 lazyload 的處理，你再網頁往下滾過程，會發現區塊先有各種顏色的背景，再開始慢慢載入圖片。&lt;/p&gt;
&lt;h2&gt;Google Guide Lazyload&lt;/h2&gt;
&lt;p&gt;google 這篇文章，有非常詳盡的教學，告訴你每種處理方法之間的差異。(推薦看完)&lt;/p&gt;
&lt;p&gt;Google website Guide: &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/&quot; title=&quot;Lazy Loading Images&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Lazy Loading Images&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;實作方法 inline images&lt;/h2&gt;
&lt;p&gt;這是最常見的處理方法，直接利用 javascript 搭配 viewport 判斷，把圖片網址由 data-src 轉為加入 src 載入圖片 ，實際作法分為三種。Intersection observer、event handler、原生 chrome 支援。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;before
&lt;code&gt;&amp;#x3C;img data-src=&quot;https://fakeimg.pl/250x100/&quot; class=&quot;lazyload&quot;&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;after
&lt;code&gt;&amp;#x3C;img src=&quot;https://fakeimg.pl/250x100/&quot;&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Intersection observer&lt;/h3&gt;
&lt;p&gt;IntersectionObserver 是新的瀏覽器 api，主要處理 element 與 viewport 之間處理，當目標與 element 交會則會處理互動，效能相對於傳統做法相對好。&lt;/p&gt;
&lt;p&gt;Google article: &lt;a href=&quot;https://developers.google.com/web/updates/2019/02/intersectionobserver-v2&quot; title=&quot;Trust is Good, Observation is Better—Intersection Observer v2&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Trust is Good, Observation is Better—Intersection Observer v2&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var observer = new IntersectionObserver(callback[, options]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的參數 callback 是當 viewport 與 element 交會時會觸發，options 則是可以使用 &lt;code&gt;root&lt;/code&gt;、&lt;code&gt;rootMargin&lt;/code&gt;、&lt;code&gt;threshold&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;root 可以定義我們判斷這整個 viewport 的大外層，rootMargin 則是可以給予 root 大外層假想的 margin，讓我們可以讓外層 viewport 提早被觸發，進一步提早 callback，threshold 則是可以定義出 viewport 與 element 之間觸發的比例 0~1.0，預設為 0，當我設定 [0, 0.5, 1]，代表他會在三個 viewport 比例 callback。&lt;/p&gt;
&lt;p&gt;IntersectionObserver DOC:&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/IntersectionObserver&quot; title=&quot;Intersection_Observer_API&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;MDN Intersection&lt;em&gt;Observer&lt;/em&gt;API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這方法有非常大的問題，就是不支援全部瀏覽器，ie 全部不支援，需要引入 IntersectionObserver polyfill 處理，或是判斷 window API 有沒有 IntersectionObserver，沒有就走 event handler 方法，&lt;/p&gt;
&lt;p&gt;第一個方法缺點就是要載資源，背後實作也是用 scroll listener，沒有說你用了 polyfill 就享有效能好的福利，第二種方法缺點就是要維運兩套 lazyload trigger function，對開發來說成本頗高。&lt;/p&gt;
&lt;p&gt;caniuse intersectionObserver : &lt;a href=&quot;https://caniuse.com/#feat=intersectionobserver&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;悲劇的 IE&lt;/a&gt; &quot;悲劇的 IE&quot;)&lt;/p&gt;
&lt;p&gt;頁面範例: &lt;a href=&quot;https://codepen.io/chu1228/pen/QPXLBv?editors=0110&quot; title=&quot;codepen&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;codepen demo&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Event handler&lt;/h3&gt;
&lt;p&gt;這是最常見的做法，監聽瀏覽器滾動事件，利用 getBoundingClientRect().top，來判斷這個 element 是不是在使用者的視點內，如果在視點內的話，我們就將 img src 轉變成真正的 url，達到延後載入的效果。&lt;/p&gt;
&lt;p&gt;下面的範例是 google guide 的示範，基本上實作邏輯都差不多，會用到 scroll listener，搭配 throttle 避免 scroll 過度觸發判斷 function，當所有 element 完成 lazyload 移除 Listener，還有監聽 resize 畫面拉伸、orientationchange 倒換畫面。&lt;/p&gt;
&lt;p&gt;頁面範例: &lt;a href=&quot;https://codepen.io/chu1228/pen/VNqaNQ&quot; title=&quot;codepen&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;codepen demo&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Chrome 原生支援&lt;/h3&gt;
&lt;p&gt;chrome version 75 才會 release 的功能，現在可以先手動開啟設定，chrome 網址列輸入&lt;code&gt;chrome://flags/#enable-lazy-image-loading&lt;/code&gt;，右邊選項改為 enabled。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;img loading=&apos;lazy&apos; src=&apos;https://placekitten.com/400/400&apos; width=&apos;400&apos; height=&apos;400&apos; alt=&apos;&apos;&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;頁面範例: &lt;a href=&quot;https://mathiasbynens.be/demo/img-loading-lazy&quot; title=&quot;chrome lazyload demo&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;chrome lazyload demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;chromestatus: &lt;a href=&quot;https://chromestatus.com/feature/5645767347798016&quot; title=&quot;chrome lazyload feature&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;chrome lazyload feature&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;lazyload 套件&lt;/h3&gt;
&lt;p&gt;隨便搜尋 lazyload plugin，就會出現各種 lazyload 的套件，這邊就不贅述了。如果還是沒方向的話，我目前專案上有用到 lazySize，config 很多也是不錯用。&lt;/p&gt;
&lt;h2&gt;修飾畫面抖動問題&lt;/h2&gt;
&lt;p&gt;但你滾動會發現右邊的 scroll bar 會慢慢長出來，要解決的辦法就是必須模擬圖片高度，撐出 lazyload 的區塊。保持高度一致不抖動畫面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示範圖片
&lt;img src=&quot;../images/rabbit.png&quot; alt=&quot;rabbit&quot; title=&quot;rabbit&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面這張圖片的寬度是 2955、高度 1516，比例約是 29: 15，我們可以利用圖片比例來產生接近圖片實際大小的灰階區塊。&lt;/p&gt;
&lt;p&gt;接下來使用 padding-top 來撐出高度，因為我們用的是比例，所以畫面寬度變化，區塊的高度也會隨之變化。直接用上面的 IntersectionObserver 修改，多做的動作就是 img 要先填上各自的比例，當載入畫面時填上 padding-top，產生區塊的灰色高度。&lt;/p&gt;
&lt;p&gt;ps.codepen 的範例有加上 setTimeout 500ms，特意讓大家看到 lazyload 灰階區塊。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Source code&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;document.addEventListener(&apos;DOMContentLoaded&apos;, function() {
    var lazyImages = [].slice.call(document.querySelectorAll(&apos;img.lazyload&apos;));

    if (&apos;IntersectionObserver&apos; in window) {
        let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
            entries.forEach(function(entry) {
                if (entry.isIntersecting) {
                    let lazyImage = entry.target;
                    lazyImage.src = lazyImage.dataset.src;
                    lazyImage.classList.remove(&apos;lazyload&apos;);

                    //clear padding-top
                    lazyImage.style.paddingTop = &apos;&apos;;
                    lazyImageObserver.unobserve(lazyImage);
                }
            });
        });

        lazyImages.forEach(function(lazyImage) {
            // get image ratio
            var ratio = lazyImage.dataset.ratio;
            // create padding-top
            lazyImage.style.paddingTop = ratio + &apos;%&apos;;
            lazyImageObserver.observe(lazyImage);
        });
    } else {
        // Possibly fall back to a more compatible method here
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;頁面範例: &lt;a href=&quot;https://codepen.io/chu1228/pen/BEgaKZ?editors=1010&quot; title=&quot;codepen&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;codepen demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外還可以加上 onload listener 讓載入圖片過程，保持 lazyload 灰色區塊。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;lazyImage.src = lazyImage.dataset.src;
lazyImage.onload = function() {
    lazyImage.classList.remove(&apos;lazyload&apos;);

    //clear padding-top
    lazyImage.style.paddingTop = &apos;&apos;;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;w3c ration 教學:&lt;a href=&quot;https://www.w3schools.com/howto/howto_css_aspect_ratio.asp&quot; title=&quot;Aspect Ratio / Height Equal to Width - W3Schools&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Aspect Ratio / Height Equal to Width - W3Schools&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;產生圖片比例 Ratio&lt;/h2&gt;
&lt;p&gt;這在實作上必須倚賴 javascript，或後端用其他工具產生，例如說圖片上傳過程後端會另外 call api，取得圖片的比例。&lt;/p&gt;
&lt;p&gt;這邊先只討論 javascript，利用 Image API 也可以輕鬆做到，下面的方法就可以拿到圖片的 ratio，setRatio 則是可以當作儲存圖片的方法，當使用者上傳圖片，會再經過 getImageRatio，再帶入 save data function 利用 callback，當取得圖片比例再提供 ratio 給後端儲存。&lt;/p&gt;
&lt;p&gt;這方法需要一個前提條件，一種是圖片寬度再 container 下需要寬滿版，因為 padding-top 推出來的高度，是相對於 container 寬度乘出來的。有些人會利用 div container img 概念處理，只要變化 container 寬度，一樣可以兼容 lazyload，medium 就是這樣處理的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function getImageRatio(url, callback) {
    var img = new Image();
    img.onload = function() {
        callback((this.height / this.width) * 100);
    };
    img.src = url;
}
function setRatio(ratio) {
    console.log(ratio);
}
getImageRatio(&apos;https://ianccy.com/images/rabbit.png&apos;, setRatio);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;seo 額外處理&lt;/h2&gt;
&lt;p&gt;雖然 googlebot 可以執行 javascript，但是其他爬蟲不一定可以，所以要特別標明出 noscript 的 img html。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascripts&quot;&gt;&amp;#x3C;img class=&quot;lazyload&quot; data-ratio=&quot;51.24481327800829&quot; data-src=&quot;https://ianccy.com/images/rabbit.png&quot; alt=&quot;rabbit&quot;&gt;
&amp;#x3C;noscript&gt;&amp;#x3C;img src=&quot;https://ianccy.com/images/rabbit.png&quot; alt=&quot;rabbit&quot; /&gt;&amp;#x3C;/noscript&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;實際上處理 lazyload 是比較麻煩，要做出 lazyload 區塊灰階，就需要知道圖片比例。至於如何產生灰階，又分為存資料前預先做好 style，或載入頁面再依賴 javascript 產生。個人較偏向預先做好 style，減少使用使用者資源。&lt;/p&gt;
&lt;p&gt;為了優化效能，目前專案部分有使用 IntersectionObserver，但要支援萬惡的 IE，要再額外載入 polyfill，這點目前還在思考最佳解，目前是判斷 window 不含 IntersectionObserver 才會執行 polyfill。&lt;/p&gt;
&lt;p&gt;結論: lazy loading image 對網站是很合理的處理優化，使用者沒看到的區塊本來就不需要浪費網路載入。&lt;/p&gt;
&lt;p&gt;感謝閱讀，以上有問題歡迎留言，或是傳訊息。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[聊聊4年前，剛出社會的我]]></title><description><![CDATA[也是很久之前就一直想紀錄的內容，到現在還是很懷念，所以才會開了生活的分類，雖然生活類只有跟工作有關的面試、面試...。 雖然說時間是…]]></description><link>https://ianccy.com/2019-03-society/</link><guid isPermaLink="false">https://ianccy.com/2019-03-society/</guid><pubDate>Thu, 28 Mar 2019 22:42:03 GMT</pubDate><content:encoded>&lt;p&gt;也是很久之前就一直想紀錄的內容，到現在還是很懷念，所以才會開了生活的分類，雖然生活類只有跟工作有關的面試、面試...。&lt;/p&gt;
&lt;p&gt;雖然說時間是 4 年前，但也算是日記吧。&lt;/p&gt;
&lt;p&gt;主要是記錄我找第一個工作的心情。&lt;/p&gt;
&lt;!--- ![write](../images/write.png &quot;write&quot;) ---&gt;
&lt;h2&gt;找工作&lt;/h2&gt;
&lt;p&gt;我是替代役的國防役，九月退伍。記得那時候很認真的準備多益考試，平日有時間就龜在圖書館讀英文，想說多益如果能考個 800 分，對我面試多少有加分吧。&lt;/p&gt;
&lt;p&gt;雖然當下只想加強英文，但我還真不知道想要做啥工作...，俗話說: 企管系樣樣通，樣樣鬆。外加我大學不學好，問我自己有什麼專業，是沒什麼信心。&lt;/p&gt;
&lt;p&gt;只知道企管系畢業可以做行銷、業務、貿易、金融，其實我是滿沒目標的。&lt;/p&gt;
&lt;p&gt;大學我是選行銷組的，但我對大學課程的行銷學還真沒興趣，覺得教授只是拿經典成功例子出來，看圖說故事 &lt;del&gt;個人心得勿戰&lt;/del&gt;。但最後我還是選擇找行銷相關的職缺。&lt;/p&gt;
&lt;h3&gt;行銷職&lt;/h3&gt;
&lt;p&gt;行銷企劃、行銷公關、網路行銷，我那時候還真的使出海投戰術，打開 104 =&gt; 搜尋行銷 =&gt; 有興趣的都投，沒事滑手機就是找工作、投履歷，就是投好投滿，&lt;/p&gt;
&lt;p&gt;一個月半下來，實際面試有 5 間公司，行銷職的面試都有做簡略簡報，我面試當下其實都滿有信心的，當下信心滿滿，事後都無聲卡...。&lt;/p&gt;
&lt;p&gt;過程中一度懷疑人生，覺得自己是不是哪邊有問題。多益成績剛好出來，很悲劇的只有 700...，聽力才 280，考場坐第一排回音超大，簡直耳包。雙重打擊啊~&lt;/p&gt;
&lt;p&gt;對了，我那時面試的有 APP 行銷企劃、貿易行銷業務、遊戲行銷、專利行政、補教業網路行銷。&lt;/p&gt;
&lt;p&gt;APP 行銷企劃是要我準備做分析市場社  交 APP 的簡報，我下載各種 APP，實際的各種研究，不過面試當天主管不在...，只是員工代替幫我面試，然後聽我簡報分享，當下面試官點點頭，最後只說你有什麼問題嗎，就這樣快速的結束了。&lt;/p&gt;
&lt;p&gt;剩下職缺面試也大同小異，幾乎都是問你:能不能勝任工作內容，我回答可以，然後就結束問我有沒有其他問題，之後無聲卡，各種無法理解問題在哪。&lt;/p&gt;
&lt;h3&gt;最後一個&lt;/h3&gt;
&lt;p&gt;比較重要是，最後一個面試是補教業行銷。&lt;/p&gt;
&lt;p&gt;是一個年輕主管面試的，頭髮有點捲捲、戴個眼鏡，看起來人和善好溝通，剛好團隊正在建構中，要找網路行銷職務的人。非常仔細、熱情的跟我分享這間公司、部門的未來發展方向，也保證會給這職位很大的發展空間。&lt;/p&gt;
&lt;p&gt;這個面試我有準備簡報，做分析公司產品跟市場定位(SWOT、4P)。當下面試官很認真的聽我講完，然後給我回饋，記得那時候他是說，面試的時候還不夠了解公司，分析很容易不準確、錯誤方向。我其實滿感動的，因為他是第一個面試給我反饋的人。&lt;/p&gt;
&lt;p&gt;一週後，打開手機收到 email，標題是恭喜邀約信，終於收到這個錄取通知了，當下還開心的跟女友慶祝 XD，真感謝她不停的給我鼓勵。&lt;/p&gt;
&lt;h2&gt;工作&lt;/h2&gt;
&lt;p&gt;剛開始工作，印象最深刻是第一次開會，照慣例，新人都會自我介紹，被經理問到問題: 你未來這一年想學什麼，我就回答: facebook 社群經營、photoshop 修圖、HTML。沒想到經理回說: 你講這麼多，是代表你沒目標、沒方向，你回去再好好思考，再來說。 我聽了當下只有錯愕、跟 what the...。所以我後面對他印象都不太好。&lt;/p&gt;
&lt;p&gt;在這待了兩年，這兩年，同事從 4 個人到最後 10 個人，很幸運的是，遇到了滿多好相處、聰明的同事，這點滿佩服主管的，我覺得他滿會找人才的。&lt;/p&gt;
&lt;p&gt;主管也很願意給你機會、空間發揮。執行長、董事長也會耳提面命，希望員工下班要多多學習。這部分公司文化是真的值得讚美的。&lt;/p&gt;
&lt;p&gt;雖然說公司薪資低了點，但同事間反而有共患難的情感。下班會一起聚餐，甚至會互相討論、分析未來職涯發展，也有資工系跑來做行銷的同事，帶入更多科學的思考，然後一起研究 SEO、Google Adword、CSS、JavaScript。甚至最後我也被影響轉換跑道。&lt;/p&gt;
&lt;p&gt;在這邊幾乎都是從 0 開始，工作時不會太忙，有得時間讓你不停的找東西學、嘗試。&lt;/p&gt;
&lt;p&gt;文長了，有空再分享第一份工作心得吧。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JavaScript Capture Bubble DOM事件獲取&冒泡]]></title><description><![CDATA[JavaScript 處理 DOM 事件上的獲取和冒泡，實務上滿常用到的觀念，可以透過這方式解決一些麻煩問題，例如: popup 視窗的關閉、內外層 DOM 互動關係，另外事件獲取、冒泡也幾乎是面試必考題。 DOM 一般事件綁定 下面的例子，我 container…]]></description><link>https://ianccy.com/2019-03-eventpass/</link><guid isPermaLink="false">https://ianccy.com/2019-03-eventpass/</guid><pubDate>Thu, 21 Mar 2019 03:03:37 GMT</pubDate><content:encoded>&lt;p&gt;JavaScript 處理 DOM 事件上的獲取和冒泡，實務上滿常用到的觀念，可以透過這方式解決一些麻煩問題，例如: popup 視窗的關閉、內外層 DOM 互動關係，另外事件獲取、冒泡也幾乎是面試必考題。&lt;/p&gt;
&lt;!--- ![JavaScript logo](../images/JavaScript-logo.png &quot;JavaScript logo&quot;)
---&gt;
&lt;h2&gt;DOM 一般事件綁定&lt;/h2&gt;
&lt;p&gt;下面的例子，我 container 先綁定 click 事件，再綁定 first，各自彈出自己的 id 名稱，那哪個會先 alert 出來。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;div id=&quot;container&quot;&gt;container
  &amp;#x3C;ul id=&quot;list&quot;&gt;ist
    &amp;#x3C;li id=&quot;first&quot;&gt;number 1&amp;#x3C;/li&gt;
  &amp;#x3C;/ul&gt;
&amp;#x3C;/div&gt;
...
&amp;#x3C;script&gt;
document.getElementById(&apos;container&apos;).addEventListener(&apos;click&apos;,function(e){
  alert(this.id);
});
document.getElementById(&apos;first&apos;).addEventListener(&apos;click&apos;,function(e){
  alert(this.id);
});
&amp;#x3C;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;會是 first 先彈跳出來，因為綁定事件順序並不是代表執行順序，單純只是哪個 DOM 先綁定事件監聽，實際執行序還是要依照 DOM 父子關係判定，除非是綁定到同個 DOM 上，才會依照先後綁定順序執行。&lt;/p&gt;
&lt;iframe src=&quot;//codepen.io/chu1228/embed/rRqGga/?height=400&amp;theme-id=0&amp;default-tab=result&quot; width=&quot;100%&quot; height=&quot;290&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;事件傳遞 Capture Bubble&lt;/h2&gt;
&lt;p&gt;我們可以在 addEventListener(&apos;click&apos;,function(){}, &lt;code&gt;true&lt;/code&gt;)，來決定 useCapture 參數的 boolean，預設沒帶會是設為 false，當 usecaptue 為 true 時，事件觸發會先經由 DOM tree 一路往子層到目標為止，之後再冒泡上去父層，這樣一個完整的流程就是事件獲取與冒泡。&lt;/p&gt;
&lt;p&gt;最重要就是我們有辦法阻止事件獲取冒泡的傳遞，利用 event.stopPropagation function，就可以阻止事件往後傳遞。&lt;/p&gt;
&lt;p&gt;另外 event 還有提供物件 eventPhase，會回傳 0~4 的數值，讓我們可以清楚知道這個事件到什麼階段。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;eventPhase: 0 沒有事件
eventPhase: 1 獲取階段，會以物件父層一直到最高開始執行，最頂端會是Window，
              再來Document，Html，一直到目標為止。
eventPhase: 2 目標階段，這代表事件執行到目標
eventPhase: 3 冒泡階段，會由目標物件的第一層父層開始，一路往上到最頂端window為止。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-TW/docs/Web/API/EventTarget/addEventListener#%E5%8F%83%E6%95%B8&quot; title=&quot;EventListener usecapture MDN&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;EventListener usecapture MDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/dompass.png&quot; alt=&quot;JavaScript dompass&quot; title=&quot;JavaScript dompass&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// get All elements
const nodeList = [...document.querySelectorAll(&apos;*&apos;)];

// add All elements eventListener
nodeList.forEach(elem =&gt; {
    // use true is for capture
    elem.addEventListener(
        &apos;click&apos;,
        e =&gt; alert(`capture ${elem.tagName} phase:${e.eventPhase}`),
        true
    );
    // default false is for bubble
    elem.addEventListener(&apos;click&apos;, e =&gt; alert(`bubble: ${elem.tagName} phase:${e.eventPhase}`));
});
&lt;/code&gt;&lt;/pre&gt;
&lt;iframe src=&quot;//codepen.io/chu1228/embed/EMdwVJ/?height=400&amp;theme-id=0&amp;default-tab=result&quot; width=&quot;100%&quot; height=&quot;290&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/chu1228/pen/EMdwVJ&quot; title=&quot;獲取&amp;#x26;冒泡&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;簡易獲取&amp;#x26;冒泡&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/pen/?&amp;#x26;editable=true&quot; title=&quot;MDN eventphase flow&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;MDN eventphase flow&lt;/a&gt; (MDN 教學)&lt;/p&gt;
&lt;h2&gt;Capture Bubble 實用範例&lt;/h2&gt;
&lt;p&gt;這邊我們用最經典的 popup 例子，需求是要點擊按鈕 click 會讓 popup 顯示的，但在這邊我們希望 popup 內部點擊不會關閉 popup，但是點外部隨便空間會關閉 popup。&lt;/p&gt;
&lt;p&gt;首先監聽 body 點擊會關閉 popup，再來監聽 openPop 按鈕點擊讓 popup 打開，這邊還多下了 &lt;code&gt;e.stopPropagation()&lt;/code&gt;;，防止我點擊 popup 打開觸發 body 點擊被關閉，因為這樣可以中斷點擊 popup 往上冒泡觸發 body 事件。&lt;/p&gt;
&lt;p&gt;再來是 popup 本身需要能點選內部內容，同樣我們也對 popup 使用 e.stopPropagation(); ，讓我們可以點擊 popup 裡面的內容、按鈕。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;button id=&quot;openPop&quot;&gt;open popup&amp;#x3C;/button&gt;
&amp;#x3C;div id=&quot;text&quot;&gt;&amp;#x3C;/div&gt; // fake wording
&amp;#x3C;div id=&quot;popup&quot; class=&quot;&quot;&gt;
  &amp;#x3C;span id=&quot;closePop&quot;&gt;x&amp;#x3C;/span&gt;
  &amp;#x3C;div&gt;
    This is popup
    &amp;#x3C;button onclick=&quot;alert(&apos;hello&apos;)&quot;&gt;Alert Button&amp;#x3C;/button&gt;
   &amp;#x3C;/div&gt;
&amp;#x3C;/div&gt;
...
const popup = document.getElementById(&apos;popup&apos;);
document.getElementById(&apos;openPop&apos;).addEventListener(&apos;click&apos;,(e)=&gt;{
    e.stopPropagation();
    popup.classList.add(&quot;active&quot;);
});

document.body.addEventListener(&apos;click&apos;,()=&gt;{
    close();
});

popup.addEventListener(&apos;click&apos;,(e)=&gt;{
    e.stopPropagation();
});

document.getElementById(&apos;closePop&apos;).addEventListener(&apos;click&apos;,()=&gt;{
    close();
});

function close () {
    popup.classList.remove(&apos;active&apos;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;iframe src=&quot;//codepen.io/chu1228/embed/MxzoZK/?height=400&amp;theme-id=0&amp;default-tab=result&quot; width=&quot;100%&quot; height=&quot;390&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;這觀念真心覺得實用，很多疑難雜症可以處理，或是可以少綁一些 eventlistener，利用父層子層獲取冒泡關係，搭配 stopPropagation。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[SEO關鍵字分析選擇，優化工具介紹]]></title><description><![CDATA[從去年剛開始寫 blog，就一直很想分享的內容，以前曾擔任過行銷，主要是負責 seo 優化，有一些些小技巧跟心得想分享。以前是依靠寫文章，並且在文章內導購手法，記得那時候部門內的全部 blog、官網我都有負責，到最後整體網站流量都還不錯，官網、blog…]]></description><link>https://ianccy.com/2019-02-keywordselect/</link><guid isPermaLink="false">https://ianccy.com/2019-02-keywordselect/</guid><pubDate>Tue, 26 Feb 2019 22:15:08 GMT</pubDate><content:encoded>&lt;p&gt;從去年剛開始寫 blog，就一直很想分享的內容，以前曾擔任過行銷，主要是負責 seo 優化，有一些些小技巧跟心得想分享。以前是依靠寫文章，並且在文章內導購手法，記得那時候部門內的全部 blog、官網我都有負責，到最後整體網站流量都還不錯，官網、blog 都成長非常多。&lt;/p&gt;
&lt;p&gt;先不說廢話了，接下來分享如何使用 google adword 關鍵字分析工具。&lt;/p&gt;
&lt;h2&gt;選擇關鍵字方法&lt;/h2&gt;
&lt;p&gt;假設你希望網站搜尋流量能成長，我會比較推薦用文章來吸流量，這方法相對容易，寫一篇跟跟你產品有正相關的文章，再引導到購買頁面。&lt;/p&gt;
&lt;p&gt;首先我們要先列出、定義，什麼是我們需要的關鍵字，還有產品調性符合的關鍵字。&lt;/p&gt;
&lt;h3&gt;google adword&lt;/h3&gt;
&lt;p&gt;google 關鍵字有個搜尋量預估的工具，可以告訴你每月大概有多少人搜尋這個關鍵字，註冊 adword 後可以免費使用。&lt;/p&gt;
&lt;p&gt;網址 : &lt;a href=&quot;https://goo.gl/3WAtQM&quot; title=&quot;google adword&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google adword&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/keywordtool.png&quot; alt=&quot;keyword tool&quot; title=&quot;keyword tool&quot;&gt;&lt;/p&gt;
&lt;p&gt;點擊關鍵字規劃工具，再點擊&lt;code&gt;尋找新的關鍵字&lt;/code&gt;，輸入&lt;code&gt;雨衣&lt;/code&gt;關鍵字後，可以看到月搜尋流量，還有更多相關的字詞(僅參考用)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/keywordtool2.png&quot; alt=&quot;keyword tool&quot; title=&quot;keyword tool&quot;&gt;&lt;/p&gt;
&lt;p&gt;從上表我們可以看出雨衣是一個有搜尋量的關鍵字，還有其他相關字有雨鞋、雨傘、雨具等等，這些都先列出放到旁邊。&lt;/p&gt;
&lt;h3&gt;google search&lt;/h3&gt;
&lt;p&gt;再來我們打開無痕 chrome，在 google 輸入雨衣，再來檢視 google search 下拉選單的推薦字詞。這邊可以看到有雨衣推薦、雨衣兩件式。這邊出現的字詞，你也可以用 adword tool 輸入看看月搜尋量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/search_rain.png&quot; alt=&quot;keyword search_rain&quot; title=&quot;keyword search_rain&quot;&gt;&lt;/p&gt;
&lt;p&gt;google 搜尋點擊網站進入，再返回上一頁，網站下方就會出現相關搜尋字詞的清單。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/search_more.png&quot; alt=&quot;keyword search_more&quot; title=&quot;keyword search_more&quot;&gt;&lt;/p&gt;
&lt;p&gt;直接滾到 google 搜尋底部，會直接列出相關搜尋。
&lt;img src=&quot;../images/search_related.png&quot; alt=&quot;keyword search_related&quot; title=&quot;keyword search_related&quot;&gt;&lt;/p&gt;
&lt;p&gt;這兩邊也可以找到非常多的關鍵字詞。都可以先列起來。再挑出與你產品有相關的關鍵字，組成一篇完整的文章內容。&lt;/p&gt;
&lt;h2&gt;規劃內容&lt;/h2&gt;
&lt;p&gt;一般來說，會抓 1 個流量大的關鍵字，後面再一起拉幾個有搜尋量，但競爭不激烈的長尾關鍵字，例如說 &lt;code&gt;一件式雨衣、雨衣推薦、年度字2019、ptt&lt;/code&gt;之類的。因為一開始大流量字沒辦法有很好排名，通常都要依賴那些長尾關鍵字撐起流量，慢慢增加整體流量，最後大流量的關鍵字也一起成長排名。&lt;/p&gt;
&lt;p&gt;你整個內容架構，就可以圍繞雨衣一件式或兩件式、材質防水，新年度 2019 設計的雨衣，或是節錄出 ptt 網友推薦內容。&lt;/p&gt;
&lt;p&gt;從產品本身敘述到網友口碑推薦，由內往外、起承轉合架構出內容。有個重點就是，千萬不要剪貼簿東貼西貼別人內容，一來侵害著作權、二來搜尋通常不會太好，google 很喜歡原創內容。&lt;/p&gt;
&lt;h2&gt;標題非常重要&lt;/h2&gt;
&lt;p&gt;到現在，title 還是非常重要...，所以好好拼湊好一段標題，例如說 &lt;code&gt;一件式雨衣，2019新款雨衣推薦&lt;/code&gt;，這種標題雖然看似很芭樂，但是確實還滿有效果的。&lt;/p&gt;
&lt;p&gt;以前我自己推薦這個詞必做，會想辦法生內容，請使用者分享心得，在內容節錄一小段。&lt;/p&gt;
&lt;p&gt;desscription 描述要寫的人看得懂的，雖然他對排名沒有正相關，但你好好打，會吸引人搜尋點擊進來，間接影響點擊率、流量，&lt;/p&gt;
&lt;h2&gt;完成內容後&lt;/h2&gt;
&lt;p&gt;假設你今天內容完成，可以做哪些工作。首先可以發 facebook、社群分享、或是 email 等等，一來透過外部連結讓 google 能快速索引網站、二來增加網站被分享出去散播，進而增加流量的可能。簡而言之就是建立外部連結，這很難沒錯，可遇不可求。&lt;/p&gt;
&lt;p&gt;我自己心得是，網站的流量與 google 排名有絕對的正相關，以前會透過經營 ptt，分享知識型內容，導入流量，但這塊流量非常無感，排名幾乎不會變動。反倒是 facebook 流量幫助非常大，雖然 link 是 nofollow 的，通常一天導入 5000 流量後，排名會突然衝到第一頁，但這方法已經沒用了，後期一樣操作手法完全沒幫助排名了。&lt;/p&gt;
&lt;h2&gt;持續修改優化&lt;/h2&gt;
&lt;p&gt;我從以前就很討厭&lt;code&gt;優化&lt;/code&gt;這個詞，應該叫做隨時準備調整內容、標題方向，當你今天建立好內容後，你應該要利用 search console，持續觀察排名變化，還有透過 ga 了解這個網址，被訪問的流量結構，搜尋流量最珍貴，再來是推薦流量，直接流量次之(以上純個人看法)。&lt;/p&gt;
&lt;p&gt;過了一個月之後，成效還是非常差，這時候你要考慮改變方向，找其他競爭較小比較少人做的關鍵字，修改增減內容。&lt;/p&gt;
&lt;p&gt;但如果很幸運的，排名不斷的進步，你要知道是哪些關鍵字，或那部份的流量幫助成長，你就要小心修改內容去刪減到那部份的關鍵字，保持原本好的部分，刪減你現在沒做到的關鍵字的部分。&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;自己覺得剛開始做 seo，要成長流量很好做，因為從 0 開始，你隨便都能成長流量，但當你流量到一個程度後，要進一步成長，會變得很困難，你可以會挑戰業界最大量的關鍵字，例如 &lt;code&gt;日本旅遊&lt;/code&gt;，那你要規劃得不再只是一頁內容，而是整體網站的串連操作。&lt;/p&gt;
&lt;p&gt;當你做到了，但要保持排名又是另一個學問了...。&lt;/p&gt;
&lt;p&gt;最後，以上都是我非常主觀的個人心得，警示一下有可能過舊沒用。如果有哪些錯誤，再麻煩提醒了。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Javascript Promise example 簡易實作模擬]]></title><description><![CDATA[Javascript 在 ES6 新增了大量非常實用的功能，其中重要一項就是 Promsie，讓我們可以很直覺的處理非同步，在以前如果我們需要同時發出多個非同步請求，就必須在每次調用 function 時，一起在參數帶回 callback 的 function…]]></description><link>https://ianccy.com/2019-02-promise/</link><guid isPermaLink="false">https://ianccy.com/2019-02-promise/</guid><pubDate>Mon, 18 Feb 2019 22:58:16 GMT</pubDate><content:encoded>&lt;p&gt;Javascript 在 ES6 新增了大量非常實用的功能，其中重要一項就是 Promsie，讓我們可以很直覺的處理非同步，在以前如果我們需要同時發出多個非同步請求，就必須在每次調用 function 時，一起在參數帶回 callback 的 function，重複了幾次就變成了波動拳。&lt;/p&gt;
&lt;p&gt;接下來會用 promise 處理 callback hell，還有建立一個簡易的 promise，幫助我們理解 promise。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/callbackhell.png&quot; alt=&quot;javascript callback hell&quot; title=&quot;javascript callback hell&quot;&gt;&lt;/p&gt;
&lt;h2&gt;簡易的 Promise&lt;/h2&gt;
&lt;p&gt;複雜專案可能會出現的波動拳，這畫面我真實有看過...，假設換成用 promise 的話，就可以很輕鬆直覺處理掉，首先我們先建立一個簡單的 ajax function sample code，下面會用 es6 來寫，希望能在整個流程中，讓你了解 es6 的方便。&lt;/p&gt;
&lt;p&gt;宣告一個 getData arrow function，裡面包含 XMLHttpRequest，我們監聽 onreadystatechange，當整個成功取得資料，就調用 resolve 來進行 callback 把資料放進 resolve function 傳遞，當取得資料失敗就調用 reject function 來傳遞資料。&lt;/p&gt;
&lt;p&gt;當我們 new 一個 promise 的同時，我們 callback function 是帶入 function(resolve, reject){resolve or reject}，讓內部 promise function 被我們用 resolve 或是 reject 調用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;promise 三種狀態&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;擱置（pending）：初始狀態，不是 fulfilled 與 rejected。
實現（fulfilled）：表示操作成功地完成。
拒絕（rejected）：表示操作失敗了。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;promise 會等待佇列 pending 狀態，等到被 resolve 觸發 fulfilled，就會開始回調 then，或是被 reject 觸發 catch。&lt;/p&gt;
&lt;p&gt;then 以及 catch 都會回傳一個 promise，也就是說可以&lt;code&gt;.then(()=&gt;{}).then(()=&gt;{}).then(()=&gt;{})&lt;/code&gt;除非有錯誤產生，否則會往下調用下去。&lt;code&gt;.catch(()=&gt;{}).catch(()=&gt;{}).catch(()=&gt;{})&lt;/code&gt;則是當 javascript 有錯誤發生，會開始向下 catch，直到沒錯誤為止才會調用 catch function，同時因為沒錯誤所以會停住。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非同步 function 範例&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// declare arrow function return Promise
// ** new Promise to inherit Promise instance **
const getData = url =&gt;
    new Promise((resolve, reject) =&gt; {
        // create http request
        const xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = () =&gt; {
            console.log(xhttp.readyState);
            if (xhttp.readyState === 4) {
                if (xhttp.status === 200) {
                    // resolve will trigger Promise then callback
                    console.log(JSON.parse(xhttp.response));
                    resolve(JSON.parse(xhttp.response));
                } else {
                    // reject will trigger Promise catch callback
                    reject(xhttp.statusText);
                }
            }
        };
        xhttp.open(&apos;GET&apos;, url, true);
        xhttp.send();
    });

getData(&apos;https://jsonplaceholder.typicode.com/todos/1&apos;)
    .then(res =&gt; {
        // destructuring object
        const { id, title, completed } = res;
        const html = `&amp;#x3C;div class=&quot;item&quot;&gt;
                    &amp;#x3C;p&gt;Id: ${id}&amp;#x3C;/p&gt;
                    &amp;#x3C;div&gt;Title: ${title}&amp;#x3C;/div&gt;
                    &amp;#x3C;div&gt;Completed: ${completed}&amp;#x3C;/div&gt;
                  &amp;#x3C;/div&gt;`;
        const newNode = document.createElement(&apos;div&apos;);
        newNode.innerHTML = html;
        document.querySelector(&apos;#list&apos;).appendChild(newNode);
    })
    // it will run when promise Reject or
    // in then function appear javascript error
    .catch(res =&gt; {
        console.log(res);
        alert(`Something Error ,because ${res}`);
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;iframe src=&quot;//codepen.io/chu1228/embed/yZrVKW/?height=400&amp;theme-id=0&amp;default-tab=js&quot; width=&quot;100%&quot; height=&quot;400&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/chu1228/pen/yZrVKW?editors=1111&quot; title=&quot;codepen promise demo&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;codepen promise demo&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Promise 解決 callback hell&lt;/h2&gt;
&lt;p&gt;那如果我們要繼續拉第二筆資料 /todos/2，這時候就能展現 promise 方便了，當拉完資料後，再回傳一個 promise，再用 then catch 去接受回傳值，反覆下去延伸。&lt;/p&gt;
&lt;p&gt;這樣的寫法優點是比起以往依賴 callback 更直覺，另外每次都分同步取資料都可能會失敗。也很容易針對每個段點做不同的錯誤處理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add more callback&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;...
getData(&apos;https://jsonplaceholder.typicode.com/todos/1&apos;)
  .then(res =&gt; {
    appendItem(res);
    // return getData promise
    return getData(&apos;https://jsonplaceholder.typicode.com/todos/2&apos;)
    }
  )
  .catch(res =&gt; {
    console.log(&apos;top&apos;, res);
  })
  // it will start next promise then catch
  .then(res =&gt; {
    appendItem(res);
    return getData(&apos;https://jsonplaceholder.typicode.com/todos/3&apos;)
    }
  ).catch(res =&gt; {
    console.log(&apos;middle&apos;, res);
  })
  .then(res =&gt; {
    appendItem(res);
    }
  ).catch(res =&gt; {
    console.log(&apos;bottom&apos;, res);
  })

// append html function
const appendItem = (res) =&gt; {
    // prevent get null or undefined trigger .catch
    if (!res) {
      return;
    }
    const { id, title, completed } = res;
    const html = `&amp;#x3C;div class=&quot;item&quot;&gt;
                    &amp;#x3C;div&gt;Id: ${id}&amp;#x3C;/div&gt;
                    &amp;#x3C;div&gt;Title: ${title}&amp;#x3C;/div&gt;
                    &amp;#x3C;div&gt;Completed: ${completed}&amp;#x3C;/div&gt;
                  &amp;#x3C;/div&gt;`;
    const newNode = document.createElement(&apos;div&apos;);
    newNode.innerHTML = html;
    document.querySelector(&apos;#list&apos;).appendChild(newNode);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;iframe src=&quot;//codepen.io/chu1228/embed/yZrMRE/?height=409&amp;theme-id=0&amp;default-tab=js&quot; width=&quot;100%&quot; height=&quot;410&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/chu1228/pen/yZrMRE?editors=1111&quot; title=&quot;codepen promise demo&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;codepen promise demo&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;實現 promise&lt;/h2&gt;
&lt;p&gt;promise 就像是個魔術，直到 es6 以前都很難處理好分同步處理，我們來試著做一個只單純帶有 then catch 簡易的 promise，來幫助我們更了解 promise。&lt;/p&gt;
&lt;p&gt;先來解讀一下 promise，他是依賴 resolve、reject function 調用的，直接 &lt;code&gt;new Promise(()=&gt;{})&lt;/code&gt;，可以看到 promise 內部的狀態，有 status、value、then、catch、finally，這邊就先不理會 finally。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Promise native prototype&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;Promise {&amp;#x3C;pending&gt;}
  __proto__: Promise
  catch: ƒ catch()
  constructor: ƒ Promise()
  finally: ƒ finally()
  then: ƒ then()
  Symbol(Symbol.toStringTag): &quot;Promise&quot;
  __proto__: Object
  [[PromiseStatus]]: &quot;pending&quot;
  [[PromiseValue]]: undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先先用 es6 class 建立一個 promise，依照 promise 內部 code，我們也建立內部的變數 status 以及 value，status 是讓我們判斷 pending 或是 fullfill reject 狀態，value 則是用來接帶進來的值。&lt;/p&gt;
&lt;p&gt;這邊比較容易看不懂的是 constructor(callback)，這個 callback 指的是 new Promise( &lt;code&gt;(res,rej)=&gt;{ res(&apos;Hello&apos;)}&lt;/code&gt; )，簡單講就是你帶進來的 function。我們在使用 promise 會用到兩個 function，reslove 以及 reject，我們也依樣畫葫蘆，依樣命名一個 resolve、reject，依照(resolve,reject)順序帶入 callback，帶進來讓使用者可以調用到。當我們在外部使用第一個 function，就會調用到內部的 reslove，如果是第二個的話則是調用到內部的 reject。&lt;/p&gt;
&lt;p&gt;距離實際的 promise 還缺少了 then、catch，接下來再繼續實作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;build promise&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class promise {
    constructor(callback) {
        // promise status
        this.status = &apos;pending&apos;;
        // create variable to store resolve or reject value
        this.value;
        // resolve is not outside resolve
        // it is use to pass callback function first function

        const resolve = res =&gt; {
            if (this.status === &apos;pending&apos;) {
                this.status = &apos;fullfilled&apos;;
                this.value = res;
            }
        };

        // reject is not outside reject
        // it is use to pass callback function second function
        const reject = res =&gt; {
            if (this.status !== &apos;pending&apos;) {
                this.status = &apos;rejected&apos;;
                this.value = res;
            }
        };

        // it&apos;s keypoint to call reslove or reject function
        // reslove or reject just assign status and value
        try {
            // this resolve is upper resolve function
            callback(resolve, reject);
        } catch (err) {
            reject(err);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;加上 then catch 接受回傳值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;...
  // then will let user call to check status
  then = (success, failed) =&gt; {
      console.log(`then`)
      if(this.status === &apos;fulfilled&apos;){
          return success(this.value);
      }
      if(this.status === &apos;rejected&apos;){
          return failed(this.value);
      }
  }
  // it will call then function and callback second callback function
  catch = cb =&gt; {
      this.then(null,cb);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/chu1228/pen/pGmLez?editors=0011&quot; title=&quot;codepen promise build&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;codepen promise build&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到這裡只是很簡單的 promise 大致上執行邏輯而已，方便我們更好理解 promise 原理，要完整實現還有很多細節要處理，例如說要 then 或是 catch 要 return promise，還有 all race finally 沒有寫上去。你可以看一下更多完整功能要怎實現出來。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/vkarpov15/169d61f210c3420accf96f2081ad716d&quot; title=&quot;vkarpov15/promise.js&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;vkarpov15/promise.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;雖然每次用 promise 都很理所當然，規則已經既定是如此，但如果每次使用都能了解背後原理，能夠以不同角度來看待，我自己覺得對我來說，幫助都很大，最近正在無盡的的優化網頁效能，無限感慨中...。&lt;/p&gt;
&lt;p&gt;如果有錯誤歡迎留言，感謝閱讀。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Server-side rendering SEO處理]]></title><description><![CDATA[先來稍微介紹一下為什麼要做 server side render，另外這邊不會使用 next.js，雖然公司目前專案有用到，但我滿推薦用 next.js 的，很好導入並且解決很多需要處理的問題。(雖然有一些 bug、還會頻繁更新，兩年內 version 3 ->…]]></description><link>https://ianccy.com/2019-01-reactssr/</link><guid isPermaLink="false">https://ianccy.com/2019-01-reactssr/</guid><pubDate>Wed, 30 Jan 2019 00:39:25 GMT</pubDate><content:encoded>&lt;p&gt;先來稍微介紹一下為什麼要做 server side render，另外這邊不會使用 next.js，雖然公司目前專案有用到，但我滿推薦用 next.js 的，很好導入並且解決很多需要處理的問題。(雖然有一些 bug、還會頻繁更新，兩年內 version 3 -&gt; 7...)&lt;/p&gt;
&lt;!--- ![react lifecycle](../images/react.png &quot;react lifecycle&quot;) ---&gt;
&lt;h2&gt;Server-side rendering SEO&lt;/h2&gt;
&lt;p&gt;傳統網站內容是依靠後端 php、jsp 等產生 html 內容，稱之為 Server-side rendering，但隨著前端技術演進，所有動態內容不再是連接資料庫取資料，轉變為使用非同步請求，依照不同需要依靠 JavaScript 直接請求 API，然後更新需要改動的 html，雖然說這樣處理很方便，使用者不用換網址發請求，整個畫面重新閃動。&lt;/p&gt;
&lt;p&gt;但這方法背後也產生 SEO 的缺點，動態內容的核心是執行 JavaScript，而網頁爬蟲卻不一定會載入執行網頁上的 JavaScript，雖然 google 官方表示爬蟲會&lt;code&gt;盡可能&lt;/code&gt;的執行 script，但實務上當你要優化 SEO，就可能會避免用非同步拉資料，或是處理其他細節。這方式又稱為 Client-side rendering。&lt;/p&gt;
&lt;p&gt;PS.google 官方表示爬蟲邏輯大概是 索引 -&gt; (有資源後) -&gt; 執行 JavaScript，核心價值在於 URL，不同內容必須要有對應的 URL，才有可能幫你每個分頁分開索引。&lt;/p&gt;
&lt;p&gt;影片推薦觀看，能更了解 JavaScript 與爬蟲之間關係。
&lt;a href=&quot;https://www.youtube.com/watch?v=PFwUbgvpdaQ&quot; title=&quot;Google I/O &amp;#x27;18 javascript website&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Google I/O &apos;18 javascript website&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;React server-side render&lt;/h2&gt;
&lt;p&gt;使用 React 框架，但又需要讓爬蟲能索引得到 html，就需要轉為使用 server-side render，核心概念就是，原本 JavaScript 是用戶端執行產生內容，轉向依靠 server 來產生內容，請求 API 的部分也交由 server 端處理，直接在 server 端拿到畫面相關的資料，這樣爬蟲來索引的同時，就已經拿到了內容了。&lt;/p&gt;
&lt;p&gt;接下來來試著架構出 React server-side render 的架構，會使用到 react 官方的 cli create-react-app，以及 node.js 作為 server。&lt;/p&gt;
&lt;h3&gt;使用 create-react-app cli&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;npx create-react-app react-ssr
cd react-ssr
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;安裝使用 express&lt;/h3&gt;
&lt;p&gt;server side render 需要後端執行 javascript，因此這邊使用 node 來處理，npm i express，再來建立 server folder，在建立一個 index.js，作為我們 server 執行的 root。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;src&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;server&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;index.js&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;純粹只是 client side render，就只要執行 npm run build，再來我們針對 build 出來的資源，用 express 來控制。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const express = require(&apos;express&apos;);
const app = express();
const path = require(&apos;path&apos;);

// host build foler resource
app.use(express.static(path.join(__dirname, &apos;../build&apos;)));

// settting router
app.get(&apos;*&apos;, (req, res) =&gt; {
    res.sendFile(path.join(__dirname + &apos;../build/index.html&apos;));
});

app.listen(8080);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/csr.png&quot; alt=&quot;react csr&quot; title=&quot;react csr&quot;&gt;&lt;/p&gt;
&lt;h2&gt;express render REACT&lt;/h2&gt;
&lt;p&gt;先談談用 node 執行 javascript 會遇到哪些難解問題。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先 node 無法執行 import。
依靠 @babel/register 搭配 @babel/plugin-syntax-dynamic-import、@babel-plugin-dynamic-import-node，讓 express 執行轉譯過的 i
mport。&lt;/li&gt;
&lt;li&gt;node 無法讀取 css、image 會出現 object
利用 style-ignore，避開執行 css 內容，並在這邊處理好 image hash name。&lt;/li&gt;
&lt;li&gt;render react
透過 react-dom/server 的 renderToString 或 renderToStaticMarkup 執行 react。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;剩下 react-router、redux、檔案加入 hash name、hot reload 等等，就先不在這邊討論。
(置底 medium 文章有用到 redux、react-router)&lt;/p&gt;
&lt;h2&gt;建立 server.js、render.js&lt;/h2&gt;
&lt;p&gt;再建立 server.js loader.js 兩個檔案，&lt;code&gt;server.js&lt;/code&gt; 主要負責 express，&lt;code&gt;index.js&lt;/code&gt;則是處理 server 設定 babel、各種預處理修正，&lt;code&gt;render.js&lt;/code&gt; 負責 render 內容。&lt;/p&gt;
&lt;h2&gt;index.js 功能&lt;/h2&gt;
&lt;p&gt;md5File 是為了讀取 image file name，搭配 ignoreStyles 使用，讓 server 讀取到 npm build 出來的 file name。這邊最黑魔法的是 babel/register，也是第一次看過這個用法，很輕鬆不需要 eject 就導入 babel 到 create react app 內。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install md5-file ignore-styles&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const md5File = require(&apos;md5-file&apos;);
const path = require(&apos;path&apos;);

const ignoreStyles = require(&apos;ignore-styles&apos;);
const register = ignoreStyles.default;

const extensions = [&apos;.gif&apos;, &apos;.jpeg&apos;, &apos;.jpg&apos;, &apos;.png&apos;, &apos;.svg&apos;];

// ignore image and style request
register(ignoreStyles.DEFAULT_EXTENSIONS, (module, filename) =&gt; {
    if (!extensions.find(f =&gt; filename.endsWith(f))) {
        // use for style
        return ignoreStyles.noOp();
    } else {
        // use for image and add hash follow react cli
        const hash = md5File.sync(filename).slice(0, 8);
        const bn = path.basename(filename).replace(/(\.\w{3})$/, `.${hash}$1`);
        module.exports = `/static/media/${bn}`;
    }
});
require(&apos;@babel/polyfill&apos;);
require(&apos;@babel/register&apos;)({
    ignore: [/\/(build|node_modules)\//],
    presets: [&apos;@babel/preset-env&apos;, &apos;@babel/preset-react&apos;],
    plugins: [&apos;@babel/plugin-syntax-dynamic-import&apos;, &apos;dynamic-import-node&apos;, &apos;react-loadable/babel&apos;]
});

// it will run express
require(&apos;./server&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;server.js 功能&lt;/h2&gt;
&lt;p&gt;這邊主要就是處理 express 路由，static file 路徑，非常簡單的基本設定，比較特別的是用到 Loadable 來確保有 render component 有執行完成。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install react-loadable express&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import express from &apos;express&apos;;
import path from &apos;path&apos;;
import Loadable from &apos;react-loadable&apos;;

import render from &apos;./render&apos;;

const app = express();
const PORT = process.env.PORT || 4000;

app.use(express.Router().get(&apos;/&apos;, render));
app.use(express.static(path.resolve(__dirname, &apos;../build&apos;)));
app.use(render);

// Loadable listener to make sure that all of your loadable components are already loaded
// https://github.com/jamiebuilds/react-loadable#preloading-all-your-loadable-components-on-the-server
Loadable.preloadAll().then(() =&gt; {
    app.listen(PORT, console.log(`App listening on port ${PORT}!`));
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;render.js 功能&lt;/h2&gt;
&lt;p&gt;這邊就是實際 render react，主要依賴 renderToString 來取得 react 執行後的 html，之後再將 react 的 html 組裝成完整頁面的資料。&lt;/p&gt;
&lt;p&gt;這邊我有傳遞資料給 App wording，假設直接看 view-source:&lt;a href=&quot;http://localhost:4000/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:4000/&lt;/a&gt; 會看到 THIS IS Server Side Render ，但是 client side init 會瞬間不見，這邊可以讓你做一些 call api 後的資料傳遞，但這邊要記得要設定成某個變數名，讓 client 抓取這個變數。&lt;/p&gt;
&lt;p&gt;ps.client 指的是使用者載入時。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import path from &apos;path&apos;;
import fs from &apos;fs&apos;;

import React from &apos;react&apos;;
import { renderToString } from &apos;react-dom/server&apos;;
import Helmet from &apos;react-helmet&apos;;

import App from &apos;../src/app&apos;;

export default (req, res) =&gt; {
    fs.readFile(path.resolve(__dirname, &apos;../build/index.html&apos;), &apos;utf8&apos;, (err, htmlData) =&gt; {
        if (err) {
            console.error(`Error page ${err}`);
            return res.status(404).end();
        }

        const helmet = Helmet.renderStatic();

        const html = injectHTML(htmlData, {
            html: helmet.htmlAttributes.toString(),
            title: helmet.title.toString(),
            meta: helmet.meta.toString(),
            body: renderToString(&amp;#x3C;App wording=&quot;THIS IS Server Side Render&quot; /&gt;)
        });
        res.send(html);
    });
};

const injectHTML = (data, { html, title, meta, body, state }) =&gt; {
    data = data.replace(&apos;&amp;#x3C;html&gt;&apos;, `&amp;#x3C;html ${html}&gt;`);
    data = data.replace(/&amp;#x3C;title&gt;.*?&amp;#x3C;\/title&gt;/g, title);
    data = data.replace(&apos;&amp;#x3C;/head&gt;&apos;, `${meta}&amp;#x3C;/head&gt;`);
    data = data.replace(&apos;&amp;#x3C;div id=&quot;root&quot;&gt;&amp;#x3C;/div&gt;&apos;, `&amp;#x3C;div id=&quot;root&quot;&gt;${body}&amp;#x3C;/div&gt;`);
    return data;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;package.json&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  &quot;dependencies&quot;: {
    &quot;@babel/core&quot;: &quot;^7.1.2&quot;,
    &quot;@babel/plugin-syntax-dynamic-import&quot;: &quot;^7.0.0&quot;,
    &quot;@babel/polyfill&quot;: &quot;^7.0.0&quot;,
    &quot;@babel/register&quot;: &quot;^7.0.0&quot;,
    &quot;babel-plugin-dynamic-import-node&quot;: &quot;^2.1.0&quot;,
    &quot;ignore-styles&quot;: &quot;^5.0.1&quot;,
    &quot;md5-file&quot;: &quot;^4.0.0&quot;,
    &quot;react-frontload&quot;: &quot;^1.0.3&quot;,
    &quot;react-helmet&quot;: &quot;^5.2.0&quot;,
    &quot;react-loadable&quot;: &quot;^5.5.0&quot;,
    &quot;react&quot;: &quot;^16.7.0&quot;,
    &quot;react-dom&quot;: &quot;^16.7.0&quot;,
    &quot;react-scripts&quot;: &quot;2.1.3&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;,
    &quot;test&quot;: &quot;react-scripts test&quot;,
    &quot;eject&quot;: &quot;react-scripts eject&quot;,
    &quot;dev&quot;: &quot;NODE_ENV=development node ./server/index.js&quot;,
    &quot;prod&quot;: &quot;NODE_ENV=production node ./server/index.js&quot;
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Ianpig/react-sample-ssr&quot; title=&quot;Source Code Github&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Source Code Github&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;整個寫完只需要三個檔案，看似簡單，但其實還有非常多部分還未處理，例如 router，要能夠在 server 處理各種路徑 render。開發時需要 hot reload，否則每次更新都要 build。這邊有看到有人有使用 nodeman 處理。各種檔案資源的壓縮優化，這就要依靠 webpack。&lt;/p&gt;
&lt;p&gt;以上問題 next.js 都有提供方法處理，官方還有各種工具整合的 sample code，雖然我自己不太愛 next.js，但它真的解決不少問題。(但是 safari back 存在各種 bug...)&lt;/p&gt;
&lt;p&gt;如果有錯誤的地方，還麻煩提出，感謝閱讀。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@cereallarceny/server-side-rendering-in-create-react-app-with-all-the-goodies-without-ejecting-4c889d7db25e&quot; title=&quot;參考資料 medium cereallarceny&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;參考資料 medium cereallarceny&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[SEO 301、302轉址Redirect，canonical tag重複內容處理]]></title><description><![CDATA[SEO 優化，是眾多細節的組成的，不光光只是設定好 title 而已，還有網站架構、速度、後端設定處理等等，包含非常多項目，對開發人員來說，不論是設計、前端、後端都需要注意。 google search…]]></description><link>https://ianccy.com/2018-12-seoredirect/</link><guid isPermaLink="false">https://ianccy.com/2018-12-seoredirect/</guid><pubDate>Wed, 19 Dec 2018 23:14:11 GMT</pubDate><content:encoded>&lt;p&gt;SEO 優化，是眾多細節的組成的，不光光只是設定好 title 而已，還有網站架構、速度、後端設定處理等等，包含非常多項目，對開發人員來說，不論是設計、前端、後端都需要注意。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/google_search.png&quot; alt=&quot;google search&quot; title=&quot;google search&quot;&gt;&lt;/p&gt;
&lt;p&gt;假設一個網站改版更新，大概會有幾個需求，前端畫面修改、網址架構更新、增加欄位修改 api 等等。&lt;/p&gt;
&lt;p&gt;前端需要注意畫面更新方式，如果是不變化網址(SPA)，內容是經由互動產生內容，那互動產生內容同時，就要有對應的網址參數(window.history.pushState)，然後這些網址要能夠請求拿到各自對應的內容。每個對應的網址參數在列在 sitemap 上，讓 google 有辦法索引。&lt;/p&gt;
&lt;h2&gt;rediect 轉址介紹&lt;/h2&gt;
&lt;p&gt;更換網址架構的話，假設你有個賣蘋果的頁面網址是 domain/product/apple，在 google 搜尋上 &lt;code&gt;網購蘋果&lt;/code&gt; 是第一名，但如果改版後網址要變成 domain/product/freshapple，有個重點非常重要，千萬要記得做轉址。否則 product/apple &lt;code&gt;網購蘋果&lt;/code&gt; 的排名就會歸零。&lt;/p&gt;
&lt;p&gt;白話來說，轉址的概念大概是宣告這個頁面要搬家到另一個頁面的意思，也可以跨 domain 轉。&lt;/p&gt;
&lt;h2&gt;轉址方法&lt;/h2&gt;
&lt;p&gt;依照不同後端語言，各有不同的轉址寫法，但邏輯上都是一樣的，大概分為 301、302、307。&lt;/p&gt;
&lt;h3&gt;rediect 轉址狀態碼&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;301 狀態碼表示網頁已永久遷移至新的位置&lt;/li&gt;
&lt;li&gt;302 狀態瑪表示網頁暫時導向新位置&lt;/li&gt;
&lt;li&gt;307 狀態瑪表示暫時導向新位置，但是保持使用者請求方式不變&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Node.js express 301 語法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;res.redirect(301, &apos;http://example.com&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://support.google.com/webmasters/answer/93633?hl=zh-Hant&quot; title=&quot;google 301 rediect 介紹&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google 301 rediect 介紹&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;哪些網址需要做 redirect&lt;/h2&gt;
&lt;p&gt;www.domain.com 跟 domain.com 就會被 google 是為兩個網站，這時候你可以用 301 轉址處理，避免網站同時存在各種 url 顯示相同網址。
(domain 網站就有做 domain.com redirect to www.domain.com)&lt;/p&gt;
&lt;p&gt;網站同時存在 https:// http:// 兩種可以被訪問，也需要做轉址，假設網址結尾帶有或是無 .php .jsp，也需要指定一個做 301redirect。&lt;/p&gt;
&lt;p&gt;需不需要轉址核心概念就是，這個頁面的內容，只有一個網址可以顯示。&lt;/p&gt;
&lt;p&gt;但是如果今天網址需要帶參數怎辦(utm、gdn)? 這時候就需要 canonical tag。(後半段介紹)&lt;/p&gt;
&lt;h2&gt;轉址缺點、後遺症&lt;/h2&gt;
&lt;p&gt;三年前工作經驗，使用 301 轉址，新網址的關鍵字排名&lt;code&gt;一定&lt;/code&gt;會掉落排名，大概過了一兩週後才會慢慢回升，我會用一定是因為 john muller(google webmaster 發言人)也確實發表過掉落些許排名這件事情。&lt;/p&gt;
&lt;p&gt;但 2016 年時 google&apos;s Gary Illyes 表示 30x 不在會掉落 PageRank。在今年，我的 blog 有做過 301 轉址，大概一兩天之後，在搜尋結果上，新網址會取代舊網址，排名完全沒有變動。&lt;/p&gt;
&lt;iframe border=0 frameborder=0 height=200 width=550 
 src=&quot;https://twitframe.com/show?url=https://twitter.com/methode/status/757923179641839616?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E757923179641839616&amp;ref_url=https%3A%2F%2Fmoz.com%2Fblog%2F301-redirection-rules-for-seo&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;canonical 介紹&lt;/h2&gt;
&lt;p&gt;如果你網站沒辦法經由 301 處理，讓同個頁面有多個網址可以載入取得，或是有重複性內容處理的問題，那你就需要使用 canonical 處理，你可以用 html 的 link 處理。指定目前網址的搜尋權重指派到哪個網址。或是在 server response header 加上 rel=canonical。&lt;/p&gt;
&lt;p&gt;另外 sitemap 也可以指定索引的網址，但效力會被 canonical 蓋過。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;網址為 &lt;a href=&quot;https://example.com/apple?user=ianchuu&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://example.com/apple?user=ianchuu&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;link rel=&quot;canonical&quot; href=&quot;https://example.com/apple&quot; /&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;google 重複性內容處理&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;如果您有某一個網頁可透過多個網址存取，或是不同網頁上存在相似的內容 (例如同時有行動版和桌面版網頁)，Google 會將這些網頁視為相同網頁的重複版本，從中選出一個網址做為「標準」版本並檢索該網址，其他網址則會被視為「重複」網址，檢索頻率會比較低。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://support.google.com/webmasters/answer/139066?visit_id=636808323796527838-1214345128&amp;#x26;rd=1&quot; title=&quot;google 整合重複的網址&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google 整合重複的網址&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;這邊大部分觀念都圍繞在更換網址、處理重複性內容。&lt;/p&gt;
&lt;p&gt;一般網站很高機會遇到重複性內容的問題，因為前端或是後端需要網址參數來變化內容，記得，如果網址有帶參數，但是有沒有帶網頁內容都一樣，就記得加上 canonical，直接指定一個網址讓 google 指派權重。&lt;/p&gt;
&lt;p&gt;但如果網址有帶參數，但是內容不一樣就要列在 sitemap 上或是產生個內部連結，如果沒有做的話，就浪費這個頁面被索引的機會了。&lt;/p&gt;
&lt;p&gt;感謝閱讀，有問題歡迎留言!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Update Next.js 7、react 16 error and bug]]></title><description><![CDATA[前陣子公司專案從 next 3 更新到 7、react 也從 15 更新到 16，希望能加快開發或佈署的速度，順便分享一下踩到了哪些的地雷。 首先呢，update react、react-dom、next，接下來開始測試一下 local build，執行 yarn build…]]></description><link>https://ianccy.com/2018-12-nextupdate/</link><guid isPermaLink="false">https://ianccy.com/2018-12-nextupdate/</guid><pubDate>Sun, 09 Dec 2018 22:00:19 GMT</pubDate><content:encoded>&lt;p&gt;前陣子公司專案從 next 3 更新到 7、react 也從 15 更新到 16，希望能加快開發或佈署的速度，順便分享一下踩到了哪些的地雷。&lt;/p&gt;
&lt;p&gt;首先呢，update react、react-dom、next，接下來開始測試一下 local build，執行 &lt;code&gt;yarn build&lt;/code&gt;，恩...，大概幾隻套件過舊，完全無法編譯，幸好這幾隻套件都有繼續維運，更新一下套件，重新繼續 yarn build =&gt; yarn start。&lt;/p&gt;
&lt;!--- ![node.js](../images/next&amp;react.png &quot;next &amp; react&quot;) ---&gt;
&lt;h2&gt;產生 BUILD_ID&lt;/h2&gt;
&lt;p&gt;發現 run 起來會抓不到 app.js，發現需要處理路徑問題，舊版 next build 出來的目錄，不會帶有 BUILD&lt;em&gt;ID，只會在編譯的時候，拿取.next 的 BUILD&lt;/em&gt;ID 來當作路徑，之前是利用 docker 產生.BUILD_ID。但是新版的會直接寫在 folder name 上。要使用 generateBuildId 產生 buildId，對了，我們 buildId 內容是 git commit hash。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nextjs.org/docs/#configuring-the-build-id&quot; title=&quot;generateBuildId&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;next.js generateBuildId &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外還有 react 更新，所以 eslint 相關插件也要更新到新版，花了&lt;code&gt;一些&lt;/code&gt;(三天)時間再處理 indent 跟一些新版的 eslint rule。&lt;/p&gt;
&lt;p&gt;其餘並沒有改動太大，next.js 拋棄滿多舊有 router 處理，把專案上有用到部分都移除掉，還有 title tag 不在_document.js render。&lt;/p&gt;
&lt;h2&gt;踩坑&lt;/h2&gt;
&lt;p&gt;心裡想更新 react、next 還真是簡單，於是乎信心滿滿的更新到正式機上，但是，才發現事情沒有我想的這麼簡單。&lt;/p&gt;
&lt;p&gt;當天晚上發現各種 error、bug 相繼發生，因為更新幅度非常大，需要花滿多時間判斷問題發生在哪個部分。&lt;/p&gt;
&lt;h2&gt;next.js router bug&lt;/h2&gt;
&lt;p&gt;發現一個非常嚴重的問題，Safari 點選網頁上的連結到外部網站，在返回頁面回來，next 會直接導引到 error page。
( 到我發文這天都沒修復掉，持續有人回報。 )&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zeit/next.js/issues/4103&quot; title=&quot;next.js safari bug &quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;next.js safari bug &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;next.js 有個用法，建立_app.js，當作各個 pages/yourpath.js 共用的 render point，我在這邊處理不同路徑共用 title tag，_app.js 需要依靠 pages/path.js 傳入資料，我就使用了 getInitialProps 來處理 server side call api 取得的資料。&lt;/p&gt;
&lt;p&gt;但是問題發生在 Safari 返回頁面，會使用之前的 cache，並且不對 server 做請求，返回頁面會執行 getInitialProps 但是取不到 server side 拿到的資料，所以資料會錯誤，導致錯誤發生。&lt;/p&gt;
&lt;p&gt;目前看起來問題還在，這邊修復方法是，直接拉掉 getInitialProps 取 server side 資料，改到內層去 render title。&lt;/p&gt;
&lt;h2&gt;react server、client side HTML 不同步&lt;/h2&gt;
&lt;p&gt;這是 react 16 再處理 server side 到 client side render 畫面的邏輯修改，為了增加 render 效能，react 拋棄的比對 server side to client html 比對，官方建議 server side 跟 client side 的 html 要盡量保持一致。如果要有不一樣的話，建議在 componentDidMount setState 處理畫面更新。&lt;/p&gt;
&lt;p&gt;發現部分的 html 畫卡在 server side render layout，修復方法就利用 server side 跟 client side 用不同的 key 值，讓 react 比對 node 做更新。但是如果要更新 dangerouslySetInnerHTML 用 key 方法也沒用，目前 hotfix 作法是兩邊用不同的 html tag 強更新，之後會改為 componentDisMount 更新。&lt;/p&gt;
&lt;h3&gt;react 16 官方宣告&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;In general, we don’t recommend that you render different content on the client versus the server, but it can be useful in some cases (e.g. timestamps).
However, it’s dangerous to have missing nodes on the server render as this might cause sibling nodes to be created with incorrect attributes.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://reactjs.org/blog/2017/09/26/react-v16.0.html#better-server-side-rendering&quot; title=&quot;Better server-side rendering &quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Better server-side rendering &lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;更新大概花了 2 週左右時間，大部分時間都在調整 next config，原先更新是為了使用 react 16 新語法，還有希望能加速專案 build deploy 的速度。結果 next 這部分是有稍快一點，但  主要優點還是在於 react 語法，方便我們在開發上處理更多問題，還有跟上 react 更新腳步，未來希望能夠導入 react hooks。&lt;/p&gt;
&lt;p&gt;很多狀況在測試階段都沒有察覺，不幸的 release 後發現很多問題...，幸好都有找到原因修復掉。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[結構化資料SEO 優化顯示搜尋結果]]></title><description><![CDATA[過去，搜尋引擎難以理解網站的內容屬性，這時就依靠結構化資料(structured data)，這是 Google、Yahoo、Bing 等搜尋引擎根據 schema.org 制定的標記，共同的去支援。這些標記多半是關於網站內容的一些分類，麵包屑(breadcrumb…]]></description><link>https://ianccy.com/2018-11-structuredseo/</link><guid isPermaLink="false">https://ianccy.com/2018-11-structuredseo/</guid><pubDate>Sun, 25 Nov 2018 17:28:59 GMT</pubDate><content:encoded>&lt;p&gt;過去，搜尋引擎難以理解網站的內容屬性，這時就依靠結構化資料(structured data)，這是 Google、Yahoo、Bing 等搜尋引擎根據 schema.org 制定的標記，共同的去支援。這些標記多半是關於網站內容的一些分類，麵包屑(breadcrumb)、文章(article)、活動(event)、影片(video)等等。&lt;/p&gt;
&lt;!--- ![structureddata](../images/structureddata.png &quot;structureddata&quot;) ---&gt;
&lt;p&gt;當你網站有依照規範使用這些標記，就會有助於搜尋引擎理解網站的內容。最重要、也最有回饋感的是，會直接讓網站在搜尋結果顯示更不一樣，間接地幫助提高網站點擊率。google 官方有非常詳盡的支援標籤，以及使用過後搜尋結果的變化。&lt;/p&gt;
&lt;p&gt;接下來會分享些使用標籤的範例、心得。&lt;/p&gt;
&lt;p&gt;google 介紹 : &lt;a href=&quot;https://developers.google.com/search/docs/guides/intro-structured-data&quot; title=&quot;google structured data info&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google structured data info&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;google 支援標籤 : &lt;a href=&quot;https://developers.google.com/search/docs/data-types/article&quot; title=&quot;google support structured data&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google support structured data&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;結構化標記語法&lt;/h2&gt;
&lt;p&gt;有三種語法可以使用，分別為 JSON-LD(google 推薦)、Microdata、RDFa，JSON-LD 是 javascript 的語法類型，這只是 javascript 的資料所以不會顯示在畫面上，Microdata 則是在 html 上標記，所以就需要依賴實際存在的 html 來加入，RDFa 類似 Microdata，是基於 html5 的標記，但語法與 Microdata 不大相同，但邏輯非常類似。&lt;/p&gt;
&lt;p&gt;我個人是比較喜歡用 JSON-LD 的語法，因為比較簡潔好讀寫，看下面範例比較應該很好理解。google 官方是表示三種方法並沒有差異，選擇方便使用的語法即可，但是提醒一下滿多屬性並不支援 Microdata。&lt;/p&gt;
&lt;p&gt;稍微介紹一下 JSON 資料的概念，大概就是 key -&gt; value，key 可以當作名稱，value 則當作值。{ } 稱作為物件，相同一筆的資料都會包覆在這個符號內，[ ] 則是代表陣列，多筆資料的意思。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSON-LD Course 範例&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;script type=&quot;application/ld+json&quot;&gt;
{
  &quot;@context&quot;: &quot;http://schema.org/&quot;,
  &quot;@type&quot;: &quot;schema:Course&quot;,
  &quot;name&quot;: &quot;The Data Scientist&apos;s Toolbox&quot;,
  &quot;description&quot;: &quot;In this course you will get an introduction
                  to the main tools and ideas in the
                  data scientist&apos;s toolbox...&quot;,
  &quot;hasCourseInstance&quot;: {
    &quot;@type&quot;: &quot;CourseInstance&quot;,
    &quot;courseMode&quot;: [&quot;MOOC&quot;,&quot;online&quot;],
    &quot;endDate&quot;: &quot;March 21&quot;,
    &quot;startDate&quot;: &quot;February 15&quot;
  }
}
&amp;#x3C;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;RDFa Course 範例&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;body vocab=&quot;http://schema.org/&quot;&gt;
    &amp;#x3C;main typeof=&quot;Course&quot;&gt;
        &amp;#x3C;h1 property=&quot;name&quot;&gt;The Data Scientist&apos;s Toolbox&amp;#x3C;/h1&gt;
        &amp;#x3C;h2&gt;About this Course&amp;#x3C;/h2&gt;
        &amp;#x3C;p property=&quot;description&quot;&gt;
            In this course you will get an introduction to the main tools and ideas in the data
            scientist&apos;s toolbox...
        &amp;#x3C;/p&gt;
        &amp;#x3C;div rel=&quot;hasCourseInstance&quot; typeof=&quot;CourseInstance&quot;&gt;
            &amp;#x3C;meta property=&quot;courseMode&quot; content=&quot;MOOC&quot; /&gt;
            &amp;#x3C;meta property=&quot;courseMode&quot; content=&quot;online&quot; /&gt;
            &amp;#x3C;h2&gt;Session dates&amp;#x3C;/h2&gt;
            &amp;#x3C;span property=&quot;startDate&quot;&gt;February 15&amp;#x3C;/span&gt; -&amp;#x3C;span property=&quot;endDate&quot;&gt;March 21&amp;#x3C;/span&gt;
        &amp;#x3C;/div&gt;
    &amp;#x3C;/main&gt;
&amp;#x3C;/body&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;breadcrumb 標記&lt;/h2&gt;
&lt;p&gt;最實用也最常用的莫過於麵包屑了，通常網站內容都會有不同的分類，例如說今天有某篇 ga 的文章歸類在 marketing，那結構大概會是 marketing › {{文章標題}}，俗稱麵包屑。再來來使用 JSON-LD 方法來標記。&lt;/p&gt;
&lt;p&gt;首先使用@content 來宣告使用結構化標記，再來以@type 來使用標籤類型 BreadcrumbList，再以陣列[] 來列出多筆，第一筆資料會是 marketing，position 代表排在第一位，name 列上 marketing，item 則列上網址。以此類推往下增加下去，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSON-LD breadcrumb&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;script type=&quot;application/ld+json&quot;&gt;
{
  &quot;@context&quot;: &quot;http://schema.org&quot;,
  // use schema type BreadcrumbList
  &quot;@type&quot;: &quot;BreadcrumbList&quot;,
  // use array as list
  // key name is itemListElement
  &quot;itemListElement&quot;: [{
    &quot;@type&quot;: &quot;ListItem&quot;,
    &quot;position&quot;: 1,
    &quot;name&quot;: &quot;marketing&quot;,
    &quot;item&quot;: &quot;https://ianccy.com/categories/marketing/&quot;
  },{
    &quot;@type&quot;: &quot;ListItem&quot;,
    &quot;position&quot;: 2,
    &quot;name&quot;: &quot;Google Analytics 工作階段介紹、定義&quot;,
    &quot;item&quot;: &quot;https://ianccy.com/gasession/&quot;
  }]
}
&amp;#x3C;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;測試結構化資料&lt;/h2&gt;
&lt;p&gt;進入網站 &lt;a href=&quot;https://search.google.com/structured-data/testing-tool&quot; title=&quot;google 測試結構化資料&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google 測試結構化資料&lt;/a&gt;，點擊輸入程式碼片段，輸入剛剛那段 JSON，點擊下方驗證後，就可以看到語法有沒有成功，如果有錯誤的話，上面會提供修正的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/structuretootl.png&quot; alt=&quot;structured data tool&quot; title=&quot;structured data tool&quot;&gt;&lt;/p&gt;
&lt;p&gt;之後再進入 search console，提交網站索引或是 sitemap，等待搜尋引擎更新索引就大功告成了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/breadcrumb.png&quot; alt=&quot;structured breadcrumb&quot; title=&quot;structured breadcrumb&quot;&gt;&lt;/p&gt;
&lt;h2&gt;搜尋結果錨點 (非 structured data)&lt;/h2&gt;
&lt;p&gt;最後再提供一個最近特別用到修改，下方的搜尋結果出現頁面內的錨點，原本 blog 頁面架構就有用 id 錨點)，查閱結構化資料過後發現，並沒有錨點可以使用的功能，於是我針對搜尋結果有出現錨點的頁面都看過一次 html。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;h2 id=&quot;#錨點名稱&quot;&gt;{{ content }}&amp;#x3C;/h2&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;發現都有相同概念，就是要當你搜尋結果要出現錨點，頁面上就必須要有實體連結可以點過去。於是我就做了頁面左邊的那個點擊 scroll 區塊，大約過了一週後搜尋結果就開始出現錨點。雖然常常一下只顯示麵包屑，一下又只顯示錨點...。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/searchlink.png&quot; alt=&quot;structured searchlink&quot; title=&quot;structured searchlink&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目錄範例&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;div class=&quot;toc-article&quot; id=&quot;toc&quot;&gt;
    &amp;#x3C;div class=&quot;toc-title&quot;&gt;文章目錄&amp;#x3C;/div&gt;
    &amp;#x3C;ol class=&quot;toc&quot;&gt;
        &amp;#x3C;li class=&quot;toc-item toc-level-2&quot;&gt;
            &amp;#x3C;a class=&quot;toc-link&quot; href=&quot;#Google-analytics-設定事件&quot;&gt;
                &amp;#x3C;span class=&quot;toc-text&quot;&gt;Google analytics 設定事件&amp;#x3C;/span&gt;
            &amp;#x3C;/a&gt;
        &amp;#x3C;/li&gt;
        &amp;#x3C;li class=&quot;toc-item toc-level-2&quot;&gt;
            &amp;#x3C;a class=&quot;toc-link&quot; href=&quot;#實作測試&quot;&gt;
                &amp;#x3C;span class=&quot;toc-text&quot;&gt;實作測試&amp;#x3C;/span&gt;
            &amp;#x3C;/a&gt;
        &amp;#x3C;/li&gt;
        &amp;#x3C;li class=&quot;toc-item toc-level-2&quot;&gt;
            &amp;#x3C;a class=&quot;toc-link&quot; href=&quot;#ga-event產生器&quot;&gt;
                &amp;#x3C;span class=&quot;toc-text&quot;&gt;ga event產生器&amp;#x3C;/span&gt;
            &amp;#x3C;/a&gt;
        &amp;#x3C;/li&gt;
        ...
    &amp;#x3C;/ol&gt;
&amp;#x3C;/div&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;結構化資料出了大概 3、4 年了，突然想到 search console 有螢光筆工具，它可以直接畫記結構資料屬性，我在 3 年前有用過，完成但搜尋結果並沒任何變化。&lt;/p&gt;
&lt;p&gt;剩下還有很多的標籤屬性(event、product、recipe、video、article 等等)，其實也沒有技術難度，就依照官方文件範例照著填入需要的資料就好了，唯一難處可能是缺資料 XD。&lt;/p&gt;
&lt;p&gt;再分享個最近實作結構化資料經驗，完成標記提交網站索引後，大概都要一週後才會漸漸地有變化。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Portals render component anywhere example]]></title><description><![CDATA[這幾天專案要處理非常麻煩的畫面，子層被父層 overflow: hidden 加 postion relative 切到部分展開元件，突然想到之前同事提到新功能 Portals，Portals 能夠將元件向任意 dom…]]></description><link>https://ianccy.com/2018-11-reactportal/</link><guid isPermaLink="false">https://ianccy.com/2018-11-reactportal/</guid><pubDate>Mon, 19 Nov 2018 20:34:26 GMT</pubDate><content:encoded>&lt;p&gt;這幾天專案要處理非常麻煩的畫面，子層被父層 overflow: hidden 加 postion relative 切到部分展開元件，突然想到之前同事提到新功能 Portals，Portals 能夠將元件向任意 dom 節點依附渲染，非常酷炫的功能，想說就順便來研究一下 React Portals。&lt;/p&gt;
&lt;p&gt;這邊會介紹兩個範例，頁面上渲染元件，還有渲染元件到 window open。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://reactjs.org/docs/fragments.html&quot; title=&quot;React fragment&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React fragment &lt;/a&gt; 、&lt;a href=&quot;https://reactjs.org/docs/portals.html&quot; title=&quot;React Portals&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React Portals &lt;/a&gt;&lt;/p&gt;
&lt;!--- ![react](../images/react.png &quot;react&quot;) ---&gt;
&lt;h2&gt;React Portals rule&lt;/h2&gt;
&lt;p&gt;要用 React Portals 必須遵照規定的格式 ReactDOM.createPortal(element,container)，第一個參數要傳遞需要渲染的物件，第二個參數 container，建立&lt;code&gt;document.createElement(&apos;div&apos;)&lt;/code&gt; 作為 render 的 container。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;ReactDOM.createPortal(element, container);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;會需要用到兩個 lifeCycle，第一個是 componentDidMount react 元件 render 後調用，另一個則是 componentWillUnmount 在元件被移除後會調用。&lt;/p&gt;
&lt;p&gt;再來在 componentDidMount 上加入要渲染元素的節點，讓這個 component render 後調用 appendChild，讓 dom 依附渲染上去。如果要移除渲染的話，則是控制 component 移除觸發 componentWillUnmount，再調用 removeChild 就完成了移除。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// create component
class Portal extends React.Component {
    constructor(props) {
        super(props);
        // create element as render container element
        this.el = document.createElement(&apos;div&apos;);
    }

    componentDidMount() {
        // select element to render
        const elementId = document.getElementById(&apos;elementId&apos;);
        elementId.appendChild(this.el);
    }

    componentWillUnmount() {
        // select element to remove
        const elementId = document.getElementById(&apos;elementId&apos;);
        elementId.removeChild(this.el);
    }

    render() {
        // first argument as element or string or fragment
        // second argument as render container
        return ReactDOM.createPortal(this.props.children, this.el);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Portals example&lt;/h2&gt;
&lt;p&gt;聽起來可能有點抽象，實際來寫個範例看看。點擊左邊的按鈕是使用 Portals 顯示圖片，右邊的則是一般父子層顯示方法。&lt;/p&gt;
&lt;p&gt;會發現左邊用 Portals 顯示，image 元件會打印到 section 外，避免右邊的一般父子渲染方法，在 section 內被 overflow hidden 蓋住。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codesandbox.io/s/4w42r7p69x&quot; title=&quot;Portals example&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Portals example Code &lt;/a&gt;&lt;/p&gt;
&lt;iframe src=&quot;https://csb-4w42r7p69x-gtgmeeadnb.now.sh/&quot; width=&quot;100%&quot; height=&quot;550&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;Portals open window example&lt;/h2&gt;
&lt;p&gt;Portals 也可以打印到 window open 頁面的節點上。這邊範例是使用了 open window，再將元件透過 document.body.appendChild 渲染到開啟的視窗上。這邊是看到 medium 的範例，是利用 setInterval 每秒執行一次 setState，處理 小視窗 更新 parent 的視窗，有試驗過 postMessage 沒效果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Portal extends React.Component {
    constructor(props) {
        super(props);
        this.el = document.createElement(&apos;div&apos;);
        this.Window = null;
    }

    componentDidMount() {
        this.Window = window.open(&apos;&apos;, &apos;&apos;, &apos;width=800,height=500&apos;);
        this.Window.document.body.appendChild(this.el);
    }

    componentWillUnmount() {
        this.Window.close();
    }

    render() {
        return ReactDOM.createPortal(this.props.children, this.el);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://codesandbox.io/s/nr23kvm144&quot; title=&quot;Portals open window&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Portals open window Code &lt;/a&gt;&lt;/p&gt;
&lt;iframe src=&quot;https://csb-nr23kvm144-nxbmzxxibg.now.sh/&quot; width=&quot;100%&quot; height=&quot;350&quot;&gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[Upload progress bar drag&drop 圖片拖拉上傳進度條]]></title><description><![CDATA[最近剛好要使用圖片上傳的功能，但因為資源較少，所以考慮用網路上的 image api 服務，稍微研究後選擇 imgur 的服務。以前拖拉上傳，都是用套件處理掉，剛好來研究一下如何處理拖拉上傳圖片，附加進度條功能。 我們需要取得 imgur api，再來使用 input…]]></description><link>https://ianccy.com/2018-10-imgprogress/</link><guid isPermaLink="false">https://ianccy.com/2018-10-imgprogress/</guid><pubDate>Sat, 27 Oct 2018 19:47:03 GMT</pubDate><content:encoded>&lt;p&gt;最近剛好要使用圖片上傳的功能，但因為資源較少，所以考慮用網路上的 image api 服務，稍微研究後選擇 imgur 的服務。以前拖拉上傳，都是用套件處理掉，剛好來研究一下如何處理拖拉上傳圖片，附加進度條功能。&lt;/p&gt;
&lt;p&gt;我們需要取得 imgur api，再來使用 input 處理上傳檔案，檔案串接上傳 imgur api，在處理 drag and drop 拖拉上傳檔案，完成後也要串接 imgur api。&lt;/p&gt;
&lt;p&gt;完成頁面: &lt;a href=&quot;https://test.ianccy.com/imgur/&quot; title=&quot;Drop file demo&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Drop upload demo&lt;/a&gt;&lt;/p&gt;
&lt;!--- ![dragupload](../images/dragupload.png &quot;dragupload&quot;) ---&gt;
&lt;h2&gt;申請 imgur api key&lt;/h2&gt;
&lt;p&gt;首先進入 imgur 申請帳號登入，再點選下方的連結，申請屬於自己的 Client ID。後面 call api 會需要使用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://api.imgur.com/oauth2/addclient&quot; title=&quot;imgur Register an Application&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;imgur Register an Application&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看 imgur 提供的 restful api post image，需要帶的有 header client ID，body 則需要有格式
&lt;code&gt;image&lt;/code&gt; A binary file, base64 data, URL for image.限制 10MB 以下，其他則是選填 album(optional)、title、description、name、type。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://apidocs.imgur.com/#c85c9dfc-7487-4de2-9ecd-66f727cf3139&quot; title=&quot;imgur upload api post&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;imgur upload api post&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;imgur jquery ajax sample&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var form = new FormData();
form.append(&apos;image&apos;, &apos;R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&apos;);

var settings = {
    async: true,
    crossDomain: true,
    url: &apos;https://api.imgur.com/3/image&apos;,
    method: &apos;POST&apos;,
    headers: {
        Authorization: &apos;Client-ID {{clientId}}&apos;
    },
    processData: false,
    contentType: false,
    mimeType: &apos;multipart/form-data&apos;,
    data: form
};

$.ajax(settings).done(function(response) {
    console.log(response);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;傳統 input 上傳&lt;/h2&gt;
&lt;p&gt;先簡易的傳統的點擊 input 上傳檔案，首先創建 input tag，type 選擇 file，再來監聽這個 input 有沒有變化，如果他有變化的話，代表獲取到檔案上傳，我們就要轉出這個檔案。&lt;/p&gt;
&lt;p&gt;對了，官網範例是用 jquery ajax，為了方便我們直接拿來用，記得要引入 jquery library。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;...
&amp;#x3C;body&gt;
  &amp;#x3C;input type=&quot;file&quot; accept=&quot;image/*&quot; id=&quot;imageUpload&quot; /&gt;
  &amp;#x3C;img id=&quot;imagePreview&quot;&gt;
  &amp;#x3C;script&gt;
    // listen input change call handleFiles
    document.querySelector(&apos;#imageUpload&apos;).addEventListener(&apos;change&apos;,handleFiles);

    function handleFiles() {
      // get input files object
      var fileList = this.files;
      console.log(fileList);
      if (this.files[0]) {
        // call ajax
        upload(this.files[0]);
      }
    }
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接到檔案後，直接用官網的 sample，調用 ajax post api，headers 帶 Authorization 用產生的 client id，以檔案作為參數。&lt;/p&gt;
&lt;p&gt;完成上傳後，api 會回傳 json 的 string type，所以接到 api 回傳後，要用 JSON.parse 轉成 json type，再取出 link 圖片的網址。這樣就完成了 imgur 的 api 串接。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;...
    function upload(data) {
      var form = new FormData();
      form.append(&quot;image&quot;, data);

      var settings = {
        &quot;async&quot;: true,
        &quot;crossDomain&quot;: true,
        &quot;url&quot;: &quot;https://api.imgur.com/3/image&quot;,
        &quot;method&quot;: &quot;POST&quot;,
        &quot;headers&quot;: {
          &quot;Authorization&quot;: &quot;Client-ID {{clientId}}&quot;
        },
        &quot;processData&quot;: false,
        &quot;contentType&quot;: false,
        &quot;mimeType&quot;: &quot;multipart/form-data&quot;,
        &quot;data&quot;: form
      }

      $.ajax(settings).done(function (response) {
        // get respon string type json
        var res = JSON.parse(response);
        console.log(res.data.link);
        document.getElementById(&quot;imagePreview&quot;).src = res.data.link;
      });
    }
  &amp;#x3C;/script&gt;
&amp;#x3C;/body&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;input upload imgur demo&lt;/li&gt;
&lt;/ul&gt;
&lt;iframe src=&quot;https://test.ianccy.com/imgur/try.html&quot; width=&quot;100%&quot; height=&quot;430&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;上傳檔案 progress bar&lt;/h2&gt;
&lt;p&gt;製作上傳進度條，就需要監聽上傳檔案的進度，在 jquey ajax 在增加 option xhr，延展 jquery 具有 xhr 特性，在使用 xhr 監聽 upload 事件，取得目前上傳檔案的 size，在除以整個檔案後取的比例，再將這個比例帶進 progress bar value，這樣就完成了上傳進度條。&lt;/p&gt;
&lt;p&gt;提醒 fetch 無法使用進度條監聽事件，axios、原生 xmlhttprequest 都有方法實作進度條。&lt;/p&gt;
&lt;p&gt;實作方法 : &lt;a href=&quot;https://github.com/axios/axios#request-config&quot; title=&quot;axios onUploadProgress&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;axios onUploadProgress&lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#%E7%9B%A3%E8%A6%96%E9%80%B2%E5%BA%A6&quot; title=&quot;xmlhttprequest mdn progress bar&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;xmlhttprequest mdn progress bar&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // add progress bar element
  &amp;#x3C;progress id=&quot;progress&quot; style=&quot;display:none&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&amp;#x3C;/progress&gt;
  &amp;#x3C;img id=&quot;imagePreview&quot; onload=&quot;hideProgress()&quot;&gt;
...
        &quot;mimeType&quot;: &quot;multipart/form-data&quot;,
        &quot;data&quot;: form,
        // add xhr to extend ajax
        &quot;xhr&quot;: function() {
            var myXhr = $.ajaxSettings.xhr();
            if(myXhr.upload){
                myXhr.upload.addEventListener(&apos;progress&apos;,progress, false);
            }
            return myXhr;
        },
...
function progress(e){
  if(e.lengthComputable){
    var length = e.total;
    var current = e.loaded;
    var progress = document.getElementById(&apos;progress&apos;);

    var percent = Math.floor((current * 100)/length);
    progress.value = percent;
    if (progress.style.display !== &apos;block&apos;){
      progress.style.display = &apos;block&apos;;
    }
  }
 }
 function hideProgress(){
    document.getElementById(&apos;progress&apos;).style.display = &apos;none&apos;;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;upload progress version&lt;/li&gt;
&lt;/ul&gt;
&lt;iframe src=&quot;https://test.ianccy.com/imgur/try2.html&quot; width=&quot;100%&quot; height=&quot;450&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;拖拉上傳檔案&lt;/h2&gt;
&lt;p&gt;這邊會是技術比較複雜的部分，一般網頁開發比較少用到 drag，首先要了解拖拉物件，會觸發哪些 event，拖拉過程怎麼帶資料互動，&lt;/p&gt;
&lt;p&gt;稍微測試每個事件觸發點，當我開始拖拉一個物件，會先觸發 dragstart =&gt; drag =&gt; dragenter / dragover / dragleave / dragexit =&gt; drop =&gt; dropend，也就是說拖拉物件到放置另一個區塊，會觸發 drop、dropend，其中 drop 會再被放置到有效區塊才會觸發，而且 dragend 無法以外部拖拉檔案觸發，所以我們只要監聽 drop 就好了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML drag API&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;drag 於一個元素或文字選取區塊被拖曳時觸發。
dragend 於拖曳操作結束時觸發（如放開滑鼠按鍵或按下鍵盤的 escape 鍵。
dragenter 於一個元素或文字選取區塊被拖曳移動進入一個有效的放置目標時觸發。
dragexit  當一個元素不再是被選取中的拖曳元素時觸發。
dragleave 於一個元素或文字選取區塊被拖曳移動離開一個有效的放置目標時觸發。
dragover  於一個元素或文字選取區塊被拖曳移動經過一個有效的放置目標時觸發
dragstart 於使用者開始拖曳一個元素或文字選取區塊時觸發。
drop 於一個元素或文字選取區塊被放置至一個有效的放置目標時觸發。

注意：dragstart 與 dragend 事件，在把檔案從作業系統拖放到瀏覽器時，並不會觸發。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;drag 文件: &lt;a href=&quot;https://developer.mozilla.org/zh-TW/docs/Web/API/HTML_Drag_and_Drop_API&quot; title=&quot;MDN HTML Drag_and_Drop_API&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;MDN HTML Drag&lt;em&gt;and&lt;/em&gt;Drop_API&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MDN drag element demo&lt;/li&gt;
&lt;/ul&gt;
&lt;iframe src=&quot;//codepen.io/chu1228/embed/mzoXyR/?height=265&amp;theme-id=0&amp;default-tab=result&quot; width=&quot;100%&quot; height=&quot;250&quot;&gt;&lt;/iframe&gt;
&lt;h3&gt;外部檔案拖拉&lt;/h3&gt;
&lt;p&gt;如果是外部檔案拖拉進的話，依序觸發 dragenter =&gt; dragover =&gt; drop，這幾個動作要取消預設的事件 event.preventDefault()，防止拖拉開啟檔案。可以用 event.dataTransfer.files 來接受拖拉的檔案。&lt;/p&gt;
&lt;p&gt;下面範例用 FileReader 來轉換檔案成 base64 格式，在打印到 img src 上顯示圖片。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;div id=&quot;dragZone&quot;&gt;
&amp;#x3C;img src=&quot;https://fakeimg.pl/450x100/?text=Drop_your_Image&quot;&gt;
&amp;#x3C;/div&gt;
&amp;#x3C;div id=&quot;fileText&quot;&gt;&amp;#x3C;/div&gt;
&amp;#x3C;img src=&quot;&quot; id=&quot;fileImg&quot; /&gt;

&amp;#x3C;script&gt;
var dragZone = document.getElementById(&apos;dragZone&apos;);
var fileText = document.getElementById(&apos;fileText&apos;);
var fileImg = document.getElementById(&apos;fileImg&apos;);
// cancel default event
dragZone.addEventListener(&apos;dragover&apos;,function(e){
  e.preventDefault();
  console.log(&apos;dragover&apos;)
});
dragZone.addEventListener(&apos;drop&apos;,function(e){
  // cancel default event
  e.preventDefault();
  if(e.dataTransfer.files.length &gt; 1){
    alert(&apos;僅支援單一檔案&apos;);
    return;
  }
  var file = e.dataTransfer.files[0];
  if(file.type.indexOf(&apos;image&apos;) === -1){
    alert(&apos;僅支援圖片格式喔&apos;);
    return;
  }
  fileText.innerText = file.name;
  // export file as base64
  var reader = new FileReader();
   reader.readAsDataURL(file);
   reader.onload = function () {
     fileImg.src = reader.result
   };
});
&amp;#x3C;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;iframe src=&quot;https://codepen.io/chu1228/embed/MPxrdq/?height=265&amp;theme-id=0&amp;default-tab=result&quot; width=&quot;100%&quot; height=&quot;500&quot;&gt;&lt;/iframe&gt;
&lt;script async src=&quot;https://static.codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt;
&lt;p&gt;這樣就幾乎完成了。我們只要把上面的 drop 獲取檔案，一起與 ajax 呼叫，就支援拖拉上傳檔案了。&lt;/p&gt;
&lt;p&gt;首先增加包覆的 div，隱藏掉傳統的 input 按鈕，讓外層的區塊點擊觸發點擊 input。再增加上事件監聽，主要依靠 drop 監聽，當獲取檔案時，調用 ajax 傳輸資料。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改先前檔案&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // add container zone and hide input
  &amp;#x3C;div id=&quot;dragZone&quot;&gt;
    拖拉上傳 Drop Upload
    &amp;#x3C;input type=&quot;file&quot; accept=&quot;image/*&quot; id=&quot;imageUpload&quot; /&gt;
    &amp;#x3C;progress id=&quot;progress&quot; style=&quot;display:none&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&amp;#x3C;/progress&gt;
  &amp;#x3C;/div&gt;
...
var dragZone = document.getElementById(&apos;dragZone&apos;);

// add listener click dropzone trigger click input
dragZone.addEventListener(&apos;click&apos;,function(e){
  document.getElementById(&apos;imageUpload&apos;).click();
})
dragZone.addEventListener(&apos;dragover&apos;,function(e){
  e.preventDefault();
});

dragZone.addEventListener(&apos;drop&apos;,function(e){
...
  if(file.type.indexOf(&apos;image&apos;) === -1){
    alert(&apos;僅支援圖片格式喔&apos;);
     return;
  }
  // get file call ajax
  upload(file);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;頁面完成&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://test.ianccy.com/imgur/&quot; title=&quot;Drop file demo&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Drop file demo&lt;/a&gt;&lt;/p&gt;
&lt;iframe src=&quot;https://test.ianccy.com/imgur/&quot; width=&quot;100%&quot; height=&quot;500&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;成功!!這樣就完成拖拉上傳了。&lt;/p&gt;
&lt;p&gt;實際寫一遍會發現其實並沒有太艱難，只是有滿多小細節要處理，包含拖拉事件、串接 api 檔案格式、進度條處理等等。這邊還沒寫邏輯還有圖片寬度高度、size 判斷等等。但擔心繼續寫下去會太長，等下一篇再來處理這些小細節吧。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Google Tag Manager(gtm)教學 觸發、代碼、變數設定介紹]]></title><description><![CDATA[之前有介紹過如何在 tag manager 安裝 ga 追蹤碼，埋設 tag manager 的追蹤碼到網頁後，再來開始進入 tag manager 設定，首先點選 觸發 建立好觸發邏輯，再進入 代碼 增加 ga…]]></description><link>https://ianccy.com/2018-10-tagteach/</link><guid isPermaLink="false">https://ianccy.com/2018-10-tagteach/</guid><pubDate>Tue, 16 Oct 2018 00:03:46 GMT</pubDate><content:encoded>&lt;p&gt;之前有介紹過如何在 tag manager 安裝 ga 追蹤碼，埋設 tag manager 的追蹤碼到網頁後，再來開始進入 tag manager 設定，首先點選 &lt;em&gt;觸發&lt;/em&gt; 建立好觸發邏輯，再進入 &lt;em&gt;代碼&lt;/em&gt; 增加 ga 追蹤碼，綁定設定好的觸發點，再點選提交上去，就完成設定了。&lt;/p&gt;
&lt;p&gt;雖然上次有順手寫掉事件設定，但沒有特別介紹每個設定的邏輯，這次會帶更多細節。以 &lt;a href=&quot;https://work.ianccy.com/commentboard/&quot; title=&quot;留言板&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;留言板&lt;/a&gt; 為範例。&lt;/p&gt;
&lt;p&gt;假設我們要追蹤送出留言，建立一個事件，拿進 ga 當作轉換目標。&lt;/p&gt;
&lt;p&gt;文章連結：&lt;a href=&quot;https://ianccy.com/tagmanager/&quot; title=&quot;tag manager 安裝追蹤碼&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;tag manager 安裝追蹤碼&lt;/a&gt;&lt;/p&gt;
&lt;!--- ![google tagmanager](../images/tagtool.png &quot;google tagmanager&quot;) ---&gt;
&lt;h2&gt;Tag manager 設定邏輯&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;設定 trigger(觸發) =&gt; 設定 tag(代碼) =&gt; publish(提交)

ps. 每個步驟中都可以使用變數
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查看 html 標籤&lt;/h3&gt;
&lt;p&gt;所有的設定都會走上面的流程，每個代碼都一定要包含觸發。這邊我們先做一個觸發，時機點是在送出留言的時候。&lt;/p&gt;
&lt;p&gt;我們先打開連結 =&gt; &lt;a href=&quot;https://work.ianccy.com/commentboard/&quot; title=&quot;留言板&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;留言板&lt;/a&gt;，打開 chrome devtool( 滑鼠右鍵 -&gt; 檢查 )，點選上面的 Elements，點擊左上角的游標標誌。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagchromedev.png&quot; alt=&quot;chrome devtool&quot; title=&quot;chrome devtool&quot;&gt;&lt;/p&gt;
&lt;p&gt;再把游標移到網頁上，會發現出現選取整個區塊，這時候移動到送出按鈕，用游標點擊一下，會發現右邊的 html 會變成選取樣式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagchromedev2.png&quot; alt=&quot;chrome devtool2&quot; title=&quot;chrome devtool2&quot;&gt;&lt;/p&gt;
&lt;h4&gt;按鈕 HTML&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;button type=&quot;button&quot; id=&quot;submitComment&quot; class=&quot;btn btn-secondary&quot;&gt;
    送出
&amp;#x3C;/button&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這時候會發現按鈕的 id &lt;code&gt;submitComment&lt;/code&gt;，通常來說一個頁面的 id 只會存在一個，所以我們會用這個 id 被點擊來作為觸發點，如果你要用 className 也是沒問題，只要處理好判斷即可。&lt;/p&gt;
&lt;p&gt;學會查看網頁的 html 很重要，學會這個工具的話，對你在設定追蹤數據有很大幫助。&lt;/p&gt;
&lt;h2&gt;I.觸發條件&lt;/h2&gt;
&lt;p&gt;先來開始 tag manager 第一個步驟，設定觸發條件。&lt;/p&gt;
&lt;p&gt;打開 tag manager 網頁 &lt;a href=&quot;https://tagmanager.google.com&quot; title=&quot;tagmanager&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;tagmanager&lt;/a&gt;，點擊觸發條件 =&gt; 新增。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagtri.png&quot; alt=&quot;tag manager trigger&quot; title=&quot;tag manager trigger&quot;&gt;&lt;/p&gt;
&lt;p&gt;這時候點擊觸發條件設定，右邊會展開一大堆選項， 大概分類為 網頁瀏覽、點擊、使用者主動參與、其他，這四種。&lt;/p&gt;
&lt;p&gt;我們選擇點擊元素，依狀況不同設定進階條件。選擇要執行的網頁路徑、click id 填上 submitComment。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagsmaple4.png&quot; alt=&quot;tag manager tagsmaple4&quot; title=&quot;tag manager tagsmaple4&quot;&gt;&lt;/p&gt;
&lt;h3&gt;tag manager 觸發簡易介紹&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://support.google.com/tagmanager/topic/7679384?hl=zh-Hant&amp;#x26;ref_topic=3441647&quot; title=&quot;tag manager 官方觸發條件介紹&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;tag manager 官方觸發條件介紹&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;網頁瀏覽&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;網頁瀏覽
使用者一進入網頁，就會觸發 網頁瀏覽。&lt;/li&gt;
&lt;li&gt;DOM 就緒
當使用者進入網頁後，會開始讀取 DOM (html)內容，從上往下跑一次，跑到底就會觸發 DOM 就緒。&lt;/li&gt;
&lt;li&gt;視窗已載入
當讀取完成 DOM 之後，會繼續執行載入檔案內容，例如圖片、影片、js css 檔案、iframe 等等，當這些都載入完成，就會觸發 視窗已載入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;點擊&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;僅連結
使用者點選連結 (&lt;code&gt;&amp;#x3C;a href=&quot;domain/pathname&quot;&gt;Link Text&amp;#x3C;/a&gt;&lt;/code&gt;)，才會觸發。&lt;/li&gt;
&lt;li&gt;所有元素
使用者隨意在頁面上做點擊動作，就會觸發。例如我點了網頁的空白區塊，就會觸發了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;使用者主動參與&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;YouTube 影片
當網站上嵌入 youtube 影片，觀看影片的各種狀況，開始、暫停、完成播放，觀看影片的百分比設定。&lt;/li&gt;
&lt;li&gt;元素可見度
網頁上物件出現在畫面上，都可以算是觸發元素可見度。包括載入出現、滾動出現、變化樣式 css 等等。&lt;/li&gt;
&lt;li&gt;捲動頁數
針對滾動整個網頁觸發，用來計算滾動的百分比，可以讓自己定義要追蹤的比率。&lt;/li&gt;
&lt;li&gt;表單提交
使用者提交表單就會觸發，&lt;code&gt;&amp;#x3C;form&gt;&amp;#x3C;button&gt;送出&amp;#x3C;/button&gt;&amp;#x3C;/form&gt;&lt;/code&gt;form html 架構才會觸發，如果是使用 javascript ajax 傳輸，就不會觸發到表單提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript 錯誤
使用 window.onError 來監聽錯誤，會提供錯誤訊息、錯誤網址、錯誤行號碼等資訊。&lt;/li&gt;
&lt;li&gt;自訂事件
dataLayer.push({event:{eventName}})，會依照 dataLayer 中 event 觸發。&lt;/li&gt;
&lt;li&gt;計時器
可以設定某個動作觸發開始計時，之後再依照設定的時間倒數後在觸發另一個事件。&lt;/li&gt;
&lt;li&gt;記錄變更
當使用 history.pushState()時會被觸發，可以處理 spa 的網址變化，運用在 react-router。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;../images/triggerlist.png&quot; alt=&quot;tag manager triggerlist&quot; title=&quot;tag manager triggerlist&quot;&gt;&lt;/p&gt;
&lt;h2&gt;II.變數&lt;/h2&gt;
&lt;p&gt;變數可能會比較抽象，簡單介紹一下什麼叫做變數，變數可以當作&lt;code&gt;賦予某個值一個名稱&lt;/code&gt;，至於為什麼要命名變數，因為方便我們之後可以直接拿這個變數名稱來使用。&lt;/p&gt;
&lt;p&gt;打開變數區塊=&gt;點擊新增，會看到 tag manager 會預設好幾個比較常用到的變數，click text、url、pathName 等等，下方還可以讓你新增使用者自己的變數，有很多種可以新增，比較常用的會是 dataLayer 帶變數、還有 javascript function return。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;javascript function return - 回傳留言欄位的內容&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function(){
  return document.getElementById(&apos;commentValue&apos;).value
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagtitle.png&quot; alt=&quot;tag manager tagtitle&quot; title=&quot;tag manager tagtitle&quot;&gt;
上面的名稱我取作 comment&lt;em&gt;value，也就是說之後只要其他地方輸入 {{comment&lt;/em&gt;value}} 就可以取得留言的內容。&lt;/p&gt;
&lt;p&gt;這邊如果不會寫 javascript 的話，也可以使用內建好的變數，記得要勾選後才能被取用。&lt;/p&gt;
&lt;h2&gt;III.代碼&lt;/h2&gt;
&lt;p&gt;這部分就是 tag manager 的核心，經由設定觸發條件，然後執行代碼。tag manager 整合非常多的不同工具，除了 facebook pixel...。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://support.google.com/tagmanager/answer/6106924&quot; title=&quot;tag manager 支援代碼&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;tag manager 支援代碼&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我們以 ga 設定事件為例子，原本你在 ga 設定事件，會需要在網站上寫&lt;code&gt;ga(&apos;send&apos;, &apos;event&apos;, 類別, 動作, 標籤 )&lt;/code&gt;，在這邊都視覺化了，每個類別、動作、標籤都分欄位讓你輸入，所以不用會寫 javascript，你也可以輕易設定事件，更重要是不需要透過工程師幫你處理。&lt;/p&gt;
&lt;p&gt;簡單講就是，你在 tag manager 的追蹤設定，不會影響到原本網站上的程式架構。網站上一定會埋一堆哩哩摳摳的程式碼，對工程師來說每建立一個新頁面都要用整包，畫面不乾淨也不好維運。它可以幫助你追蹤碼分離掉。&lt;/p&gt;
&lt;p&gt;點擊代碼新增 =&gt; 選擇 google analytics，使用 ga 的事件。&lt;/p&gt;
&lt;p&gt;再來建立類別、動作、標籤，標籤這邊用我們建立的變數&lt;code&gt;comment_value&lt;/code&gt;，最後觸發條件再選擇送出留言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagsmaple5.png&quot; alt=&quot;tag manager tagsmaple5&quot; title=&quot;tag manager tagsmaple5&quot;&gt;&lt;/p&gt;
&lt;h2&gt; 追蹤 adblock 實作範例&lt;/h2&gt;
&lt;p&gt;上面講了一遍後，再來試著操作一遍，需求是，要追蹤來我的 blog 的人，有多少人使用 adblock，使用 ga 事件來記錄。&lt;/p&gt;
&lt;p&gt;以需求來看，觸發點就會是載入頁面後，判斷廣告區塊沒有正常顯示，所以我們要建立一個觸發，執行 ga 事件的代碼。&lt;/p&gt;
&lt;p&gt;這邊來用 tag manager 代碼區塊的自訂 html。建立一個 javascript，這段是要判斷 google-auto-placed 有沒有在 html 上，這是 google 自動廣告會帶的 className，如果沒有這個 class，就代表使用者有裝設 adblock。然後使用&lt;code&gt;dataLayer.push({event: &apos;getAdblock&apos;})&lt;/code&gt;產生自訂事件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代碼區塊使用自訂 html&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;script&gt;
  if (document.getElementsByClassName(&apos;google-auto-placed&apos;).length === 0) {
    dataLayer.push({
      event: &apos;getAdblock&apos;
    });
  }
&amp;#x3C;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagsample.png&quot; alt=&quot;tag manager tagsample&quot; title=&quot;tag manager tagsample&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下來，到觸發區塊點選點選 自訂事件，在輸入剛剛 push event 的名稱 getAdblock。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagsample3.png&quot; alt=&quot;tag manager tagsample3&quot; title=&quot;tag manager tagsample3&quot;&gt;&lt;/p&gt;
&lt;p&gt;進入代碼區塊，建立一個 ga 事件，再輸入事件類別、動作、標籤，觸發就選擇剛剛建好的觸發條件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagsample2.png&quot; alt=&quot;tag manager tagsample2&quot; title=&quot;tag manager tagsample2&quot;&gt;&lt;/p&gt;
&lt;p&gt;這樣就大功告成了!!&lt;/p&gt;
&lt;p&gt;ps.記得點開 tag manager 預覽模式，來看一下代碼有沒有成功跑起來。&lt;/p&gt;
&lt;h2&gt;工作實作心得&lt;/h2&gt;
&lt;p&gt;記得我兩年前第一次接觸 tag manager，評語是 &lt;em&gt;這鬼東西太複雜難用了吧&lt;/em&gt; 。但不知道是不是兩年間有改版，最近回頭接觸的感想，發現其實滿好用的！特別是預覽模式，很清楚的在發布前測試有沒有設定正確。&lt;/p&gt;
&lt;p&gt;會一直介紹 tag manager 的原因，絕對不是因為我最近每天工作都要接觸 tag manager(眼神死...)，是 tag manager 功能真的太強大了，對前端開發來說也減少非常多的工時，省去在專案上處理各種 ga(xxx)的麻煩、突兀，轉而關注處理 dataLayer。&lt;/p&gt;
&lt;p&gt;最後最後，如果你是行銷人，然後會用 tag manager 的話，我非常敬佩你。&lt;/p&gt;
&lt;p&gt;感謝閱讀！&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Node.js Express MongoDB RESTful Api 留言板實作教學]]></title><description><![CDATA[前端不斷的演進，更講求畫面快速變化，跳脫傳統傳送資料方式，漸漸改為用 javascript 連接，所以，server 端就負責建立 api，透過串接 api 處理資料。 關於 Api， 就有所謂的 RESTful (Representational State…]]></description><link>https://ianccy.com/2018-10-nodejsapi/</link><guid isPermaLink="false">https://ianccy.com/2018-10-nodejsapi/</guid><pubDate>Thu, 11 Oct 2018 22:40:24 GMT</pubDate><content:encoded>&lt;p&gt;前端不斷的演進，更講求畫面快速變化，跳脫傳統傳送資料方式，漸漸改為用 javascript 連接，所以，server 端就負責建立 api，透過串接 api 處理資料。&lt;/p&gt;
&lt;p&gt;關於 Api， 就有所謂的 RESTful (Representational State Transfer)，RESTful 是某種設計架構的稱呼，方便、有彈性的傳輸資料。後面來會用 node.js 搭配 express 架構 RESTful Api，部署到 server 上，建立一個簡單的留言板。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://work.ianccy.com/commentboard/&quot; title=&quot;Demo comment board&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Demo comment board&lt;/a&gt;
Free Heroku 會 sleep，太慢請 reload&lt;/p&gt;
&lt;!--- ![node restful api](../images/nodeapi.png &quot;node restful api&quot;) ---&gt;
&lt;h2&gt;安裝 Node.js express&lt;/h2&gt;
&lt;p&gt;首先先創建資料夾，npm init 安裝 package.json。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// create file
mkdir nodeapi
cd nodeapi
// install package.json
npm init
// install express
npm install --save express
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下來要開始建立 node.js server&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// open package.json &amp;#x26; add npm start
...
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node index.js&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;#x26;&amp;#x26; exit 1&quot;
  },
...

// create index.js
touch index.js
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;建立 nodejs server&lt;/h2&gt;
&lt;p&gt; 以 index.js 作為 node.js server 的起始點，首先引入 express，執行使用 express，這邊先設定好 Port 是 3000，再來建立 get 的 route，路徑是/comments。儲存後執行 npm start，在網址輸入 &lt;a href=&quot;http://localhost:3000/%EF%BC%8C%E9%80%99%E6%99%82%E5%80%99%E6%9C%83%E7%9C%8B%E5%88%B0%E7%95%AB%E9%9D%A2%E9%A1%AF%E7%A4%BA&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/，這時候會看到畫面顯示&lt;/a&gt; Hello world。&lt;/p&gt;
&lt;h4&gt;/index.js&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const express = require(&apos;express&apos;);
const app = express();

const port = 3000;

app.get(&apos;/&apos;, (req, res) =&gt; {
    res.sendFile(__dirname + &apos;/index.html&apos;);
});

app.listen(port, function() {
    console.log(`server start on http://localhost:${port}, port`);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;index.html&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;!DOCTYPE html&gt;
&amp;#x3C;html lang=&quot;en&quot;&gt;
&amp;#x3C;head&gt;
  &amp;#x3C;meta charset=&quot;UTF-8&quot;&gt;
  &amp;#x3C;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &amp;#x3C;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &amp;#x3C;title&gt;Document&amp;#x3C;/title&gt;
&amp;#x3C;/head&gt;
&amp;#x3C;body&gt;
  &amp;#x3C;h1&gt;Hello!!&amp;#x3C;/h1&gt;
&amp;#x3C;/body&gt;
&amp;#x3C;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;建立 mLab account 創建 mongoDB&lt;/h2&gt;
&lt;p&gt;因為我想試試看串接 mongoDB，這邊選用 mLab 來管理 mongoDB，流程大概是進入 mlab 網站，建立帳戶，再來創建 db，點擊建立 User，設定帳號、密碼、權限。&lt;/p&gt;
&lt;p&gt;這邊雖然看似簡單但非常麻煩。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.mlab.com/&quot; title=&quot;mlab 建立mongoDB教學&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;mlab 建立 mongoDB 教學&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;記得要 create user，後面會依靠這個 username 跟 password 來串接 mongoDB，我因為打錯 dbName，顯示 &lt;em&gt;MongoError: not authorized on dbname to execute command&lt;/em&gt;，大概卡了 40 分鐘...。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/createmlab.png&quot; alt=&quot;createmlab&quot; title=&quot;createmlab&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先安裝 mongodb。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;npm install --save mongodb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index.js 增加內容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// modify index.js
...
const MongoClient = require(&apos;mongodb&apos;).MongoClient;

const url = &apos;mongodb://ian:PASSWORD@ds131323.mlab.com:31323/ian-test&apos;;

MongoClient.connect(url, function(err, db) {
    if (err) throw err;
    const dbo = db.db(&quot;ian-test&quot;);
    const myobj = { name: &quot;john&quot;, time: &quot;2018/10/13/00:58&quot;, content: &quot;hello, good evening&quot; };
    dbo.collection(&quot;comments&quot;).insertOne(myobj, function(err, res) {
      if (err) throw err;
      console.log(&quot;1 document inserted&quot;);
      db.close();
    });
});
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改完成後輸入 npm start，如果沒出現 error 就可以打開 collection 觀看，會增加一個 comments 的 collection，點開 comments 會發現剛剛 myobj 資料在裡面。這邊是建立資料邏輯，在 RESTful 會用到 Create，剩下更新 PUT、刪除 Delete、讀取 Get 後面再寫上。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3schools.com/nodejs/nodejs_mongodb_createcollection.asp&quot; title=&quot;w3c mongoDB 語法教學&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;w3c mongoDB 語法教學&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/mlabData.png&quot; alt=&quot;mlabData&quot; title=&quot;mlabData&quot;&gt;&lt;/p&gt;
&lt;h2&gt;POST Api 創建資料&lt;/h2&gt;
&lt;p&gt;這邊要下載 body-parser 插件，要對資料格式處理，這邊要使用到是 JSON data。在 index.js 引入 body-parser，使用 bodyParser 對資料轉型別成 json type，建立 post 的 route，我們命名路徑為/comments。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;npm install body-parser --save
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;index.js&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;...
const bodyParser = require(&apos;body-parser&apos;);

app.use(bodyParser.json());

app.post(&apos;/comments&apos;, (req, res) =&gt; {
    console.log(req.body);      // your JSON
    db.collection(&apos;comments&apos;).save(req.body, (err, result) =&gt; {
        if (err) return console.log(err)
        console.log(&apos;saved to database&apos;)
        res.send(req.body);
    });
})

// modify app.listen(3000, () =&gt; {});
MongoClient.connect(url, (err, client) =&gt; {
    if (err) return console.log(err)
    db = client.db(&apos;ian-test&apos;)
    app.listen(port, () =&gt; {
        console.log(&apos;listening on 3000&apos;)
    })
})
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改完成後重新 npm start，打開 localhost:3000，打開瀏覽器 devtool，在 console.log 貼上這段 fetch post，成功的話會接收到回傳資料，哇嗚，這樣就完成了儲存的 API!!&lt;/p&gt;
&lt;h4&gt;javascript fetch post&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;fetch(&apos;http://localhost:3000/comments&apos;, {
    method: &apos;post&apos;,
    headers: {
        Accept: &apos;application/json, text/plain, */*&apos;,
        &apos;Content-Type&apos;: &apos;application/json&apos;
    },
    body: JSON.stringify({
        name: &apos;mikessss&apos;,
        time: &apos;2018/10/13-02:33:01&apos;,
        content: &apos;ggggggg.&apos;
    })
})
    .then(res =&gt; res.json())
    .then(res =&gt; console.log(res));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Get Api 取得資料&lt;/h2&gt;
&lt;p&gt;我們前面成功的建立了儲存的 api，之後的邏輯都大同小異，接收 request，再依照請求方式跟 mongoDB 連接資料。我們這邊的 get api 會拿整個 comments 的資料，如果看不懂 collection.find()，可以看一下 w3c 的 mongoDB 語法教學，非常簡單易懂。&lt;/p&gt;
&lt;p&gt;增加完成後，一樣重新啟動，再來載入 &lt;a href=&quot;http://localhost:3000/comments%EF%BC%8C%E5%B0%B1%E7%9C%8B%E5%88%B0%E6%88%91%E5%80%91%E5%89%9B%E5%89%9B%E5%84%B2%E5%AD%98%E9%80%B2%E5%8E%BB%E7%9A%84%E6%89%80%E6%9C%89%E8%B3%87%E6%96%99%E4%BA%86%E3%80%82%1C&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/comments，就看到我們剛剛儲存進去的所有資料了。&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;index.js&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;...

app.get(&apos;/comments&apos;, (req, res) =&gt; {
  db.collection(&apos;comments&apos;).find().toArray((err, result) =&gt; {
    if (err) return console.log(err)
    res.send({data: result})
  })
})

...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Delete Api 取得資料&lt;/h2&gt;
&lt;p&gt;這邊就建立一個 delete 的網址路徑，我們利用網址:id 來帶參數，方便我們好維運 api。mongoDB 刪除用的是 remove function，假設要用 mongoDB 預設的_id 當作查詢刪除，會多需要使用 ObjectID 處理 value，但如果你是自己用其他物件來查詢，就不用使用 ObjectID。&lt;/p&gt;
&lt;p&gt;這邊就不提供 fetch 測試了，推薦使用 postman 測試請求方式，又簡單又快又方便。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop&quot; title=&quot;postman chrome tool&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;postman chrome tool&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const ObjectID = require(&apos;mongodb&apos;).ObjectID;

app.delete(&apos;/comments/:id&apos;, (req, res) =&gt; {
    // use _id need use ObjectID(value)
    const obj = { _id: ObjectID(req.params.id) };
    db.collection(&apos;comments&apos;).remove(obj, function(err, obj) {
        if (err) throw err;
        console.log(&apos;1 document deleted&apos;);
        res.send(&apos;delete success&apos;);
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Update Api 更新資料&lt;/h2&gt;
&lt;p&gt;建立 put 的 route，使用 updateOne 來更新資料，前面兩個參數要帶查詢、更新資料。&lt;/p&gt;
&lt;p&gt;這樣就完成了 CRUD 的 API 了，下個步驟會建立簡單的畫面，在部署到 server 上，讓我們可以在畫面操作讀取、建立、更新、刪除資料。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascripts&quot;&gt;app.put(&apos;/comments/:id&apos;, (req, res) =&gt; {
    console.log(req.params.id, req.body);
    const newvalues = {$set: req.body};
    const obj = {_id: ObjectID(req.params.id)};
    db.collection(&quot;comments&quot;).updateOne(obj, newvalues, function(err, obj) {
        if (err) throw err;
        console.log(&quot;1 document update&quot;);
        res.send(&apos;update success&apos;);
    });
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;localhost api file&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Ianpig/node_api_comments/tree/831ddadd7cbde2f39f34adca1625e50e97a2e1c9&quot; title=&quot;github 程式碼&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;github 程式碼&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;部署到 Heroku&lt;/h2&gt;
&lt;p&gt;部署到 server 上，讓我們未來方便直接串接 api，提醒一下要到 heroku 設定 mLab 的連線，否則會連不到 mongoDB。
(這邊我也卡了 30 分鐘...，安裝 addons 也沒用，是執行下面的 command 才 run 起來)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;heroku config:set PROD_MONGODB=mongodb://dbname:password@ds131323.mlab.com:31323/ian-test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://devcenter.heroku.com/articles/mongolab#connecting-to-existing-mlab-deployments-from-heroku&quot; title=&quot;heroku mLab setting&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;heroku mLab setting&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;heroku deploy 流程&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//login account
heroku login

//use git
git init
git add .
git commit -m &quot;init node&quot;

// create heroku repo
heroku create

// push remote
git push heroku master

heroku ps:scale web=1

heroku open
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來載入 /comments 路徑，&lt;a href=&quot;https://thawing-stream-74537.herokuapp.com/comments&quot; title=&quot;pathname/comments&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;pathname/comments&lt;/a&gt;，看到 mongoDB 的資料拉!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/apidata.png&quot; alt=&quot;node api data&quot; title=&quot;node api data &quot;&gt;&lt;/p&gt;
&lt;p&gt;大功告成，接下來就處理好前端串接，畫面互動就可以了。&lt;/p&gt;
&lt;h3&gt;實作頁面&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://work.ianccy.com/commentboard/&quot; title=&quot;Demo comment board&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Demo comment board&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;完整程式碼&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Ianpig/node_api_comments&quot; title=&quot;github 程式碼&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;github 程式碼&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有問題歡迎詢問，感謝閱讀！！&lt;/p&gt;</content:encoded></item><item><title><![CDATA[第一次面試人]]></title><description><![CDATA[因為一些緣故，某個前端同事離職了。人總會來來去去，雖然我到職相處三個月多，但還是不禁有點感傷。為了補上人力缺口，公司很快地開始招募員工，沒想到，要我跟另一個前端同事 Joey…]]></description><link>https://ianccy.com/2018-09-firstinterviewer/</link><guid isPermaLink="false">https://ianccy.com/2018-09-firstinterviewer/</guid><pubDate>Thu, 27 Sep 2018 21:18:55 GMT</pubDate><content:encoded>&lt;p&gt;因為一些緣故，某個前端同事離職了。人總會來來去去，雖然我到職相處三個月多，但還是不禁有點感傷。為了補上人力缺口，公司很快地開始招募員工，沒想到，要我跟另一個前端同事 Joey 一起擔任面試角色。&lt;/p&gt;
&lt;p&gt;雖然在前公司有面試過人，以前只負責一關，但這次不太一樣，整個技術關卡由前端負責，所以心情也比較緊張。但還好有跟同事一起面試，很多流程可以互相幫忙，也可以有餘力，用旁觀者角度觀察面試流程，看哪邊需要再改進。&lt;/p&gt;
&lt;!--- ![interview chair](../images/chair.png &quot;interview chair&quot;) ---&gt;
&lt;pre&gt;&lt;code&gt;寫這篇文章，是為了記錄第一次面試。每個步驟給我的回饋

也分享一下心得
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;準備面試&lt;/h2&gt;
&lt;p&gt;大概花了一兩天跟 joey 討論，要怎規劃面試內容， 每一個 part 的時間要怎抓，最後大概是抓 15 分鐘自我介紹，30 分鐘口頭問答，我們在針對前面部分做額外提問，最後在讓面試者提問。&lt;/p&gt;
&lt;p&gt;不希望面試者要自我介紹兩次，所以我們是兩個人一起面試，我是負責 javascript、joey 則是介紹公司、跟 web 問題。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;介紹公司 =&gt; 面試者介紹 =&gt; 技術面試 =&gt; 針對個人問題 =&gt; 面試者提問
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我們討論共識精神是，_ 不要讓面試太冗長、讓對方覺得被尊重 _。以往面試每間公司，幾乎都要花上 2、3 小時，滿耗費時間，更不希望分一面二面的。&lt;/p&gt;
&lt;p&gt;原本是有一直想導入 coding test，但是最後結論是視狀況而定，除非覺得面試者不錯，但作品或經歷看不出來才考慮，如果每個人都 coding test 會太耗時。&lt;/p&gt;
&lt;p&gt;另外我們還針對不同情境假想，假設，發現面試者是大神，要怎跟對方交流，才不會失禮等等。&lt;/p&gt;
&lt;h2&gt;瀏覽履歷&lt;/h2&gt;
&lt;p&gt;主管決定人選約面試，約到之後，我的信箱就會收到履歷，所以我沒有歷經在 104 上面搜尋、篩選履歷。&lt;/p&gt;
&lt;p&gt;打開信件後，就要開始透過少少的資料來了解面試者，這時候如果有作品就太棒了，實作比列在技能上還印象深刻，還可以順便看 code，加分加分。&lt;/p&gt;
&lt;p&gt;看完會開始整理面試的問題，可能是作品，也可能是履歷的。&lt;/p&gt;
&lt;p&gt;如果公司是認真的在面試，&lt;em&gt;我相信在履歷上的每樣內容，都很重要。&lt;/em&gt;這是我看了幾份履歷的感想，因為履歷是唯一在面對面之前，可以了解你的線索。&lt;/p&gt;
&lt;h2&gt;實際面試&lt;/h2&gt;
&lt;p&gt;一開始會先由主管面試，之後再換技術部分。第一個面試，進門我簡單問候後，坐上椅子心情其實興奮又緊張，幾個月前還是坐在被面試的位置，沒想到幾個月後，居然會幫忙面試。&lt;/p&gt;
&lt;p&gt;第一個面試不是很順利，對方技術測驗都沒回答，反而是每個題目都反問，花了不少時間解釋答案...，流程延後了 30 分鐘。事後檢討是解答點到為止就好，給關鍵字給面試者回去搜尋。&lt;/p&gt;
&lt;p&gt;每次面試之後，我們都會互相檢討，這次面試是不是足夠了解對方的能力，或是流程上哪邊可以在改善。經過修修改改後，時間控制就很順暢了，&lt;/p&gt;
&lt;p&gt;每次面試後互相檢討，我是覺得很有用，後面的面試都很順利，不太會有狀況發生，網路斷網太慢、電腦出問題。&lt;/p&gt;
&lt;h4&gt;面試題目&lt;/h4&gt;
&lt;p&gt;只剩下面試最大的問題，到底這些面試問題，跟能不能勝任工作內容有關嗎?_&lt;/p&gt;
&lt;p&gt;設計的題目多圍繞 javascript 基礎、react 基礎、web 基本知識等等，多半是問一些基礎，了解基礎的優點在於開發上少採很多雷。&lt;/p&gt;
&lt;p&gt;如果我跟 joey 都看不出面試者程度，就用 coding test 來驗證，題目是 parallax 實作。&lt;/p&gt;
&lt;p&gt;這方法我覺得滿不錯的，可以快速理解對方對 es6、javascript 熟悉度。缺點就是對方可能寫不完，大概要抓 30 ~ 40 分鐘打斷，讓對方轉為口頭介紹。&lt;/p&gt;
&lt;h4&gt;使用 react 較少&lt;/h4&gt;
&lt;p&gt;這次面試比較常遇到問題，面試滿多人使用 vue，但我們相信熟悉框架的人，轉來使用 react 是沒有太大障礙的。比較麻煩是遇到就要惡補 vue 知識，至少知道對方是講正確的內容。&lt;/p&gt;
&lt;h2&gt;選擇人選&lt;/h2&gt;
&lt;p&gt;每次面試後，都會決定人選，對於這份工作是否適合，也有可能是公司、工作內容不適合他。這時候都會經過一番天人交戰，偶爾會發生我跟 joey 看法不一致的狀況，但主管給我們回饋很簡單，只要有我們有一個人覺得對方不適合，那這個人就是不適合。&lt;/p&gt;
&lt;p&gt;面試就會遇到各種類型的人，有內斂的、有熱情的、落落大方、沒自信的。有些人技術符合工作內容，但在對談中，覺得雙方的氣場不太對，畢竟未來會一起共事，能不能相處的來非常重要。&lt;/p&gt;
&lt;p&gt;我自己是抓技術佔 60%、個性、相處佔 40%。&lt;/p&gt;
&lt;p&gt;很幸運面試 6 個人後，找到了很適合的人選。&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;印象深刻，第一個面試者說 : 感謝我們，讓他學到很多東西，我們回說 : 面試對我們都像是互相學習，更感謝他來面試。&lt;/p&gt;
&lt;p&gt;這次的經驗，對我有滿大幫助。立場調換後，觀看履歷、或是臨場面試表達，都有不同感受。比起履歷上面列滿滿的技能，不如直接用這些技能實作;如果是列公司的產品，要註明分工實作項目。&lt;/p&gt;
&lt;p&gt;面試時候，介紹自己可以更有自信，常常聽到面試者說這很簡單，先挫自己銳氣了，不懂技術裝懂，會有壞印象，還有氣場適不適合這點也重要，佔了很大比例。難怪我之前某個面試答題很順利，但最後沒錄取...。&lt;/p&gt;
&lt;p&gt;最後，感謝公司給我面試的機會，獲益良多。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Google Search Console教學 提交Sitemap網址、SEO工具]]></title><description><![CDATA[gooogle search console 是非常實用、強大的工具，有辦法直接影響網站在 google 上的搜尋，例如說我要立刻取消自己網站上某頁不被 google 搜尋到，search console 移除網址可以處理。頁面剛建立好，要快速出現在 google…]]></description><link>https://ianccy.com/2018-09-searchconsle/</link><guid isPermaLink="false">https://ianccy.com/2018-09-searchconsle/</guid><pubDate>Mon, 24 Sep 2018 13:48:38 GMT</pubDate><content:encoded>&lt;p&gt;gooogle search console 是非常實用、強大的工具，有辦法&lt;code&gt;直接&lt;/code&gt;影響網站在 google 上的搜尋，例如說我要立刻取消自己網站上某頁不被 google 搜尋到，search console 移除網址可以處理。頁面剛建立好，要快速出現在 google 搜尋結果，就可以用 search console 提交網址索引，或是提交整個 sitemap。&lt;/p&gt;
&lt;p&gt;簡單講就是 google 搜尋相關的問題，都可以用 search console 解決。後面會從建立帳號開始，再來介紹一些重要的功能。&lt;/p&gt;
&lt;!--- ![searchconsole](../images/searchconsole.png &quot;searchconsole&quot;) ---&gt;
&lt;p&gt;官方教學 : &lt;a href=&quot;https://support.google.com/webmasters#topic=3309469&quot; title=&quot;google search console 說明&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google search console 說明&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;建立 search console 帳號教學&lt;/h2&gt;
&lt;p&gt;去年開始推出新版 search console，新、舊版功能還是有些差異，舊版有些功能，新版目前還沒有。新版搜尋資料儲存到 16 個月前，舊版只有三個月，我目前是兩版搭配使用，還是比較習慣舊版操作介面。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://search.google.com/search-console&quot; title=&quot;google search console 新版&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google search console 新版&lt;/a&gt;、&lt;a href=&quot;https://www.google.com/webmasters/tools/&quot; title=&quot;google search console 舊版&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google search console 舊版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;進入網站 : &lt;a href=&quot;https://search.google.com/search-console&quot; title=&quot;google search console&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google search console&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;點擊左上 =&gt; 點選新增資源
&lt;img src=&quot;../images/searcht1.png&quot; alt=&quot;search console teach&quot; title=&quot;searchconsole teach&quot;&gt;&lt;/li&gt;
&lt;li&gt;輸入網站網址
&lt;img src=&quot;../images/searcht2.png&quot; alt=&quot;search console teach&quot; title=&quot;searchconsole teach&quot;&gt;&lt;/li&gt;
&lt;li&gt;驗證所有權
選擇最適合自己的方法即可，這個 blog 是用 html meta tag。
&lt;img src=&quot;../images/searcht3.png&quot; alt=&quot;search console teach&quot; title=&quot;searchconsole teach&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;查看網站搜尋關鍵字&lt;/h2&gt;
&lt;p&gt;search console 最實用的功能，可以查看過去幾天 google 搜尋到網站的關鍵字，網站的曝光、點擊、點擊率。雖然點擊數不精確，但是可以經由這邊觀看網站整體搜尋表現，提醒一下數據會有三天延遲顯示。&lt;/p&gt;
&lt;p&gt;可以篩選網址字串比對、國家地區、瀏覽裝置、關鍵字，也可匯出報表，這功能對於執行 seo 人員會有很大幫助。&lt;/p&gt;
&lt;p&gt;優化 seo 流程大概會是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;網站建立 =&gt; 提交索引 =&gt; 觀察排名、點擊率變化 =&gt; 優化修改網頁內容、架構&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ps.google analytics 可以串接 search console，會顯示搜尋關鍵字在報表上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/searcht5.png&quot; alt=&quot;search console google 成效&quot; title=&quot;search console google 成效&quot;&gt;&lt;/p&gt;
&lt;h2&gt;提交網址&lt;/h2&gt;
&lt;p&gt;有兩種方法可以提交網址，一種是提交整個站的 sitemap，另一種則是在 google 模擬器提交單頁網址，提交後在網址列點擊索引單頁或頁面上所有連結。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;google 網址審查 (新版功能較多 能夠查看這個網址索引狀態、rwd，舊版多索引網頁內所有連結功能)
&lt;img src=&quot;../images/searcht6.png&quot; alt=&quot;search console google&quot; title=&quot;search console google&quot;&gt;&lt;/li&gt;
&lt;li&gt;sitemap 提交
&lt;img src=&quot;../images/searcht7.png&quot; alt=&quot;search console google sitemap&quot; title=&quot;search console google sitemap&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以前可以不需要透過 search console 就可以提交單頁網址，但現在 google 提供的頁面已經不存在了...，所以只能依靠 search console 或建立外部連結來索引(facebook、ptt)。&lt;/p&gt;
&lt;h2&gt;查看網站外部、內部連結&lt;/h2&gt;
&lt;p&gt;可以直接看外部連結來自哪個網站，還有網站的內部連結，可以搭配 google analytics 觀看 referral，對於 seo 優化有滿大的幫助。
&lt;img src=&quot;../images/searcht4.png&quot; alt=&quot;search console google 模擬器&quot; title=&quot;search console google 模擬器&quot;&gt;&lt;/p&gt;
&lt;h2&gt;移除網址&lt;/h2&gt;
&lt;p&gt;這個是 search console 上個人認為最獨特的功能，可以移除索引、暫時移除搜尋結果，如果網頁要在搜尋結果快速下架，就可以使用這個工具。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://support.google.com/webmasters/answer/1663419?hl=zh-Hant&quot; title=&quot;google search console 移除網址&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google search console 移除網址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/searcht9.png&quot; alt=&quot;search console google 移除網址&quot; title=&quot;search console google 移除網址&quot;&gt;&lt;/p&gt;
&lt;h2&gt;驗證結構化資料&lt;/h2&gt;
&lt;p&gt;結構化資料可以幫助 google 了解頁面架構，例如說使用評分的標記，搜尋結果就有可能會出現星星評等。search console 會顯示標記有無索引。&lt;/p&gt;
&lt;p&gt;新版還沒有這個無功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 blog post 標記
&lt;img src=&quot;../images/searcht8.png&quot; alt=&quot;search console google structured&quot; title=&quot;search console google structured&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;說明 : &lt;a href=&quot;https://developers.google.com/search/docs/guides/intro-structured-data&quot; title=&quot;google search structured data&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google search structured data&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其餘還有驗證網頁 amp、改善 html、指定網站搜尋地區、響應式裝置檢驗等等，剩下也有滿多好用的功能。這邊介紹的功能，雖然都簡單用幾個圖片文字帶過，但實際工作上幫助非常大，不論是行銷、工程師都用得到。&lt;/p&gt;
&lt;p&gt;最後感謝閱讀，希望這篇文章能對你有幫助。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[HTML postMessage iframe and open window 跨視窗傳訊用法]]></title><description><![CDATA[最近在公司專案學到了滿好用的功能 postMessage，當今天使用到跨視窗 iframe 或是 openWindow，原本 parent 頁面需要傳遞訊息給內頁 iframe 或是 tab 頁，就可以利用 postMessage 來傳遞資料。接下來會建立 demo…]]></description><link>https://ianccy.com/2018-09-postmessage/</link><guid isPermaLink="false">https://ianccy.com/2018-09-postmessage/</guid><pubDate>Sun, 23 Sep 2018 16:02:44 GMT</pubDate><content:encoded>&lt;p&gt;最近在公司專案學到了滿好用的功能 postMessage，當今天使用到跨視窗 iframe 或是 openWindow，原本 parent 頁面需要傳遞訊息給內頁 iframe 或是 tab 頁，就可以利用 postMessage 來傳遞資料。接下來會建立 demo 頁面，介紹一下 iframe 跟 window open 的使用方法。&lt;/p&gt;
&lt;!--- ![JavaScript](../images/post_message.png &quot;JavaScript&quot;) ---&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;window.postMessage() 方法被調用時，會在所有頁面腳本執行完畢之後
（e.g., 在該方法之後設置的事件、之前設置的timeout 事件,etc.）
向目標窗口派發一個  MessageEvent 消息。

該MessageEvent消息有四個屬性需要注意：
message 屬性表示該message 的類型；
data 屬性為 window.postMessage 的第一個參數；
origin 屬性表示調用 window.postMessage() 方法時調用頁面的當前狀態；
source 屬性記錄調用 window.postMessage() 方法的窗口信息。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;window postMessage 介紹&lt;/h2&gt;
&lt;p&gt;postMessage 的調用方式 =&gt; targetWindow.postMessage(message, targetOrigin, [transfer])，targetWindow 會是某個窗口，targetOrigin 則是指定可傳遞的端口網域，transfer 是一串和 message 同時傳遞的 Transferable 對象。&lt;/p&gt;
&lt;p&gt;targetWindow 可設定目標 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Window.open&lt;/li&gt;
&lt;li&gt;Window.opener&lt;/li&gt;
&lt;li&gt;HTMLIFrameElement.contentWindow (embedded iframe ),&lt;/li&gt;
&lt;li&gt;Window.parent ( parent window embedded iframe)&lt;/li&gt;
&lt;li&gt;Window.frames + an index value (named or numeric).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Syntax&quot; title=&quot;window postMessage MDN&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;window postMessage MDN &lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;window open demo page&lt;/h2&gt;
&lt;p&gt;首先要建立送出訊息跟接受訊息的頁面，送出訊息頁面主要做兩件事情，開啟視窗並指定為變數、向剛剛開啟視窗頁面送出訊息。javascript 沒有特別難度，所以就直接看我建立好的頁面，底下是處理的 html 還有 javascript。&lt;/p&gt;
&lt;p&gt;範例 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用步驟 先點選開啟視窗&lt;/li&gt;
&lt;li&gt;輸入隨意字串&lt;/li&gt;
&lt;li&gt;點選送出按鈕&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ps.分頁切換需要用瀏覽器 app safari、chrome&lt;/p&gt;
&lt;iframe src=&quot;https://work.ianccy.com/postmessage/send.html&quot; width=&quot;100%&quot; height=&quot;300px&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;Source : &lt;a href=&quot;https://work.ianccy.com/postmessage/send.html&quot; target=&quot;_blank&quot;&gt;Open Window Demo Page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;send.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;!DOCTYPE html&gt;
...
  &amp;#x3C;h1 class=&quot;cover-heading&quot;&gt;HTML send Post Message demo sample.&amp;#x3C;/h1&gt;
  &amp;#x3C;p class=&quot;lead&quot;&gt;
      &amp;#x3C;button id=&quot;openWindow&quot; type=&quot;button&quot; class=&quot;btn btn-info&quot;&gt;開啟視窗&amp;#x3C;/button&gt;
  &amp;#x3C;/p&gt;
  &amp;#x3C;div class=&quot;input-group&quot;&gt;
    &amp;#x3C;input type=&quot;text&quot; id=&quot;messageText&quot; class=&quot;form-control&quot; placeholder=&quot;輸入訊息&quot;&gt;
    &amp;#x3C;div class=&quot;input-group-append&quot;&gt;
      &amp;#x3C;button id=&quot;postWindow&quot; class=&quot;btn btn-info btn-outline-secondary&quot; type=&quot;button&quot;&gt;送出訊息&amp;#x3C;/button&gt;
    &amp;#x3C;/div&gt;
  &amp;#x3C;/div&gt;
...
  &amp;#x3C;script&gt;
    // 建立變數
    var createWindow;
    document.getElementById(&apos;openWindow&apos;).addEventListener(&apos;click&apos;,function(e){
    // 將變數 assign window open 物件
      createWindow = window.open(&quot;./receive.html&quot;);
    });
    document.getElementById(&apos;postWindow&apos;).addEventListener(&apos;click&apos;,function(e){
      sendMsg();
    });
    function sendMsg() {
      var message = document.getElementById(&quot;messageText&quot;).value;
      var domain = window.location.origin;
      // post message
      createWindow.postMessage(message, domain);
      // focus windowOpen
      createWindow.focus();
      document.getElementById(&quot;messageText&quot;).value = &apos;&apos;;
    }
  &amp;#x3C;/script&gt;
...
&amp;#x3C;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;recevie.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;!DOCTYPE html&gt;
...
    &amp;#x3C;p class=&quot;lead&quot;&gt;
      &amp;#x3C;h2 id=&quot;response&quot;&gt;&amp;#x3C;/h2&gt;
    &amp;#x3C;/p&gt;
...
    &amp;#x3C;script&gt;
      window.addEventListener(&quot;message&quot;, getMessage, false);
      function getMessage(e) {
        var content = &apos;&apos;;
        // e.data 接受傳遞訊息
        content += &quot;Get Message =&gt;&quot; + e.data + &apos;&amp;#x3C;br&gt;&apos;;
        // e.origin 接受訊息domain
        content += &quot;Url from &quot; + e.origin;
        document.getElementById(&quot;response&quot;).innerHTML = &quot;&amp;#x3C;p&gt;&quot; + content + &quot;&amp;#x3C;/p&gt;&quot;;
      };
    &amp;#x3C;/script&gt;
...
&amp;#x3C;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;iframe demo page&lt;/h2&gt;
&lt;p&gt;這個會比較特別，window open 是原本頁面傳給開啟頁面，iframe 則會使用 iframe embed 內部的網站傳遞資料給外部 parent，範例情境大概是修正 iframe 的高度，&lt;/p&gt;
&lt;p&gt;範例 : (白色區塊是使用 iframe)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;點選 iframe 內 伸縮高度按鈕&lt;/li&gt;
&lt;li&gt;點擊按鈕後，會變化 body 高度，並傳值到 parent window&lt;/li&gt;
&lt;li&gt;parent window 接受到值後，變化 iframe style height&lt;/li&gt;
&lt;/ul&gt;
&lt;iframe id=&quot;addIframe&quot; src=&quot;https://work.ianccy.com/postmessage/embed.html&quot; width=&quot;100%&quot; height=&quot;200px&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;Source : &lt;a href=&quot;https://work.ianccy.com/postmessage/iframe.html&quot; target=&quot;_blank&quot;&gt;Iframe Demo Page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;iframe.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;...
  &amp;#x3C;script&gt;
      // 接受傳遞訊息 變化iframe height
      window.addEventListener(&quot;message&quot;, getMessage, false);
      function getMessage(e) {
        if(e.data.event_id) {
          document.getElementById(&apos;addIframe&apos;).style.height = e.data.data + &apos;px&apos;;
        }
      };
  &amp;#x3C;/script&gt;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;embed.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;...
    &amp;#x3C;script&gt;
        document.getElementById(&apos;postWindow&apos;).addEventListener(&apos;click&apos;, function (e) {
          sendMsg();
        });
        function sendMsg() {
          var height = document.body.scrollHeight;
          // 向parent window 送出訊息
          window.parent.postMessage(
              {
                  event_id: &apos;my_cors_message&apos;,
                  data: height
              },
              &quot;*&quot; // or &quot;www.parentpage.com&quot;
          );
        }
    &amp;#x3C;/script&gt;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上就是簡單的 demo，還有更多延伸的運用，例如做出開視窗會員註冊，送出後傳遞資料回原本頁面渲染畫面。另外當你今天不得不用 iframe 的話，postMessage 會非常好用，賦予 iframe 更有彈性。另外提醒一下，實際運用要記得判斷 post Message 的網址，避免外部可能的攻擊。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Google Tag Manager tracking code 安裝追蹤碼]]></title><description><![CDATA[Tag manager 是一個強大的程式碼管理容器，一個代碼管理中心的概念，提醒一下它並不是取代 google analytics，而是涵蓋著處理各種代碼的設定，包括 google analytics 以及各種 tracking code、或是 html…]]></description><link>https://ianccy.com/2018-08-tagmanager/</link><guid isPermaLink="false">https://ianccy.com/2018-08-tagmanager/</guid><pubDate>Sun, 26 Aug 2018 14:01:35 GMT</pubDate><content:encoded>&lt;p&gt;Tag manager 是一個強大的程式碼管理容器，一個代碼管理中心的概念，提醒一下它並不是取代 google analytics，而是涵蓋著處理各種代碼的設定，包括 google analytics 以及各種 tracking code、或是 html 等等。功能非常的強大，因此寫錯 script 或 css 就可能讓你網站出問題。&lt;/p&gt;
&lt;!--- ![google tagmanager](../images/tagmanager.png &quot;google tagmanager&quot;) ---&gt;
&lt;p&gt;以往的埋設追蹤碼都是增加一段 script，但是當你有用了 tag manager，這段 script 可以轉由 tag manager 幫你引入，由 tag manager 來控管 tracking code，假設你是行銷人員，就不用在請程式人員幫你埋碼了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 傳統 google analytics tacking code
&amp;#x3C;script&gt;(function(i,s,o,g,r,a,m){i[&apos;GoogleAnalyticsObject&apos;]=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,&apos;script&apos;,&apos;https://www.google-analytics.com/analytics.js&apos;,&apos;ga&apos;);
ga(&apos;create&apos;,&apos;UA-xxxxxxxxxx-1&apos;,&apos;auto&apos;);ga(&apos;send&apos;,&apos;pageview&apos;);&amp;#x3C;/script&gt;

// 以上這段code會變成你在tag manager 選擇google analytics，貼上UA-xxxxxxxxxxx-1。
// 如果沒有支援就改成用html方式引入code
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;建立帳戶 埋設 Tag Manager traking code&lt;/h2&gt;
&lt;p&gt;進入 &lt;a href=&quot;https://tagmanager.google.com/&quot; title=&quot;tag manager&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google tag manager&lt;/a&gt; 網站註冊登入，點選建立帳戶，接下來會彈出一段程式碼。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;#x3C;!DOCTYPE html&gt;

...
// 將這段script 放到網站的&amp;#x3C;head&gt;前面
&amp;#x3C;!-- Google Tag Manager --&gt;
&amp;#x3C;script&gt;(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({&apos;gtm.start&apos;:
new Date().getTime(),event:&apos;gtm.js&apos;});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!=&apos;dataLayer&apos;?&apos;&amp;#x26;l=&apos;+l:&apos;&apos;;j.async=true;j.src=
&apos;https://www.googletagmanager.com/gtm.js?id=&apos;+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,&apos;script&apos;,&apos;dataLayer&apos;,&apos;GTM-你的追蹤碼&apos;);&amp;#x3C;/script&gt;
&amp;#x3C;!-- End Google Tag Manager --&gt;
&amp;#x3C;head&gt;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;恭喜你，基本上後面動作你就不需要動到 html 了。除非要做 data layer 的設定。
&lt;a href=&quot;https://developers.google.com/tag-manager/devguide&quot; title=&quot;tag manager data layer&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;tag manager data layer 說明文件&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tag manager 設定 google analytics tracking code&lt;/h2&gt;
&lt;p&gt;tag manager 有整合進 google analytics 的設定，&lt;/p&gt;
&lt;h4&gt;進入代碼區塊 點擊新增&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagadd.png&quot; alt=&quot;google tagmanager add&quot; title=&quot;google tagmanager add&quot;&gt;&lt;/p&gt;
&lt;h4&gt;選擇 google analytics&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagsetga.png&quot; alt=&quot;google tagmanager tag set ga&quot; title=&quot;google tagmanager tag set ga&quot;&gt;&lt;/p&gt;
&lt;h4&gt;點選上半部變數區塊 =&gt; 加入你 google analytics 的追蹤碼 UA-xxxxxxxx-x&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagvar.png&quot; alt=&quot;google tagmanager tag tag var&quot; title=&quot;google tagmanager tag var&quot;&gt;&lt;/p&gt;
&lt;h4&gt;點選下半部觸發區塊 =&gt; 選擇 All page view&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagtrigger.png&quot; alt=&quot;google tagmanager tag trigger&quot; title=&quot;google tagmanager tag trigger&quot;&gt;&lt;/p&gt;
&lt;h4&gt;點擊右上角提交&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagsubmit.png&quot; alt=&quot;google tagmanager tag submit&quot; title=&quot;google tagmanager tag submit&quot;&gt;&lt;/p&gt;
&lt;p&gt;記住一個重點，tag manager 每個改動都需要你點擊提交，才算是真正送出修改，如果要先觀看有沒有問題，可以點擊預覽，進入有埋設 tag manager 的網站，下方會跳出介面，會列出有在執行項目。&lt;/p&gt;
&lt;p&gt;以上就是成功用 tag manager 埋好了 google analytics，那接下來開始介紹一個強大的功能，直接靠 tag manager 建立事件。我要追蹤的是 click target=&quot;_blank&quot;的連結(因為有處理過會把外部連結設為開新視窗)。&lt;/p&gt;
&lt;h4&gt;首先先點擊左邊選單的 變數，讓我們後面可以取用點擊連結的 URL&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagopenvar.png&quot; alt=&quot;google tagmanager tag openvar&quot; title=&quot;google tagmanager openvar&quot;&gt;&lt;/p&gt;
&lt;h4&gt;點擊左邊選單的 觸發條件 =&gt; 新增 =&gt; 觸發條件設定 =&gt; 點選連結&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagtrigerset.png&quot; alt=&quot;google tagmanager tag trigerset&quot; title=&quot;google tagmanager trigerset&quot;&gt;&lt;/p&gt;
&lt;h4&gt;選擇內建變數&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagdefault.png&quot; alt=&quot;google tagmanager tag default&quot; title=&quot;google tagmanager tag default&quot;&gt;&lt;/p&gt;
&lt;h4&gt;選擇 click target =&gt; 儲存&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagtarget.png&quot; alt=&quot;google tagmanager tag target&quot; title=&quot;google tagmanager tag target&quot;&gt;&lt;/p&gt;
&lt;h4&gt;點擊左邊選單的 代碼 =&gt; 選擇 google analytics =&gt; 點擊上半部區塊[代碼設定]&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagevent.png&quot; alt=&quot;google tagmanager event setting&quot; title=&quot;google tagmanager event setting&quot;&gt;&lt;/p&gt;
&lt;h4&gt;點擊下半部區塊[代碼設定] =&gt; 選擇剛剛設定好的觸發條件&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;../images/tagevent2.png&quot; alt=&quot;google tagmanager event setting 2&quot; title=&quot;google tagmanager event setting 2&quot;&gt;&lt;/p&gt;
&lt;h4&gt;點擊提交&lt;/h4&gt;
&lt;h4&gt;點擊預覽模式 =&gt; 進入網頁測試&lt;/h4&gt;
&lt;p&gt;首先點擊網頁上的開新視窗連結，在觀察下方的介面有沒有 fired on this page
&lt;img src=&quot;../images/tagtest.png&quot; alt=&quot;google tagmanager tag test&quot; title=&quot;google tagmanager tag test&quot;&gt;&lt;/p&gt;
&lt;p&gt;woooooooo，這樣就完成了一個 google analytics 的事件追蹤設定。&lt;/p&gt;
&lt;h2&gt;Tag Manager 結論重點&lt;/h2&gt;
&lt;p&gt;tag manager 核心邏輯大概是 變數、觸發條件、代碼。變數可以把它看作設定的某個數值，觸發條件則是觸發的原因，代碼則是整合觸發條件還有變數。每個代碼都必須要有觸發條件，例如 google analytic 就是在網頁瀏覽觸發，要讓程式碼知道你這段代碼要在什麼時候執行。至於變數則是沒有一定要加，視狀況而定。&lt;/p&gt;
&lt;p&gt;另外介紹目前公司針對不同客戶的客製化代碼，都是在 tag manager 設定的。例如某個客戶要客製化的 html，就用代碼判斷這個客戶的網址，利用代碼引入 javaScipt，動態的載入 html。&lt;/p&gt;
&lt;p&gt;最後想說 tag manager 對於行銷人來說，似乎有點複雜，以前我擔任行銷時，其實也不太會用，用得好的話需要有 html、JavaScript 邏輯，有些公司甚至是前端工程師專門維運 tag manager 的，所以如果你覺得很難理解或使用應該是滿正常的，但如果你會用的話，恭喜你，tag manager 會是非常厲害的求職技能。&lt;/p&gt;
&lt;p&gt;以上是 tag manager 的介紹，關於設定流程有問題歡迎留言。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JavaScript Prototype 繼承、原型鏈 Prototype chain]]></title><description><![CDATA[因緣際會之下，最近剛經歷了招募前端，為了準備面試題目，所以整理了一些關於 JavaScript 的 觀念，其中比較抽象的題目應該是 ProtoType、Event loop、Bubbles Capture，這邊就先來介紹一下其中最抽象也比較難理解的 JavaScript…]]></description><link>https://ianccy.com/2018-08-jsproto/</link><guid isPermaLink="false">https://ianccy.com/2018-08-jsproto/</guid><pubDate>Sat, 25 Aug 2018 15:06:44 GMT</pubDate><content:encoded>&lt;p&gt;因緣際會之下，最近剛經歷了招募前端，為了準備面試題目，所以整理了一些關於 JavaScript 的 觀念，其中比較抽象的題目應該是 ProtoType、Event loop、Bubbles Capture，這邊就先來介紹一下其中最抽象也比較難理解的 JavaScript ProtoType。&lt;/p&gt;
&lt;!--- ![JavaScript](../images/JavaScript-logo.png &quot;JavaScript&quot;) ---&gt;
&lt;h2&gt;JavaScript ProtoType 介紹&lt;/h2&gt;
&lt;p&gt;JavaScript 沒有類的特性(class-based)，跟 Java 不一樣，雖然說 ES6 有 class 但它只是語法糖，每個 JavaScript 都具備有 prototype，只是分為公開、私有差異，而 JavaScript 就用 prototype 來處理繼承(prototype-based)，特性是延展性高。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 使用解構復值作為參數  並且預設沒傳值預設給予字串
function Family({ m = &apos;no person&apos;, w = &apos;no person&apos;, c = &apos;no child&apos; } = {}) {
    this.father = m;
    this.mother = w;
    this.chidren = c;
}

var data = {
    m: &apos;John Paul&apos;,
    w: &apos;Mary Alice&apos;,
    c: &apos;Chris Paul&apos;
};

// 繼承 Family
var paul = new Family(data);
// 等同於
// var paul[[Prototype]] = Family.prototype;
// Family.call(paul);
// paul 的 __proto__ 等於 Family();

console.log(paul);
// chidren: &quot;Chris Paul&quot;
// father: &quot;John Paul&quot;
// mother: &quot;Mary Alice&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/chu1228/pen/KxVoVz?editors=0001&quot; title=&quot;example codepen&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;example codepen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;console.log(paul) 截圖
&lt;img src=&quot;../images/family_proto.png&quot; alt=&quot;JavaScript proto&quot; title=&quot;family proto.proto&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下來擴充一下 Family，增加一個 function。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 增加一個 hi function
Family.prototype.hi = function() {
    console.log(`Family&apos;s child is ${this.chidren}. Family&apos;s father is ${this.father}`);
};

// this 指向調用時的物件 paul
paul.hi();
// I am Chris Paul. My father is John Paul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/chu1228/pen/rZxdxm?editors=0011&quot; title=&quot;example codepen&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;example codepen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JavaScript ProtoType 用來建立 function 也較不耗費記憶體，當我今天有多個的不同物件要產生，就不需要實際複製產生，而是轉向繼承核心的 function 使用 prototype，這特色在 es6 class 撰寫時會滿明顯感受。&lt;/p&gt;
&lt;h2&gt;JavaScript ProtoType 繼承鍊&lt;/h2&gt;
&lt;p&gt;每個物件都有一個連著其他原型（prototype）的私有屬性（private property）物件。原型物件也有著自己的原型，於是原型物件就這樣鏈結，直到撞見 null 為止。看範例可能會比較好理解，&lt;/p&gt;
&lt;p&gt;另外會發現到物件第一層會是 &lt;code&gt;__proto__&lt;/code&gt; (隱式原型)，主要是瀏覽器會透過隱式原型指向該物件的 prototype。&lt;/p&gt;
&lt;p&gt;ps. &lt;code&gt;__proto__&lt;/code&gt;稱為隱式原型) 與 prototype 顯式原型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/chain.png&quot; alt=&quot;JavaScript protochain&quot; title=&quot;family protochain&quot;&gt;&lt;/p&gt;
&lt;p&gt;簡單的範例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var Person = function() {
    this.name = `chu`;
};

var Age = function() {
    this.age = 18;
};

var Gender = function() {
    this.gender = &apos;male&apos;;
};

Age.prototype = new Person();

Gender.prototype = new Age();

var ian = new Gender();
console.log(ian.name, ian.age, ian.gender); // chu 18 male
// 會先查找 ian 的 name ，找不到找該物件的原型prototype，
// 在找不到會在往上層去找 prototype.name 就會發現找到了停止向上查找
// 直到找不到 prototype ，__proto__為null時停止
// 整個流程稱之為 prototype chain
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/chu1228/pen/LJGdGm?editors=0011&quot; title=&quot;example codepen&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;example codepen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/protochain.png&quot; alt=&quot;JavaScript protochain&quot; title=&quot;family protochain&quot;&gt;&lt;/p&gt;
&lt;p&gt;突然提到 prototype，主要是在 React 開發時，時常用到 ES6 class，才知道 class 背後處理了非常關於 prototype 繼承的細節。才知道 prototype 的概念形影不離。&lt;/p&gt;
&lt;p&gt;例如一個簡單的 class 如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Person {
    constructor(name) {
        this.name = name;
    }
    hello() {
        console.log(`hello,i am ${this.name}`);
    }
}
class Age extends Person {
    // constructor會在建立時倍呼叫
    // 接受傳遞參數
    constructor(name, age) {
        // 繼承父層 prototype.name
        super(name);
        this.age = age;
    }
    intro() {
        console.log(`i am ${this.name}, and ${this.age} years old,`);
    }
}

const ian = new Age(`chu`, 18);
ian.intro(); // i am chu, and 18 years old,
ian.hello(); // hello,i am chu
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/chu1228/pen/dqGZxB?editors=0011&quot; title=&quot;example codepen&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;example codepen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你有用過 react 的 class xxx extends React.component，就會發現到其中 super(props)，就在講繼承 React.component 的 props。es6 class 就先不在這邊講述了，&lt;/p&gt;
&lt;p&gt;以上就是 prototype 的簡單介紹，有錯誤或是問題歡迎留言。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Google Analytics 工作階段介紹、定義]]></title><description><![CDATA[google analytics…]]></description><link>https://ianccy.com/2018-07-gasession/</link><guid isPermaLink="false">https://ianccy.com/2018-07-gasession/</guid><pubDate>Mon, 30 Jul 2018 21:26:34 GMT</pubDate><content:encoded>&lt;p&gt;google analytics 網頁的左邊欄位，點開目標對象、客戶開發就會發現滿滿的工作階段，如果不懂工作階段的定義，那你裡面的相關數據可能會看不太懂，很久以前我有看過舊版的官方介紹，看完其實一知半解，一直以為工作階段會近似於入站或是使用者，然後有時候看數據就用猜測的。例如說單次工作階段頁數，雖然知道是瀏覽頁數除以工作階段，但你在交叉比對其他數據的時候，就比較難分析出真正原因。&lt;/p&gt;
&lt;p&gt;官方文件: &lt;a href=&quot;https://support.google.com/analytics/answer/2731565&quot; title=&quot;Google Analytics 工作階段&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Google Analytics 工作階段&lt;/a&gt;&lt;/p&gt;
&lt;!--- ![google analytics](../images/google_analytics.png &quot;google analytics&quot;) ---&gt;
&lt;h2&gt;工作階段定義&lt;/h2&gt;
&lt;p&gt;官方定義是『 工作階段代表指定期間內在網站上發生的多項使用者互動；舉例來說，一個工作階段可能包含多個網頁瀏覽、事件、社交互動和電子商務交易』，簡單講就是當使用者進入網站，那一刻起就算一個工作階段，沒有所謂使用者進來一跳出，沒有計算到工作階段，他跟網頁停留時間邏輯不一樣，不是依靠節點相減計算的。&lt;/p&gt;
&lt;h2&gt;一般正常流程&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;使用者輸入 https://ianccy.com =&gt;

載入網頁 (計算為一個工作階段) =&gt;

點擊連結 進入一篇文章 (總共只算一個工作階段) =&gt;

wow 文章太長拉 離開

整個流程的工作階段 = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在複雜一點解釋就是使用者在你網頁中同一頁停留 30 分鐘 (ga 預設 30 分鐘)以內，都算是一個工作階段，如果超過 30 分鐘，那會再加一個工作階段。&lt;/p&gt;
&lt;h2&gt;使用者停留過久流程&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;使用者輸入 https://tw.yahoo.com/ =&gt;

進入首頁 (計算為一個工作階段) 時間 7/30 20:00 =&gt;

點擊連結 進入新聞 時間 7/30 20:05 =&gt;

(開始發呆滑手機) =&gt;

回來繼續看新聞 (超過30分鐘 加一個工作階段) 時間 7/30 20:40 =&gt;

再點一下其他篇新聞 時間 7/30 20:45 =&gt;

看完 離開

整個流程的工作階段 = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外還有一個特例就是每過一天，都會重置工作階段的計算時間，假設我是 23:55:45 進入網站，會在 23:59:59 被停掉這次工作階段，然後在 00:00 重新計算一個工作階段。&lt;/p&gt;
&lt;p&gt;記得舊版的 ga 介紹滿容易誤導的，我以前一直把使用者當作工作階段看，然後過一陣子又把他當入站看，因為網頁總入站有時候都會等於總工作階段數 (正確來說工作階段可能會大於入站數)，我是學習到後端 session 觀念才恍然大悟。&lt;/p&gt;
&lt;h2&gt;工作階段 瀏覽量關係&lt;/h2&gt;
&lt;p&gt;記得以前被主管問過，網站 kpi 要用工作階段、還是網頁瀏覽量? 如果真的一定要分，我是把轉換型網頁分為工作階段，把工作階段視為可能發生轉換的機會，增大使用者，轉換機會就越大。廣告類用網頁瀏覽頁看，而廣告類型就看做越多瀏覽量，廣告曝光量就越大，收入也越高。雖然我自己是覺得兩個應該都要看拉，交叉比對才能更了解到底使用者都怎麼用的。&lt;/p&gt;
&lt;p&gt;簡單來說就是&lt;code&gt;分析網頁用瀏覽量計算，看使用者就用工作階段&lt;/code&gt;。因為工作階段是以使用者角度在看的，所以今天跟使用者的分類有關，都會是用工作階段計算的，例如年齡啊，客戶來源啊，因為你要分析的是使用者。&lt;/p&gt;
&lt;p&gt;但網頁內容是以網頁為角度看數據，計算準則變為不重複瀏覽量。另外還有 ga 的所有數據都是計算出來的，所以數字怪異，應該先確認好定義，在依照加減乘除的的相關數據，去找出不同原因。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Life Cycle 生命週期更新版，父子元件執行順序]]></title><description><![CDATA[如果在開發上是用 React，最常用到就是一定是處理 state、props，而其中最重要的莫過於是生命週期 lifeCycle，可以在每個元件渲染的過程，加入需要的處理，例如載入完元件後非同步抓取資料，更新 props 觸發處理事件等等。接下來就來介紹 life Cycle…]]></description><link>https://ianccy.com/2018-07-reactlife/</link><guid isPermaLink="false">https://ianccy.com/2018-07-reactlife/</guid><pubDate>Fri, 27 Jul 2018 23:59:38 GMT</pubDate><content:encoded>&lt;p&gt;如果在開發上是用 React，最常用到就是一定是處理 state、props，而其中最重要的莫過於是生命週期 lifeCycle，可以在每個元件渲染的過程，加入需要的處理，例如載入完元件後非同步抓取資料，更新 props 觸發處理事件等等。接下來就來介紹 life Cycle，順便了解新版本多的功能，還有未來會移除的功能。&lt;/p&gt;
&lt;!--- ![react lifecycle](../images/react.png &quot;react lifecycle&quot;) ---&gt;
&lt;h2&gt;React Life Cycle&lt;/h2&gt;
&lt;p&gt;大致上可分類為 Mounting 增加、Updating 更新、Unmounting 移除增加。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/react-life.png&quot; alt=&quot;react lifecycle&quot; title=&quot;react lifecycle&quot;&gt;
大推 Dan Abramov 的圖表， &lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot; title=&quot;React Life Cycle&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;網站版 React Life Cycle 網友製&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PS.React 官方已經在 2018/03/27 宣告 不推薦使用:
componentWillMount、componentWillReceiveProps、componentWillUpdate 並且 react 16.3 版本以後這些 method 會加上前綴 UNSAFE_，17 版本會丟棄。提醒使用的時候要特別小心。&lt;/p&gt;
&lt;p&gt;另外在看下面的時候可以搭配使用 &lt;a href=&quot;https://codesandbox.io/s/xp7lk14x4w&quot; title=&quot;React Life Cycle&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;react life Cycle sample&lt;/a&gt;，點開 console.log 查看執行順序，裡面操作主要兩個，一個是父元件更新傳遞的 props，還有元件自己 setState。&lt;/p&gt;
&lt;h2&gt;Mounting&lt;/h2&gt;
&lt;p&gt;Mounting 會在元件被建立時被執行。&lt;/p&gt;
&lt;h4&gt;constructor() :&lt;/h4&gt;
&lt;p&gt;這是 es6 的 class 語法糖，可以說是建構並初始化物件，這邊會繼承 React.Component，假設你元件要使用到 props，就必須這樣寫 super(props)來繼承父類別。這階段簡單說就是開始建立這個物件。如果你沒有要定義 state、或是在這邊綁定 method (另可以選用 arrow function 綁定 method)，就不需要用到 constructor。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// get parents props
constructor(props) {
  super(props);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;componentWillMount() -&gt; 17 版將丟棄 :&lt;/h4&gt;
&lt;p&gt;緊接在 constructor 後執行 componentWillMount，提醒只會在初始執行一次，移除後重新建立元件也不會在執行 componentWillMount。另外是唯一會在 server side render 時執行的 life Cycle method，關於 WillMount 最多的討論就是，在這邊擺放 fetch api 是否正確。&lt;/p&gt;
&lt;p&gt;官方表示，因為 server side 會執行一次，client side 也會再多執行一次，造成重複要資料動作。另外在這邊做 async api 處理，是無法暫停 render 動作，你一樣要等 render 完成後，你還是必須等待類似 loading 空畫面跑出來，才能在更新畫面，所以會更推薦在 componentDidMount 做 fetch api。&lt;/p&gt;
&lt;h4&gt;get­Derived­State­From­Props(nextProps, prevState) -&gt; 新增&lt;/h4&gt;
&lt;p&gt;get­Derived­State­From­Props 主要是對比到 componentWillReceiveProps，get­Derived­State­From­Props 帶有兩個參數 nextProps, prevState，更新後的 props，先前的 state，這個 method 會在初始 render 調用，還有父元件重新 render，也會調用到。&lt;/p&gt;
&lt;p&gt;還有當你使用了 get­Derived­State­From­Props，要更新 state 就需要回傳物件，如果不更新就必須回傳 null。&lt;/p&gt;
&lt;p&gt;PS.當你使用 get­Derived­State­From­Props，也同時使用 componentWillMount，WillMount 會不執行，並且 console 會傳出警告，另外就算改用 UNSAFE_componentWillMount 也不會執行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class ExampleComponent extends React.Component {
  // Initialize state in constructor,
  state = {
    isScrollingDown: false,
    lastRow: null,
  };
  // means you can not use &quot;this.setState&quot;
  // return will update state
  static getDerivedStateFromProps(props, state) {
    if (props.currentRow !== state.lastRow) {
      return {
        isScrollingDown: props.currentRow &gt; state.lastRow,
        lastRow: props.currentRow,
      };
    }
    // Return null to indicate no change to state.
    return null;
  }
}
by officical react
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;官方介紹使用情境: &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props&quot; title=&quot;get­Derived­State­From­Props example&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;get­Derived­State­From­Props example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;移動到 Update 部分: &lt;a href=&quot;#static-getDerivedStateFromProps-nextProps-prevState-gt-%E6%96%B0%E5%A2%9E&quot; title=&quot;get­Derived­State­From­Prop&quot;&gt;get­Derived­State­From­Prop&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;render()&lt;/h4&gt;
&lt;p&gt;執行 setState、更新父元件傳遞的 props，都會執行 render()，假設 shouldComponentUpdate()回傳 false，則是阻止 render 執行。使用 render 必須回傳 react element(JSX、createClass、react 元件)、或 Fragment、Portals(可以綁定 render 到其他 Dom root)、如果不回傳內容則回傳 boolean、或是 null。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://reactjs.org/docs/portals.html&quot; title=&quot;Portals&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Portals&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然後使用 render 盡量保持 pure，例如盡量少在這邊額外處理 props 以及 state，在外面處理保持 render 內乾淨。(這點我也沒做到...)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class App extends React.Component {
  filterProps = () =&gt; {
    const { personList } = this.props
    return (
      {personList.filter(elem =&gt; elem.age &gt; 20)}
    )
  }
  render() {
    return (
      &amp;#x3C;div&gt;
        older than 20 years:
        {this.filterProps()}
      &amp;#x3C;/div&gt;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;componentDidMount()&lt;/h4&gt;
&lt;p&gt;componentDidMount 會在 render 執行完成後調用。這應該是最多人用到的生命週期，舉凡綁定 DOM 事件，執行 ajax，多半會在這邊使用。提醒在這邊使用 setState 會迫使 render 執行兩次，盡量在 constructor 內設定好初始 state，避免過多 render 執行。&lt;/p&gt;
&lt;p&gt;另外提醒在這邊綁定 DOM eventListener，記得在 willUnMount 取消綁定 EventListener，如果重新 render 元件會再次執行 DidMount，造成過多的綁定事件。&lt;/p&gt;
&lt;br/&gt;
## Updating
主要是在父元件更新傳遞的props，或是元件中使用到setState，會開始整個Update的生命週期。另外setState({xxxx},callback)，則是會在整個週期執行完成才會執行callback。
&lt;h4&gt;componentWillReceiveProps(nextProps) -&gt; 17 版將丟棄&lt;/h4&gt;
&lt;p&gt;componentWillReceiveProps(nextProps)，會回傳更新過的 props，並且可以使用 setState 來更新 state，提醒在這邊使用 setstate，並不會驅使重跑 componentWillReceiveProps，因為 ReceiveProps 只會在更新傳遞的 props 時被調用。&lt;/p&gt;
&lt;p&gt;react 官方是創建 get­Derived­State­From­Prop 來替代掉 WillReceiveProps，主要明顯差異在於 get­Derived­State­From­Prop 必須使用 static，且會在 Mounting 階段執行， 但是會自動傳遞更新 state，而 componentWillReceiveProps 則是純粹執行， 不依靠 return 更新。&lt;/p&gt;
&lt;h4&gt;static getDerivedStateFromProps(nextProps, prevState) -&gt; 新增&lt;/h4&gt;
&lt;p&gt;Updating 階段中，getDerivedStateFromProps 則是在父元件更新傳遞的 props 時調用，提醒一下這時候 this.props state 還會是未更新的。&lt;/p&gt;
&lt;p&gt;移動到 Mounting 部分: &lt;a href=&quot;#get%C2%ADDerived%C2%ADState%C2%ADFrom%C2%ADProps-nextProps-prevState-gt-%E6%96%B0%E5%A2%9E&quot; title=&quot;get­Derived­State­From­Prop&quot;&gt;get­Derived­State­From­Prop&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;shouldComponentUpdate(nextProps, nextState)：&lt;/h4&gt;
&lt;p&gt;執行 receive props 後調用，這時候 this.props state 還會是未更新的。主要是判斷元件是否要往下繼續執行 willUpdate、render、componentDidUpdate，如果回傳 false，則會中斷整個更新循環，回傳 true 則是繼續往下執行，默認值為 true。&lt;/p&gt;
&lt;p&gt;一般會使用 shouldComponentUpdate 來優化效能，避免執行沒必要的 render。&lt;/p&gt;
&lt;h4&gt;componentWillUpdate（nextProps, nextState) -&gt; 17 版將丟棄&lt;/h4&gt;
&lt;p&gt;Update 到 render 前最後一個， 提醒在這邊使用 setState 的話，會導致重跑回 update 的生命週期，然後在跑到 componentWillUpdate，若沒有設定好判斷，就會再 setState，再重跑回一遍，變成反覆 infinite 執行。&lt;/p&gt;
&lt;h3&gt;render&lt;/h3&gt;
&lt;p&gt;Update 階段中開始處理 react 的畫面架構。提醒在這邊 setState 也同樣會重跑 Update，也同樣不建議在這邊執行 setState，容易產生無限迴圈。&lt;/p&gt;
&lt;p&gt;其餘跟 Mounting 階段一樣，回傳 react element，或是 react 相關的物件。&lt;/p&gt;
&lt;h3&gt;getSnapshotBeforeUpdate(prevProps, prevState) -&gt; 新增&lt;/h3&gt;
&lt;p&gt;能夠抓取 render 到執行渲染畫面更新前，所保持的畫面狀態，然後再傳第一個新值給 componentDidUpdate 當參數使用。&lt;/p&gt;
&lt;h4&gt;componentDidUpdate(prevProps, prevState, snapshot)&lt;/h4&gt;
&lt;p&gt;Updating 階段最後一個執行，在畫面渲染更新後調用，新版本的還多加 getSnapshotBeforeUpdate 傳遞的參數。&lt;/p&gt;
&lt;p&gt;在這邊可以處理 call api 動作，或是 setState，促使重新更新，但提醒記得要判斷執行時機，否則一樣會進入無限迴圈。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;componentDidUpdate(prevProps) {
    if (this.props.name !== prevProps.name) {
        updateUser(this.props.id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
## Unmounting
移除的時候會執行這個生命週期
&lt;h4&gt;componentWillUnmount()&lt;/h4&gt;
&lt;p&gt;元件要被移除的時候會執行，可以做清除綁定 eventlistener，或是清除 cookie、local storage 等等，提醒在這邊 setState 是不會重新執行 render。&lt;/p&gt;
&lt;p&gt;以上就是關於 react 新版的生命週期，看過一遍後更能理解，在哪個階段做什麼處理會更適合。&lt;/p&gt;
&lt;h2&gt;元件渲染順序&lt;/h2&gt;
&lt;p&gt;大型開發滿常遇到這個問題，子元件先執行 render 還是父元件先，還有 lifeCycle 在父子元件的調用順序。稍微試跑了一下流程。
請查看 console &lt;a href=&quot;https://codesandbox.io/s/5kpvvkqx7k&quot; title=&quot;react life Cycle parents child order&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;react life Cycle parents child order&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mounting: 簡單講就是父元件先執行到 render 後，再來開始執行子元件的 Mounting 生命週期，最後執行完子元件的 componentDidMount 後，再回頭執行父元件的 componentDidMount。&lt;/li&gt;
&lt;li&gt;Updating: 父元件執行到 render 後，換子元件執行直到 getSnapshotBeforeUpdate()，會再回父元件執行 getSnapshotBeforeUpdate()，然後再執行子元件的 componentDidUpdate，再回父元件執行 componentDidUpdate。&lt;/li&gt;
&lt;li&gt;UnMounting: 父元件先執行 componentWillUnmount，再來是子元件執行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上就是關於 react 的新版生命週期，還有父子元件執行的順序。實際研究才發現各階段德每個 method 有許多細節，例如說 mounting 階段，componentWillMount 執行 fetch api，因為他只會在第一次 Mounting 被調用的特性，如果是抓取後續不會更新的資料，其實也是一種選擇，但今天如果你後面還可能會再次 call api，或許 componentDidMount 會更適合使用。&lt;/p&gt;
&lt;p&gt;--以上如果有錯誤，歡迎留言。感謝!--&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Google analytics UTM設定參數，追蹤facebook廣告、簡訊、EDM]]></title><description><![CDATA[如果你有在操作 facebook 廣告、電子報，簡訊、或社群曝光分享 ，你可能會使用某些短網址服務，來分析點擊率、開信率，但是要從 google analytics 查看每個管道的跳出率、轉換率、停留時間等等，可能技術上會有些複雜。就只能透過網址下參數一些參數來讓 ga…]]></description><link>https://ianccy.com/2018-06-gautm/</link><guid isPermaLink="false">https://ianccy.com/2018-06-gautm/</guid><pubDate>Sat, 23 Jun 2018 15:13:59 GMT</pubDate><content:encoded>&lt;p&gt;如果你有在操作 facebook 廣告、電子報，簡訊、或社群曝光分享 ，你可能會使用某些短網址服務，來分析點擊率、開信率，但是要從 google analytics 查看每個管道的跳出率、轉換率、停留時間等等，可能技術上會有些複雜。就只能透過網址下參數一些參數來讓 ga 分開網址，例如(www.ianccy.com/?from=fbads&amp;#x26;type=video)，但這可能會造成網址參數過多，報表的數據難以整理、分析。這時候使用 utm，就能解決上面全部問題。&lt;/p&gt;
&lt;!--- ![google ga_utm](../images/ga_utm.png &quot;google ga_utm&quot;) ---&gt;
&lt;h2&gt;google analytics utm 使用介紹&lt;/h2&gt;
&lt;p&gt;utm 能精準追蹤各管道追蹤數據，這是 google 官方提供給 ga 搭配使用的功能，使用方法非常簡單，就只要在網址加上 google analytics 看得懂的參數即可。另外 ga 在報表上會自動去除這些 utm 參數，所以你不用擔心報表網址會有一堆參數。&lt;/p&gt;
&lt;p&gt;utm 參數介紹:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;utm_source (來源)：用來辨識為您的資源帶來流量的廣告客戶、網站和出版物等等，例如 Google、newsletter4、billboard。&lt;/li&gt;
&lt;li&gt;utm_medium (媒介)：代表廣告或行銷媒介，例如單次點擊出價、橫幅廣告或電子報。&lt;/li&gt;
&lt;li&gt;utm_campaign (廣告活動)：產品的個別廣告活動名稱、廣告標語和促銷代碼等。&lt;/li&gt;
&lt;li&gt;utm&lt;em&gt;term (關鍵字)：辨識付費搜尋關鍵字。如果您打算手動為付費關鍵字廣告活動添加代碼，建議您一併使用 utm&lt;/em&gt;term 來指定關鍵字。&lt;/li&gt;
&lt;li&gt;utm&lt;em&gt;content (廣告內容)：用來區分同一個廣告中的相似內容或連結。舉例來說，要是同一封電子郵件中包含兩個行動號召文字連結，只要使用 utm&lt;/em&gt;content 並為這兩個連結分別設定不同的值，您就能判斷哪個版本的行動號召文字效果較好。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://support.google.com/analytics/answer/1033863&quot; title=&quot;google官方說明utm&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google 官方 utm 說明 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假設今天是與網紅叫做 mypost 合作(隨便取)，讓她在臉書推廣，那就在 utm&lt;em&gt;source 使用 facebook，因為是使用貼文，所以 utm&lt;/em&gt;medium 使用 post，utm_campaign 就使用標籤名稱 mypost，再來使用 google 的 utm 產生器，輸入我們分類好的參數進去，產生網址。接下來載入剛剛產生的網址。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ga-dev-tools.appspot.com/campaign-url-builder/&quot; title=&quot;google utm 產生器&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google utm 產生器 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sample: &lt;a href=&quot;https://ianccy.com/?utm_source=facebook&amp;#x26;utm_medium=post&amp;#x26;utm_campaign=mypost&quot; title=&quot;ianchuu urlutm&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://ianccy.com/?utm&lt;em&gt;source=facebook&amp;#x26;utm&lt;/em&gt;medium=post&amp;#x26;utm_campaign=mypost&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;查看數據方法&lt;/h2&gt;
&lt;p&gt;點擊 google analytics =&gt; 客戶開發 =&gt; 廣告活動
&lt;img src=&quot;../images/utmdemo.png&quot; alt=&quot;google utmdemo&quot; title=&quot;google utmdemo&quot;&gt;&lt;/p&gt;
&lt;p&gt;會發現我們剛剛定義的 utm&lt;em&gt;campaign 的參數 mypost 會歸類在廣告活動，媒介則是 utm&lt;/em&gt;medium 參數 post，來源就是 utm&lt;em&gt;source facebook，至於 utm&lt;/em&gt;term、utm_content 則會在主要維度 右邊的其他 =&gt; 客戶開發的欄位內。&lt;/p&gt;
&lt;p&gt;ps.提醒整個網站的 utm 架構，是需要討論的，最好要有一致化的命名風格，才方便日後整理數據、分析。還有盡量要能重複使用。
假設是操作 ig 貼文還有打即時影片廣告，需要兩個網址，
就可以類似這樣設計:
?utm&lt;em&gt;source=ig&amp;#x26;utm&lt;/em&gt;medium=ig&lt;em&gt;post&amp;#x26;utm&lt;/em&gt;campaign=summer&lt;em&gt;170623
?utm&lt;/em&gt;source=ig&amp;#x26;utm&lt;em&gt;medium=ig&lt;/em&gt;ad&lt;em&gt;instant&amp;#x26;utm&lt;/em&gt;campaign=summer_170625&lt;/p&gt;
&lt;p&gt;之後報表上，就可以看媒介 ig 整體的轉換率如何，接下來在查看是一般貼文高，還是即時影片廣告高，最後在針對每個廣告活動細看相關數據，看是否跳出率過高或是搭配事件追蹤查看使用者有沒有看完內容等等，這樣就可以有更細節的追蹤方法。&lt;/p&gt;
&lt;p&gt;我以前擔任行銷時，還沒有使用到 ga utm，團隊打 facebook 廣告就只能瞎子摸象，只能看出是 facebook 流量進來，然後發生轉換，可是看不出來是粉絲團，還是臉書廣告的功勞，更重要還有直接流量，假設不依靠網址參數分流的話，根本看不出來是 line@還是 mail 的流量。&lt;/p&gt;
&lt;p&gt;總之如果你還沒使用 utm 的話，強烈推薦你開始試試看!
&lt;a href=&quot;https://ga-dev-tools.appspot.com/campaign-url-builder/&quot; title=&quot;google utm 產生器&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google utm 產生器 &lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Node.js、Express、MySQL串接資料庫，Heroku部署環境]]></title><description><![CDATA[一個網站組成主要會是前端加後端，簡單來說，前端主要是畫面加上操作介面，包含了 html、css、javascript，後端則是處理使用者請求控制回應，例如登入註冊，會員後台等等，其中後端有各種語言例如 PHP、Java、ASP.NET、Node.js、Python、Ruby…]]></description><link>https://ianccy.com/2018-06-nodestart/</link><guid isPermaLink="false">https://ianccy.com/2018-06-nodestart/</guid><pubDate>Sun, 17 Jun 2018 11:37:49 GMT</pubDate><content:encoded>&lt;p&gt;一個網站組成主要會是前端加後端，簡單來說，前端主要是畫面加上操作介面，包含了 html、css、javascript，後端則是處理使用者請求控制回應，例如登入註冊，會員後台等等，其中後端有各種語言例如 PHP、Java、ASP.NET、Node.js、Python、Ruby...等等。&lt;/p&gt;
&lt;p&gt;在這個前後端分離的時代，多半會再開一台 Node.js 的 server 給前端處理 router，如果有使用到 javascript framework(react、vue、angular)，就會需要 server side render，在這邊一同處理畫面跟資料的渲染，而原本的後端則單純負責 api 建立。&lt;/p&gt;
&lt;p&gt;這邊就要來使用 Node.js 搭配 express 以及 MySQL 來建立簡單的網站 router。&lt;/p&gt;
&lt;!--- ![node.js](../images/node.png &quot;node.js&quot;) ---&gt;
&lt;h2&gt;express 建立 router&lt;/h2&gt;
&lt;p&gt;1.首先建立資料夾、建立 package.json&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// create folder and movein create package.json
mkdir node-express
cd node-express
npm init -y

//install express
npm install express --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.建立 app.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// use express method
var express = require(&apos;express&apos;);
var app = express();

// use express get method
// create root router and print hello world
app.get(&apos;/&apos;, function(req, res) {
    res.send(&apos;hello world&apos;);
});

// check running enviroment
var port = process.env.PORT || 3000;

// create
app.listen(port);

// only print hint link for local enviroment
if (port === 3000) {
    console.log(&apos;RUN http://localhost:3000/&apos;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://expressjs.com/zh-tw/4x/api.html#app.get.method&quot; title=&quot;express get&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;express get&lt;/a&gt;
&lt;a href=&quot;http://expressjs.com/zh-tw/4x/api.html#app.listen&quot; title=&quot;express listen&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;express listen&lt;/a&gt;
&lt;a href=&quot;http://expressjs.com/zh-tw/4x/api.html#app.METHOD&quot; title=&quot;express METHOD&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;express METHOD&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.執行 app.js、打開 &lt;a href=&quot;http://localhost:3000/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;http://localhost:3000/&lt;/a&gt;
打開 command 輸入 node app.js 執行檔案&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;node app.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../images/nodehello.png&quot; alt=&quot;node hello world&quot; title=&quot;node hello world&quot;&gt;
成功看到了 Hello world，這樣就建立了一個很簡易的 node server。但這邊印出來的 hello world，只是純粹字串，不具備 html 架構。&lt;/p&gt;
&lt;p&gt;4.建立對應 html 檔案搭配動態 router&lt;/p&gt;
&lt;p&gt;這邊用到的是 ejs template，方便我們之後取用 node.js 傳遞的資料。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// install ejs
npm install ejs-locals --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立 ejs 相對應的檔案。
&lt;img src=&quot;../images/filestru.png&quot; alt=&quot;file structure&quot; title=&quot;file structure&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// create ejs
var engine = require(&apos;ejs-locals&apos;);
app.engine(&apos;ejs&apos;,engine);
app.set(&apos;files&apos;,&apos;./files&apos;);
app.set(&apos;view engine&apos;,&apos;ejs&apos;);

...

// modify router use file name
app.get(&apos;/&apos;, function(req, res){
  res.render(&apos;index&apos;);
});

app.get(&apos;/about&apos;, function(req, res){
  res.render(&apos;about&apos;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;輸入完成一樣執行 node app.js，就完成有對應檔案的 router。
&lt;img src=&quot;../images/nodedemo.png&quot; alt=&quot;nodedemo&quot; title=&quot;nodedemo&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://expressjs.com/zh-tw/starter/static-files.html&quot; title=&quot;express static&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;express static&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;串接 MySQL&lt;/h2&gt;
&lt;p&gt;再來讓我們試著串接 MySQL，做一個完整的後端服務。如果你的電腦沒有安裝 MySQL，要記得先安裝好，&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/osx-installation-pkg.html&quot; title=&quot;mac 安裝 mysql 教學&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;mac 安裝 mysql 教學&lt;/a&gt;、&lt;a href=&quot;https://jerrynest.io/windows-mysql-installer/&quot; title=&quot;windwos 安裝 mysql 教學&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;windwos 安裝 mysql 教學&lt;/a&gt;。
ps.mysql 記得安裝 5.7 以下版本，剛剛跑一遍下載到 8.0.x 版本的，sequel pro 連接出一堆問題，也許是不支援新版的。&lt;/p&gt;
&lt;p&gt;1.安裝 MySQL for node.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// install MySQL tool
npm install mysql --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://expressjs.com/zh-tw/guide/database-integration.html#mysql&quot; title=&quot;express with mysql&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;express with mysql&lt;/a&gt;
&lt;a href=&quot;https://github.com/mysqljs/mysql&quot; title=&quot;node.js mysql&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;node.js mysql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.在 MySQL 建立資料、透過 express 連接 sql
&lt;img src=&quot;../images/sqldata.png&quot; alt=&quot;sqldata&quot; title=&quot;sqldata&quot;&gt;
在剛剛建立的 app.js 上面建立&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;...
var mysql      = require(&apos;mysql&apos;);

// connect MySQL
var connection = mysql.createConnection({
  host     : &apos;localhost&apos;,
  user     : &apos;root&apos;,
  password : &apos;&apos;,
  database: &apos;test&apos;
});

// select MyGuests table and print all colums
connection.query(&apos;select * from MyGuests&apos;, function(err, rows, fields) {
  if (err) throw err;
  console.log(&apos;The solution is: &apos;, rows);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行 node app.js 會看到印出資料，這樣就成功地在 express 連接到 MySQL 了，接下來就要把這個資料加到 express 的 router 中，讓我們在頁面中可以使用資料&lt;/p&gt;
&lt;p&gt;3.把剛剛 sql 的資料設定到 about page&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// create object
var data = {};
connection.query(&apos;select * from MyGuests&apos;, function(err, rows, fields) {
    if (err) throw err;
    // set data to object
    data.user = rows[0];
});

app.get(&apos;/&apos;, function(req, res) {
    res.render(&apos;index&apos;);
});

app.get(&apos;/about&apos;, function(req, res) {
    // add data property to about page
    res.render(&apos;about&apos;, { data: data.user });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.修改 about.ejs 使用設定的 data&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;    &amp;#x3C;h2&gt;Name:&amp;#x3C;%- data.id %&gt;&amp;#x3C;/h2&gt;
    &amp;#x3C;h2&gt;firstname:&amp;#x3C;%- data.firstname %&gt;&amp;#x3C;/h2&gt;
    &amp;#x3C;h2&gt;lastname:&amp;#x3C;%- data.lastname %&gt;&amp;#x3C;/h2&gt;
    &amp;#x3C;h2&gt;email:&amp;#x3C;%- data.email %&gt;&amp;#x3C;/h2&gt;
    &amp;#x3C;h2&gt;registert date:&amp;#x3C;%- data.reg_date %&gt;&amp;#x3C;/h2&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.執行檔案
&lt;img src=&quot;../images/expressdata.png&quot; alt=&quot;expressdata&quot; title=&quot;expressdata&quot;&gt;&lt;/p&gt;
&lt;p&gt;會發現到頁面拿到了 MySQL 的資料，這樣就完成了很基本的一個後端架構。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Ianpig/work/tree/nodeexpre&quot; title=&quot;source code&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;source code&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;部署 Heroku&lt;/h2&gt;
&lt;p&gt;再來把剛剛寫好的 node.js 部署到網路上面，heroku 有免費使用的方案，所以這邊使用的是 heroku。&lt;/p&gt;
&lt;p&gt;首先要安裝 heroku cli，再來註冊帳號，在專案內的 package.json 加入&quot;start&quot;: &quot;node app.js&quot;，新增檔案 Procfile。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://devcenter.heroku.com/articles/getting-started-with-nodejs#introduction&quot; title=&quot;heroku node deploy 教學&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;heroku node deploy 教學&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// file package.json

  &quot;engines&quot;: {
    &quot;node&quot;: &quot;6.2.2&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node app.js&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;#x26;&amp;#x26; exit 1&quot;
  },

// file Procfile
web: node app.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;開始準備部署作業&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//login account
heroku login

//use git
git init
git add .
git commit -m &quot;init node&quot;

// create heroku repo
heroku create

// push remote
git push heroku master

heroku ps:scale web=1

heroku open
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成部署之後就可以看到剛剛的內容了。&lt;/p&gt;
&lt;p&gt;實際上檔案架構應該要分離，這邊為了快速 demo 以及簡單化，所以全部操作都寫在一個檔案，應該要分離 router、MySQL 的邏輯，然後引入其他工具方便我們操作。讓架構比較清楚也比較好管理。日後再好好的處理一版。&lt;/p&gt;
&lt;p&gt;之後應該會考慮用 mongoDB，不用人人本地端要安裝 MySQL。然後寫 api 做出 CRUD，再搭配 node.js 或是 next 做 Server side render。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Facebook 粉絲團網域驗證教學]]></title><description><![CDATA[最近剛好朋友傳給我看一則文章，關於編輯貼文的功能，有條件地開放了。因為 fb 要防止假新聞事件重演，目前只開放媒體型粉絲團編輯連結資料，其他粉絲團 po 文都不能編輯，但是，「認證網域」之後就可以開放編輯貼文了。我看到這消息就實際跑一次流程試試看。 FB…]]></description><link>https://ianccy.com/2018-05-fbvotify/</link><guid isPermaLink="false">https://ianccy.com/2018-05-fbvotify/</guid><pubDate>Wed, 09 May 2018 22:45:24 GMT</pubDate><content:encoded>&lt;p&gt;最近剛好朋友傳給我看一則文章，關於編輯貼文的功能，有條件地開放了。因為 fb 要防止假新聞事件重演，目前只開放媒體型粉絲團編輯連結資料，其他粉絲團 po 文都不能編輯，但是，「認證網域」之後就可以開放編輯貼文了。我看到這消息就實際跑一次流程試試看。&lt;/p&gt;
&lt;!--- ![facebook vertify](../images/facebook.png &quot;fb domain vertify&quot;) ---&gt;
&lt;h2&gt;FB 官方說明 網域驗證的功能&lt;/h2&gt;
&lt;p&gt;驗證網域完全免費，還可保護內容安全。企業商家可以驗證線上網域，以便編輯網域連結。網域通過驗證後，您就能認領並維護自家內容及連結的編輯權限。透過網域驗證，發佈商和廣告主得以掌控有權編輯其內容的對象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.facebook.com/business/help/286768115176155&quot; title=&quot;FB網域驗證說明&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;FB 網域驗證說明 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先找到了 FB 的官方教學，如果你沒有企業平台就先申請，然後再加入粉絲團。(這步驟省略)&lt;a href=&quot;https://business.facebook.com/&quot; title=&quot;創建企業平台&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt; 創建企業平台 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;進入企業平台設定 =&gt;  點擊左邊導覽的安全 -&gt; 網域驗證
&lt;img src=&quot;../images/fb-domainvertify.png&quot; alt=&quot;fb domain vertify&quot; title=&quot;fb domain vertify&quot;&gt;&lt;/p&gt;
&lt;p&gt;最重要的就這邊了，facebook 提供你兩種方法驗證網域。&lt;/p&gt;
&lt;h2&gt;第一個方法 新增 DNS 紀錄驗證&lt;/h2&gt;
&lt;p&gt;找到你的 domain hosting 的地方 =&gt; 然後增加 dns txt (格式可以參照 google 教學，記得改成 fb 給的代碼)&lt;/p&gt;
&lt;p&gt;強烈推薦大家觀看 google 的新增 dns txt 教學，只是代碼記得要貼 fb 給的，寫的比 fb 好上一百萬倍...。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.facebook.com/help/work/816932368486761?helpref=uf_permalink&quot; title=&quot;FB DNS txt教學流程&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;FB DNS txt 教學流程 &lt;/a&gt;
&lt;a href=&quot;https://support.google.com/a/topic/1409901&quot; title=&quot;Google DNS txt教學流程&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;推薦看 Google DNS txt 教學流程 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;雖然我是用 godaddy 的網域，但因為我不是用他們來 host，用比較冷門的主機商，所以就不貼上我自己的流程了。&lt;/p&gt;
&lt;h2&gt;第二個方法 html 檔案 驗證&lt;/h2&gt;
&lt;p&gt;首先下載 html 檔案，在根目錄增加，然後載入頁面。這方法看起來最簡單直白，假設你可以自由控制主機的話。&lt;/p&gt;
&lt;p&gt;兩步驟擇一完成之後就等待一段時間，再點擊驗證就完成了。&lt;/p&gt;
&lt;p&gt;寫這篇文章，主要推薦大家看 google dns txt 教學，各大網域代管商都有，外加流程圖圖文並茂，果然是 google 啊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/fb_vertify_pass.png&quot; alt=&quot;facebook vertify pass&quot; title=&quot;fb domain vertify pass&quot;&gt;
因為網址有做 redirect 關係，關閉了才過關...。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Higher Order Components 初探觀念]]></title><description><![CDATA[換了工作環境，接觸了全新的專案，一打開 react 專案，恩...滿滿的 stateless component，稍微整理一下相關資訊。這邊要來介紹使用 stateless component 的時候，常會搭配使用的 Higher Order Components…]]></description><link>https://ianccy.com/2018-05-reacthoc/</link><guid isPermaLink="false">https://ianccy.com/2018-05-reacthoc/</guid><pubDate>Tue, 08 May 2018 23:28:33 GMT</pubDate><content:encoded>&lt;p&gt;換了工作環境，接觸了全新的專案，一打開 react 專案，恩...滿滿的 stateless component，稍微整理一下相關資訊。這邊要來介紹使用 stateless component 的時候，常會搭配使用的 Higher Order Components，之前有看到「高階組件」這區塊，被他名字誤會了，實際上一點也不高階，他就只是一個 function 函式，接受參數元件然後回傳全新元件，簡易的範例如下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.css88.com/react/docs/higher-order-components.html&quot; title=&quot;React官方說明&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;React 官方說明 &lt;/a&gt; - 高階組件是一個函數，能夠接受一個組件並返回一個新的組件。&lt;/p&gt;
&lt;!--- ![react](../images/react.png &quot;react&quot;) ---&gt;
&lt;h2&gt;stateless component&lt;/h2&gt;
&lt;p&gt;ps.以下混雜使用 es6 解構、展開運算子(Spread Operator)寫法，在 react 中處理大量 props 很方便。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//stateless component  預設props會作為參數
function NameCard(props) {
    return &amp;#x3C;h2&gt;Hello,{props.name}&amp;#x3C;/h2&gt;;
}

//接到一個參數的元件 然後加上props 回傳有加入props的元件
function Warpper(Item) {
    const props = { name: &apos;Chu&apos; };
    return &amp;#x3C;Item {...props} /&gt;;
}
const element = Warpper(NameCard);

ReactDOM.render(element, document.getElementById(&apos;root&apos;));
&lt;/code&gt;&lt;/pre&gt;
&lt;iframe height=&apos;265&apos; scrolling=&apos;no&apos; title=&apos;ZovoEQ&apos; src=&apos;//codepen.io/chu1228/embed/ZovoEQ/?height=265&amp;theme-id=dark&amp;default-tab=js,result&amp;embed-version=2&apos; frameborder=&apos;no&apos; allowtransparency=&apos;true&apos; allowfullscreen=&apos;true&apos; style=&apos;width: 100%;&apos;&gt;See the Pen &lt;a href=&apos;https://codepen.io/chu1228/pen/ZovoEQ/&apos;&gt;ZovoEQ&lt;/a&gt; by ianchu (&lt;a href=&apos;https://codepen.io/chu1228&apos;&gt;@chu1228&lt;/a&gt;) on &lt;a href=&apos;https://codepen.io&apos;&gt;CodePen&lt;/a&gt;.
&lt;/iframe&gt;
[範例連結 ](https://codepen.io/chu1228/pen/vjpRrW?editors=0010 &quot;範例連結&quot;)
&lt;h2&gt;HOC component&lt;/h2&gt;
&lt;p&gt;ps.es6 arrow function 產生 return function 邏輯&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const Wrapper = a =&gt; b =&gt; {
    console.log(a, b);
};

// babel 會編譯為如下
var Wrapper = function Wrapper(a) {
    return function(b) {
        console.log(a, b);
    };
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下來就改使用 return function 來傳遞額外資料&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//建立 Person 元件
function Person(props) {
    const { name, age, status } = props;
    return (
        &amp;#x3C;h1&gt;
            Hello, {name} is {age} years old,ohhh and so {status}
        &amp;#x3C;/h1&gt;
    );
}

//建構包裹的function
const Warpper = child =&gt; props =&gt; {
    //加入物件 status 判斷age 大於18 true=&gt;產生old false =&gt;產生young
    props = { ...props, status: props.age &gt; 18 ? &apos;old&apos; : &apos;young&apos; };
    return child({ ...props });
};

const person1 = { name: &apos;ian&apos;, age: 28 };
const element = Warpper(Person)(person1);

ReactDOM.render(element, document.getElementById(&apos;root&apos;));
&lt;/code&gt;&lt;/pre&gt;
&lt;iframe height=&apos;265&apos; scrolling=&apos;no&apos; title=&apos;VxyQOa&apos; src=&apos;//codepen.io/chu1228/embed/VxyQOa/?height=265&amp;theme-id=dark&amp;default-tab=js,result&amp;embed-version=2&apos; frameborder=&apos;no&apos; allowtransparency=&apos;true&apos; allowfullscreen=&apos;true&apos; style=&apos;width: 100%;&apos;&gt;See the Pen &lt;a href=&apos;https://codepen.io/chu1228/pen/VxyQOa/&apos;&gt;VxyQOa&lt;/a&gt; by ianchu (&lt;a href=&apos;https://codepen.io/chu1228&apos;&gt;@chu1228&lt;/a&gt;) on &lt;a href=&apos;https://codepen.io&apos;&gt;CodePen&lt;/a&gt;.
&lt;/iframe&gt;
[範例連結 ](https://codepen.io/chu1228/pen/VxyQOa?editors=0010 &quot;範例連結&quot;)
&lt;p&gt;核心概念就是將元件包裹上我們想要增加的屬性，舉凡是 props、lifecycle 等等，我們可以將許多元件共用的函式，整理建立一個專門用來處理 HOC 的 function，然後各元件重複使用。redux 的 connect 也是同樣使用 HOC 的觀念，將 mapStateToProps、mapDispatchToProps 在處理成我們要的 props 傳遞給元件。&lt;/p&gt;
&lt;p&gt;主要是網路看不到 stateless component 這方面的介紹，所以才寫這篇解釋一下下 HOC 在幹嘛。&lt;/p&gt;
&lt;p&gt;以上如果有錯誤，再麻煩留言提醒。感謝!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Google analytics 事件追蹤、轉換目標設定教學 ga event]]></title><description><![CDATA[Google analytics 是一個追蹤數據的好工具，其中有個重要的功能『事件追蹤』，事件追蹤可以讓我們紀錄使用者的動作，例如點擊註冊會員按鈕、影片播放，或是  滾動畫面等等，只要動作能判斷都可，甚至連滑鼠移動可以追蹤。 通常一個網站一定會有要求的 KPI…]]></description><link>https://ianccy.com/2018-04-gaevents/</link><guid isPermaLink="false">https://ianccy.com/2018-04-gaevents/</guid><pubDate>Wed, 25 Apr 2018 23:29:39 GMT</pubDate><content:encoded>&lt;p&gt;Google analytics 是一個追蹤數據的好工具，其中有個重要的功能『事件追蹤』，事件追蹤可以讓我們紀錄使用者的動作，例如點擊註冊會員按鈕、影片播放，或是  滾動畫面等等，只要動作能判斷都可，甚至連滑鼠移動可以追蹤。&lt;/p&gt;
&lt;!--- ![google analytics](../images/google_analytics.png &quot;google analytics&quot;) ---&gt;
&lt;p&gt;通常一個網站一定會有要求的 KPI，例如註冊會員數、訂單數、填表數等等，這時候如果沒有建立轉換目標的話，就只能看流量自圓其說了 ，下廣告也只能盲目亂打一通。&lt;/p&gt;
&lt;p&gt;這時候就可以使用 google analytics 提供的方法 ga(&apos;send&apos;, &apos;event&apos;, xx , xx , xx)針對這些動作來產生事件，成功產生事件後，就可以再把這個事件設定為轉換目標，就可以做到註冊會員、填表等等的追蹤了。&lt;/p&gt;
&lt;p&gt;但實際上負責 ga 的多半都是行銷，技術人員可能不懂怎設定 ga 事件，又或是沒有配置技術人員，這時候必須要自己來實作了。其實基本的事件追蹤並不難，後面就來教你怎麼自己寫追蹤事件。&lt;/p&gt;
&lt;h2&gt;Google analytics 設定事件&lt;/h2&gt;
&lt;p&gt;首先來教你設定 ga 的事件，下方的官方文件，很清楚的介紹 ga 事件是如何運作的，當 ga(send,{hitType: &apos;event&apos;,xxx })執行之後，搭配 hitType 為 event，再加上必備的參數，事件類別以及事件動作，就可以讓 google analytics 接收到資料。下面程式是簡單的事件執行的方法(Method)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;開發者文件 : &lt;a href=&quot;https://developers.google.com/analytics/devguides/collection/analyticsjs/events?hl=zh-cn&quot; title=&quot;google analytics event 技術文件&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google analytics event 技術文件 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;說明 : &lt;a href=&quot;https://support.google.com/analytics/answer/1033068&quot; title=&quot;ga 事件中文說明&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;ga 事件說明 &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
簡單介紹一下在寫啥米
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  //當使用者觸發 會發送 類別:導覽清單 ,動作:點擊 ,標籤:註冊會員 , 價值:200
  ga(&apos;send&apos;, {
    hitType: &apos;event&apos;,
    eventCategory: &apos;導覽清單&apos;, // 類別 字元(必填)
    eventAction: &apos;點擊&apos;, //動作 字元(必填)
    eventLabel: &apos;註冊會員&apos; //標籤 字元(選填)
    eventValue: &apos;200&apos; //標籤 數字(選填)
  });
  // ==&gt; 下方為簡化
  ga(&apos;send&apos;, &apos;event&apos;, &apos;導覽清單&apos;, &apos;點擊&apos;, &apos;首頁 - 註冊會員&apos;, 200);
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;p&gt;寫好了 event 的參數之後，再來是要如何才能觸發，我們預期使用者點擊註冊跟登入會員按鈕，執行 ga 的事件紀錄。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // 登入註冊會員按鈕

  // 1.html onclick 設定方法
  ...
  &amp;#x3C;button onclick=&quot;ga(&apos;send&apos;, &apos;event&apos;, &apos;導覽清單&apos;, &apos;點擊&apos;, &apos;登入會員&apos;);&quot; id=&quot;loginMember&quot; class=&quot;btn btn-primary&quot;&gt;登入會員&amp;#x3C;/button&gt;
  &amp;#x3C;button onclick=&quot;ga(&apos;send&apos;, &apos;event&apos;, &apos;導覽清單&apos;, &apos;點擊&apos;, &apos;註冊會員&apos;, 200);&quot; id=&quot;registerMember&quot; class=&quot;btn btn-warning&quot;&gt;註冊會員&amp;#x3C;/button&gt;
  ...

  // 2.不能動到html的話 就用這個方法
  // javascript track click
  ...
  &amp;#x3C;button id=&quot;loginMember&quot; class=&quot;btn btn-primary&quot;&gt;登入會員&amp;#x3C;/button&gt;
  &amp;#x3C;button id=&quot;registerMember&quot; class=&quot;btn btn-warning&quot;&gt;註冊會員&amp;#x3C;/button&gt;

  &amp;#x3C;script&gt;
  //確保html載入後執行
  window.addEventListener(&quot;DOMContentLoaded&quot;, function() {
    //監聽登入按鈕點擊 執行ga的方法 id=&quot;loginMember&quot;
    document.querySelector(&apos;#loginMember&apos;).addEventListener(&apos;click&apos;,function(e){
      ga(&apos;send&apos;, &apos;event&apos;, &apos;導覽清單&apos;, &apos;點擊&apos;, &apos;登入會員&apos;);
    });

    //監聽註冊按鈕 id=&quot;register&quot;
    document.querySelector(&apos;#register&apos;).addEventListener(&apos;click&apos;,function(e){
      ga(&apos;send&apos;, &apos;event&apos;, &apos;導覽清單&apos;, &apos;點擊&apos;, &apos;註冊會員&apos;, 200);
    });
  }, false);

  &amp;#x3C;/script&gt;

  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;實作測試&lt;/h2&gt;
&lt;p&gt;很簡單的做出兩顆按鈕，點擊下方按鈕就會發出 ga event 的方法，就可以讓我們在 ga 上看到數據了，點選 即時 =&gt; 事件 來檢查有沒有成功，行為 =&gt; 事件 則需要幾小時資料才會出現。&lt;/p&gt;
&lt;div style=&quot;background:#eee;padding:15px;text-align:center;&quot;&gt;
demo:
  &lt;button id=&quot;loginMember&quot; class=&quot;pure-button pure-button-primary&quot;&gt;登入會員&lt;/button&gt;  &lt;button id=&quot;registerMember&quot; class=&quot;pure-button pure-button-primary&quot;&gt;註冊會員&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
  window.addEventListener(&quot;DOMContentLoaded&quot;, function() {
    document.querySelector(&apos;#loginMember&apos;).addEventListener(&apos;click&apos;,function(e){
      alert(&apos;觸發 ga event 登入&apos;)
      ga(&apos;send&apos;, &apos;event&apos;, &apos;導覽清單&apos;, &apos;點擊&apos;, &apos;登入會員&apos;);
    });
&lt;pre&gt;&lt;code&gt;document.querySelector(&apos;#registerMember&apos;).addEventListener(&apos;click&apos;,function(e){
  alert(&apos;觸發 ga event 註冊&apos;)
  ga(&apos;send&apos;, &apos;event&apos;, &apos;導覽清單&apos;, &apos;點擊&apos;, &apos;註冊會員&apos;, 200);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, false);
&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;查看 ga 即時是否有數據，發現成功看到數字了，大功告成！
&lt;img src=&quot;../images/ga%E5%8D%B3%E6%99%82event.png&quot; alt=&quot;ga即時event&quot; title=&quot;ga即時event&quot;&gt;&lt;/p&gt;
&lt;br/&gt;
&lt;h2&gt;ga event 產生器&lt;/h2&gt;
&lt;p&gt;最後順便寫了 ga event 產生器，如果你不太會改參數的話，直接用下來複製貼上吧，只差我沒加上取消互動的參數，還有表單沒特別設計有點醜醜。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;連結 : &lt;a href=&quot;https://work.ianccy.com/gaeventgenerator.html&quot; title=&quot;ga event generator&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;ga event generator &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;iframe height=&apos;700&apos; scrolling=&apos;no&apos; src=&quot;https://work.ianccy.com/gaeventgenerator.html&quot; frameborder=&apos;no&apos; allowtransparency=&apos;true&apos; allowfullscreen=&apos;true&apos; style=&apos;width: 100%;&apos;&gt;
&lt;/iframe&gt;
&lt;h2&gt;Google analytics 事件設定目標轉換&lt;/h2&gt;
&lt;p&gt;官方文件有關於轉換的不同設定教學，我們這邊利用剛剛建立好的事件來設定轉換，接下來就只剩下設定目標轉換，點選左下角的管理員 =&gt; 點選目標 =&gt; 新增目標 =&gt; 自訂。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件 : &lt;a href=&quot;https://support.google.com/analytics/answer/1032415&quot; title=&quot;ga 官方目標設定&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;ga 官方目標設定 &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;../images/%E8%BD%89%E6%8F%9B%E8%A8%AD%E5%AE%9A.png&quot; alt=&quot;轉換設定&quot; title=&quot;轉換設定&quot;&gt;&lt;/p&gt;
&lt;p&gt;選擇事件，再輸入事件名稱
&lt;img src=&quot;../images/%E8%BD%89%E6%8F%9B%E8%A8%AD%E5%AE%9A2.png&quot; alt=&quot;轉換設定2&quot; title=&quot;轉換設定2&quot;&gt;&lt;/p&gt;
&lt;p&gt;測試事件，觀看即時轉換是否有數字
&lt;img src=&quot;../images/%E8%BD%89%E6%8F%9B%E8%A8%AD%E5%AE%9A3.png&quot; alt=&quot;轉換設定3&quot; title=&quot;轉換設定3&quot;&gt;&lt;/p&gt;
&lt;h2&gt;完成事件、轉換設定後&lt;/h2&gt;
&lt;p&gt;完成轉換設定之後，我們就可以根據依據轉換數字來判斷，哪個廣告成效較佳、或使用者都在哪個頁面發生轉換。&lt;/p&gt;
&lt;p&gt;如果你對於 javascript 熟悉的話，還可以寫一些動態判斷，例如追蹤某區塊的連結，然後動態帶入連結的標籤名稱、或是頁面，就可以歸納出這區塊中哪些連結使用者最常點擊，哪些最不常點擊等等等等。&lt;/p&gt;
&lt;p&gt;操作廣告的話，我自己是覺得網站設定 ga 事件、轉換後，再搭配 gtm，對於判斷成效有非常大幫助，如果你操作廣告但不會用，那推薦你嘗試看看設定轉換。事件、轉換對於行銷來說是非常好用的 ga 工具，讓你多了一把武器上戰場。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[前端工程師面試心得 | Frontend Engineer interview]]></title><description><![CDATA[ 整理最近的面試心得，要找的是第二份前端職缺，我大概在三月開始找工作，主要是用 104、yourator、ptt，找的都是希望有用到前端框架或是未來要用，挑公司產品主力是網頁相關。幾乎都是主動投遞履歷居多，主動找我的只有一間有約面試。 我是用 cakeresume…]]></description><link>https://ianccy.com/2018-03-interview/</link><guid isPermaLink="false">https://ianccy.com/2018-03-interview/</guid><pubDate>Sun, 25 Mar 2018 22:32:53 GMT</pubDate><content:encoded>&lt;p&gt; 整理最近的面試心得，要找的是第二份前端職缺，我大概在三月開始找工作，主要是用 104、yourator、ptt，找的都是希望有用到前端框架或是未來要用，挑公司產品主力是網頁相關。幾乎都是主動投遞履歷居多，主動找我的只有一間有約面試。&lt;/p&gt;
&lt;p&gt;我是用 cakeresume 製作的線上履歷，自己覺得比 104 的好看許多，簡單不拖泥帶水，還可以讓你用 html 改樣式，非常推薦。&lt;/p&gt;
&lt;h2&gt;個人履歷：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cakeresume.com/s--218myPu57dtHzWToabR5lg--/chu2815&quot; title=&quot;cakeresume 線上履歷&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;cakeresume 線上履歷&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--- ![interview](../images/interview.png &quot;interview&quot;) ---&gt;
&lt;h2&gt;個人背景&lt;/h2&gt;
&lt;p&gt; 前一份工作兩年網路行銷經驗 ， 目前  一年半的前端工作經驗，工作上主要用 css、html、javascript、bootstrap、jquery、react.js、串接各種 api，還有編寫 jsp、jstl，偶爾會幫寫 controller。&lt;/p&gt;
&lt;p&gt;公司目前就一個前端，負責範圍滿廣的， 前台要處理、後台也要處理。 所以參與到滿多功能開發，面試很多東西可以聊。 另外因為我上一份工作因素，每間公司幾乎都會聊到 SEO。&lt;/p&gt;
&lt;p&gt;因為希望能夠磨練前端技術，所以選擇向外找工作。&lt;/p&gt;
&lt;h2&gt;面試公司&lt;/h2&gt;
&lt;h3&gt;1.愛食記(yourator)&lt;/h3&gt;
&lt;p&gt;因為愛食記是我愛用的 app， 可以找附近的餐廳，所以當下毫不猶豫投履歷。&lt;/p&gt;
&lt;h4&gt;onsite 面試&lt;/h4&gt;
&lt;p&gt;首先先與兩位技術 co-founder 面試， 非常驚人的是目前只有兩位技術人員，一個負責 ios 加前端、另一個負責 android 加後端，原本還以為是 10 幾人的新創公司(因為 yourator 照片人很多 XD)，能做出這樣的 app 真的是十分厲害。&lt;/p&gt;
&lt;p&gt;首先自我介紹，再來就是公司介紹，後面聊到我變成小粉絲，提到使用感想、建議，再來就是簡單的 javascript 問題。&lt;/p&gt;
&lt;p&gt; 最後才是筆試 - 使用 google hangout 共享螢幕，筆試總共五題，題目需要與面試官溝通了解情境、需求，另外是使用 JEST 測試。&lt;/p&gt;
&lt;p&gt;大概考的觀念是處理排序、篩選 array 資料、immutable、還有解構賦值等等，邏輯其實沒有太難，不過陷阱滿多，我是下班直接過去，沒吃晚餐肚子超餓，到後面我其實腦袋一片空白，然後每個題目都要問面試官才能知道，寫到後面卡住就中斷面試了。&lt;/p&gt;
&lt;p&gt;這次面試後，讓我知道 immutable 的重要性，處理資料要注意有沒有改變到本身。處理 array 用 push、pop、shift、unshift、reserve、sort、splice 都會改變原有的陣列。這個觀念在處理複雜的全域變數陣列非常有幫助。&lt;/p&gt;
&lt;p&gt;結果:感謝信&lt;/p&gt;
&lt;h3&gt;2.triplisher(yourator)&lt;/h3&gt;
&lt;p&gt;提一下公司環境，雖然公司人不多，但空間非常舒適，舒適的裝潢附有 bar 台、沙發等。&lt;/p&gt;
&lt;h4&gt;onsite 面試&lt;/h4&gt;
&lt;p&gt;進去會先給你中文的邏輯測驗，給你一段文章，文章內會給你每個物品與人的關聯，誰的隔壁是什麼之類的，要你推導出最後人與物品的關係。覺得難度還好，稍微想一下應該還 ok。&lt;/p&gt;
&lt;p&gt;我拿到的題目是修改 google map 的滑鼠事件，觸發滑鼠改變畫面 css，要你拿官網直接做修改，如果有用過 google map 的 event 應該算簡單。&lt;/p&gt;
&lt;p&gt;後面都是與技術主管面談，不免俗的自我介紹，閒聊之後，知道公司核心功能要用 react 改寫，未來計劃推出 react native 的 app，目前團隊就一個後端技術人員。話說我問到瀏覽器支援，技術主管要求的是盡可能的支援，我還以為自己公司支援到 ie9 已經很廣了，沒想到這裡支援更廣，讓我十分驚訝。&lt;/p&gt;
&lt;p&gt;最後技術主管提到，目前有非常多的前端 candidate，所以預計會在月底通知二面，恩...聽起來應該是張無聲卡。&lt;/p&gt;
&lt;p&gt;結果:無聲卡&lt;/p&gt;
&lt;h3&gt;3.Yahoo(104)&lt;/h3&gt;
&lt;p&gt;人資先打電話通知應徵職缺資料，並且約電話面試時間，我接到電話才知道我投遞的是約聘職，不過想說面試 yahoo 應該會讓我學到不少東西，就答應後續面試了。&lt;/p&gt;
&lt;h4&gt;電話面試:&lt;/h4&gt;
&lt;p&gt;首先由部門技術主管、前端來電面試。下面滿多題目我沒有答出來的，像是 event loop、settimeout 原理，遇到跨網域 CORS 要怎麼解決，過程有點像是快問快答。&lt;/p&gt;
&lt;p&gt;電話面試題目:
網頁載入流程、display all type、Cookie localstorage sessionstorage、CSS box model、Javasctipt Event loop、settimeout 原理、CORS 處理、Promise 原理、功能&lt;/p&gt;
&lt;h4&gt;onsite 面試&lt;/h4&gt;
&lt;p&gt;會請你 share 螢幕投影。首先要你求質數，丟入某個數字 input，然後得到數字以下的所有質數，我第一步驟是卡在如何分辨質數，技術主管有提示我，不過很可惜最後我沒完成...。&lt;/p&gt;
&lt;p&gt;接下來就與前端工程師一對一面試，要你先切版面，然後要你置中或水平置中置頂，再來是考你下面這些題目，先從 css 觀念開始，再來是 javascript 基礎，後面開始進入 react，還不太熟悉所以這邊還滿慘，redux 還直接跳過。最後一題是 promise，不斷延伸 promise 然後問你其中每個步驟的 flow。&lt;/p&gt;
&lt;p&gt;工程師在面試過程，如果你答錯了，他還會說正確的答案，然後解釋原因，這點非常棒，不會只有單向的你問我答。&lt;/p&gt;
&lt;p&gt;Onsite 題目:
Css - 排版、selector、box-modal、border box-sizing
js - event loop、this、eettimeout、hosisting、let 命名 function 處理 hoisting&lt;/p&gt;
&lt;p&gt;react - HOC high order component、state prop、Stateless component
Es6 - 介紹 es6 新功能、Promise&lt;/p&gt;
&lt;h3&gt;4.Medpartner(ptt)&lt;/h3&gt;
&lt;h4&gt;onsite 面試&lt;/h4&gt;
&lt;p&gt;medpartner 是做醫療內容的新創公司，我是在 ptt 看到的徵才訊息。技術長擔任面試官，面試官是台大資工的大大，是一個創業家，很真誠的跟你介紹他自己，是我面試下來最認真介紹自己的面試官，讓人覺得誠意十足，再來就換我自我介紹，才知道公司之後要發展電商、軟體，而目前團隊也欠缺前端角色。&lt;/p&gt;
&lt;p&gt;聊完就開始考白板題目，不過可以讓你用筆電先寫好在寫上去，考你處理陣列、物件的判斷，後面再延伸下去，要你追求效能的寫演算法，題目共有 3 題，我只寫了兩題，可能後面趕時間，所以就改讓我口頭講邏輯。&lt;/p&gt;
&lt;h4&gt;視訊面試&lt;/h4&gt;
&lt;p&gt;接下來是視訊面試，錄取前需要與創辦人聊天，創辦人非常非常熱情，提到他許多創業理念，希望讓社會能夠共善。公司也有不錯的福利待遇，每週 remote 或是月額外獎金等等，不過思考過後婉拒邀請，個人還是希望加入的公司是有前端團隊。&lt;/p&gt;
&lt;p&gt;結果:收到 offer&lt;/p&gt;
&lt;h3&gt;5.Voicetube(104)&lt;/h3&gt;
&lt;h4&gt;實作測驗&lt;/h4&gt;
&lt;p&gt;voicetube 是用 vue，是我唯一投遞用 react 以外的框架的公司。&lt;/p&gt;
&lt;p&gt;首先會寄給你技術表還有題目實作，技術表混雜後端、前端技術名稱，雲端 server、php 後端都沒涉略，幾乎沒勾...。實作題目是給你一個 api，然後再給你一個 sketch 檔，要你實現 mockup、串接 api，沒有限定型式，我選擇用 React 來寫，大概花了一早上寫完，一開始就遇到 CORS 的問題，時間因素沒自己架 sever 串過去，選擇自己建假資料。時間、排版或字串需要注意，其餘部分應該沒有特別難。&lt;/p&gt;
&lt;h4&gt;onsite 面試&lt;/h4&gt;
&lt;p&gt;同時與公司的後端、前端、技術主管一起面試，首先由我自我介紹，再來由前端工程師針對之前實作 codereview，詢問滿多細節為什麼這樣寫，某些寫法記憶體效能可以更好，最重要才發現我居然忘記調 RWD。相比其他公司沒有太多前端技術問題，主要流程像是我分享自己技術實作，大家在一起討論技術解法。&lt;/p&gt;
&lt;p&gt;後面變成與技術主管一對一面試，比較像是一對一聊天，整個過程非常愉快，分享滿多 voicetube 對於使用新技術的看法，還有團隊合作流程，還有 voicetube 也非常注重 SEO，其他關於 voicetube 營運細節就不做分享了。&lt;/p&gt;
&lt;p&gt;雖然是全部面試過程最愉快也最順利的公司，很意外的收到感謝信，也許是框架不同，也許是我的技術還不足。&lt;/p&gt;
&lt;p&gt;結果:感謝信&lt;/p&gt;
&lt;h3&gt;6.KKbox(104)&lt;/h3&gt;
&lt;h4&gt;實作測驗&lt;/h4&gt;
&lt;p&gt;收到面試題目是 codity 線上測驗，總共有三題我是選擇用 javascript 作答，第一題是 array 處理、第二題 debug、第三題 ajax 處理畫面，作答時間大概是 2 小時左右，第三題沒答對，因為不知道 codity 要怎做畫面處理。&lt;/p&gt;
&lt;h4&gt;onsite 面試&lt;/h4&gt;
&lt;p&gt;面試是與另一個部門的前端工程師、用人部門主管同時面試，很意外完全沒詢問我 codity 上面作答內容，反倒是主管很詳細地問我學前端的過程，還有行銷轉前端的問題，很鉅細靡遺的了解我職涯。再來是前端工程師面試，詢問了一些技術問題，介紹之後工作負責的內容，很簡單的結束面試。&lt;/p&gt;
&lt;h3&gt;簡報面試&lt;/h3&gt;
&lt;p&gt;題目是優化曾經寫過的 code，不論是 UX、效能、coding style 皆可，收到題目後，剛好就收到 offer 了，因為應徵部門會只有一個前端，思考過之後婉拒後續面試。&lt;/p&gt;
&lt;p&gt;結果:婉拒面試&lt;/p&gt;
&lt;h2&gt;感想&lt;/h2&gt;
&lt;p&gt;最後選的公司沒有寫在上面，總計面試了 7 間公司，花了大概 3、4 天面試，最後拿到兩個 offer，沒特別列出薪資。因為我都是用一樣的年薪(前端 junior 薪資)去談。&lt;/p&gt;
&lt;p&gt;考前有稍微刷了 leetcode easy medium，但實際上幫助不大，不如好好了解 ES6 新功能，面試題目沒到 medium 那麼難，反倒是投影螢幕臨場考試都太緊張，其中兩個面試都沒吃正餐，肚子餓會更不舒服，腦袋會呈現一片空白。yahoo 的面試後面工程師讓我邊吃餅乾邊面試...，因為那時候真的太餓了。&lt;/p&gt;
&lt;p&gt;還有記得帶筆電，不是要 demo 作品自我介紹，是面試幾乎都有上機測驗。javascript 上除了 react 以外，幾乎大家面試問的題目都差不多，ES6、evenet loop、this，至於 css 滿多公司都簡單帶過，只有 yahoo 是問滿滿的 css。&lt;/p&gt;
&lt;p&gt;技術上現在公司都採前後端分離，後端 php、java 處理 api，node.js 則交由前端處理，都有做 server side render 優化 SEO。然後滿多公司放生 IE9 XDDD，css 用到 flex。&lt;/p&gt;
&lt;p&gt;實際面試之後更能感覺自己那些地方不足，對於滿多技術的背後原理不夠熟悉，被問深入就被問倒，最後就期許自己可以更加油。&lt;/p&gt;
&lt;p&gt;感謝你的閱讀 。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Google sheet 試算表表單串接api]]></title><description><![CDATA[要用到活動或是問卷，相信大家最常會用到 google form，非常快速的創出填表功能，但 google form 存在許多限制，我沒辦法創立特別的欄位，沒辦法做出一個複雜訂餐表單，表單長太醜(痾...其實我對 google…]]></description><link>https://ianccy.com/2018-02-googleformapi/</link><guid isPermaLink="false">https://ianccy.com/2018-02-googleformapi/</guid><pubDate>Thu, 08 Feb 2018 20:34:31 GMT</pubDate><content:encoded>&lt;p&gt;要用到活動或是問卷，相信大家最常會用到 google form，非常快速的創出填表功能，但 google form 存在許多限制，我沒辦法創立特別的欄位，沒辦法做出一個複雜訂餐表單，表單長太醜(痾...其實我對 google 表單設定不太熟悉)。&lt;/p&gt;
&lt;p&gt;或是不希望讓使用者點擊網址離開才能填表。最後網站只能鑲上 google form 的 iframe 又無法追蹤填表操作動作，google analytics 轉換目標也不能設定。上面這些問題都可以用 google excel 的 api 來解決。&lt;/p&gt;
&lt;!--- ![炸雞demo](../images/炸雞demo.png &quot;炸雞demo&quot;) ---&gt;
&lt;p&gt;&lt;a href=&quot;https://work.ianccy.com/%E7%82%B8%E9%9B%9E%E8%A8%82%E8%B3%BC&quot; title=&quot;炸雞訂購網頁&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;炸雞訂購網頁&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;延伸文章: &lt;a href=&quot;/googleformadv/&quot; title=&quot;客戶讀取、取消訂單&quot;&gt;客戶讀取、取消訂單&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;google excel 試算表 實作功能&lt;/h2&gt;
&lt;p&gt;這邊要利用 google 試算表 增加資料 撈取 來實作一個網頁，簡單的鹹酥雞訂餐服務，老闆也可以修改處理狀態，讓顧客可以再取餐前查詢，到底老闆有沒有幫我做好鹹酥雞勒，還是放生我了 XD。&lt;/p&gt;
&lt;p&gt;只需要搭配 html + css + javascript。
（因為我家附近有間鹹酥雞，每次買都實在等太久，所以才想玩玩看。）&lt;/p&gt;
&lt;h2&gt;google sheet method 介紹&lt;/h2&gt;
&lt;p&gt;google 官方文件 &lt;a href=&quot;https://developers.google.com/apps-script/reference/spreadsheet/sheet&quot; title=&quot;google sheet api&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;spreadsheet method&lt;/a&gt;，裡面有非常詳盡的介紹，包括可以讀取欄位、讀取資料、排序資料、插入資料等等的功能，其實某方面來說算是功能齊全的類資料庫了。有興趣可以點開來看裡面文件。&lt;/p&gt;
&lt;p&gt;文件裡面 method 一大堆，還是直接實作比較快。&lt;/p&gt;
&lt;h3&gt;STEP.1 打開 google 雲端硬碟 建立 google excel、建立 google AppScript&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/creatExcel.png&quot; alt=&quot;google creatExcel&quot; title=&quot;google creatExcel&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/creatAppScript.png&quot; alt=&quot;google creatAppScript&quot; title=&quot;google creatAppScript&quot;&gt;&lt;/p&gt;
&lt;h3&gt;STEP.2 選擇剛剛創立的 google excel 網址參數&lt;/h3&gt;
&lt;p&gt;xxxxxxxxxxx/edit，/edit 前面這段參數
&lt;a href=&quot;https://docs.google.com...&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://docs.google.com...&lt;/a&gt;&lt;mark&gt;1JbXssixJaqTL_BMgnmOiMxLyAZm0jOkw173VdewqO9c1&lt;/mark&gt;/edit#gid=0&lt;/p&gt;
&lt;h3&gt;STEP.3 打開 AppScript 加上剛剛複製的編碼 以及 javascript&lt;/h3&gt;
&lt;p&gt;首先在 myFunction 上加入參數，因為之後要透過 call 這個 api 帶入資料，下面是預期會帶入的物件名稱 name、phone、time、order、price。這些都可以根據你想要帶的資料名稱變化，也可以刪減。&lt;/p&gt;
&lt;p&gt;後面是依靠 google sheet 的 method 來選取表單，後面貼上你剛剛 excel 的編碼，再來是用.getSheets()[0]來選取第 1 個工作表單。這樣就成功的選取到這整個 table 了。&lt;/p&gt;
&lt;p&gt;這邊先處理接到值傳進來先命名，再來選取你要填入的 google excel 編碼、excel tab。&lt;/p&gt;
&lt;p&gt;ps.這邊用的是 doGet function，代表這個 function 會被 api 的 Get 調用到，也可以用 doPost，但是你串接 api 就要改用 Post。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function doGet(e) {
  //接帶入值 轉為變數    - 可根據需求修改
  var params = e.parameter;
  var name = params.name;
  var phone = params.phone;
  var time = params.time;
  var order = params.order;
  var price = params.price;

  //這是選擇這個google excel
  var SpreadSheet = SpreadsheetApp.openById(&quot;貼上你剛剛複製的編碼&quot;);
  //取得 第一個表單
  var Sheet = SpreadSheet.getSheets()[0];

  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊比較搞剛的是要處理訂單編號，以便於日後我們比對資料方便，剩下最重要的塞剛剛帶進來的值。就完成的簡單的插入資料 function 了！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  ...
  //取得 LastRow = 有資料的最後一行的位置
  var LastRow = Sheet.getLastRow();


  // 這邊是處理訂單編號 - 我先選取 有資料最後一行 的 第6欄
  var range = Sheet.getRange(LastRow, 6);
  // 創立訂單編號  (最後一行的第六欄 +1)
  var orderNum = parseFloat(range.getValues())+1;
  //若最後一行是第1行 需要轉為訂單編號1
  if(LastRow == 1){
    orderNum = 1;
  }

  //開始寫入資料 同樣是 getRange 選擇 (行,欄) setValue 帶入值name phone time order price values進來
  Sheet.getRange(LastRow+1, 1).setValue(name);
  Sheet.getRange(LastRow+1, 2).setValue(phone);
  Sheet.getRange(LastRow+1, 3).setValue(time);
  Sheet.getRange(LastRow+1, 4).setValue(order);
  Sheet.getRange(LastRow+1, 5).setValue(price);
  Sheet.getRange(LastRow+1, 6).setValue(orderNum);

  //寫入結束後傳回true
  return ContentService.createTextOutput(true);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;STEP.4 建立 debug.gs 來測試剛剛的 建立資料&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//call
function debug() {
    var Result = doGet({
        parameter: {
            name: &apos;測試先生&apos;,
            phone: &apos;0912345678&apos;,
            time: &apos;2018/02/10 22:46:00&apos;,
            order: &apos;鹹酥雞 * 1&apos;,
            price: &apos;40&apos;
        }
    });
    Logger.log(&apos;Result: %s&apos;, Result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;STEP.5 編輯 允許權限&lt;/h3&gt;
&lt;p&gt;ㄧ路點選允許到底即可&lt;/p&gt;
&lt;p&gt;這邊需要點進階 前往 xxx 不安全
&lt;img src=&quot;../images/userright.png&quot; alt=&quot;google userright&quot; title=&quot;google userright&quot;&gt;
&lt;img src=&quot;../images/debugRun.png&quot; alt=&quot;debugRun&quot; title=&quot;debugRun&quot;&gt;&lt;/p&gt;
&lt;h3&gt;STEP.6 部署為網路應用程式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../images/deployAppScript.png&quot; alt=&quot;google deployAppScript&quot; title=&quot;google deployAppScript&quot;&gt;
&lt;img src=&quot;../images/adjustAppscript.png&quot; alt=&quot;adjustAppscript&quot; title=&quot;adjustAppscript&quot;&gt;
&lt;img src=&quot;../images/AppScriptapi.png&quot; alt=&quot;AppScriptapi&quot; title=&quot;AppScriptapi&quot;&gt;&lt;/p&gt;
&lt;p&gt;把上面的 URL 複製起來，這就是我們 API 的 URL。&lt;/p&gt;
&lt;h3&gt;STEP.7 建立 html 串接資料&lt;/h3&gt;
&lt;p&gt;快速簡單的建出了一個網頁，點擊下方的送出，然後 call send function 非同步送出資料，然後成功再回傳給使用者感謝，&lt;/p&gt;
&lt;p&gt;這個頁面的 javasctipt 都在處理 沒填寫資料要被擋，還有組出訂購的品量數量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;上半部為觸發call function
...
      var data = {
          &apos;name&apos; : name,
          &apos;phone&apos;:phone,
          &apos;time&apos;: filltime,
          &apos;order&apos;: order,
          &apos;price&apos;: price,
      }
      send(data)
    }
    function send(data){
      $.ajax({
        type: &quot;get&quot;,
        url: &quot;https://script.google.com/macros/s/AKfycbz3fU3FVDmIQehtWX6ecKuV_A67lE64FEQ-ekmOZ_jZDyY96z0/exec&quot;,
        data: data,
        dataType: &quot;JSON&quot;,
        success: function (response) {
          alert(&apos;感謝您的訂購！！&apos;);
        }
      });
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://work.ianccy.com/%E7%82%B8%E9%9B%9E%E8%A8%82%E8%B3%BC&quot; title=&quot;鹹酥雞訂購 範例網頁&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;鹹酥雞訂購 範例網頁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.google.com/spreadsheets/d/1JbXssixJaqTL_BMgnmOiMxLyAZm0jOkw173VdewqO9c/edit#gid=0&quot; title=&quot;鹹酥雞訂購 Excel&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;鹹酥雞訂購 Excel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Ianpig/work/blob/master/googleform.md&quot; title=&quot;google form api html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;詳細的 code HTML Javasctipt + Appscript code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;剩下部份就客戶讀取、取消訂單，最後連結是進階處理。&lt;/p&gt;
&lt;p&gt;總結一下步驟:
建立 excel、appscript -&gt; 編輯 appscript -&gt; 部署公開串接 -&gt; 網頁前端串接 api -&gt;&gt;&gt; over&lt;/p&gt;
&lt;h2&gt;使用心得&lt;/h2&gt;
&lt;p&gt;目前服務的公司也經常使用 google excel api，假設填表資料需要分享觀看、編輯，也不希望合作夥伴觀看公司後台，通常就會使用 google excel 來處理填表，優點就是創立非常快速、不需要後端幫忙，只要前端處理 css + html + javascript 大概 2 小時可以搞定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接續文章: &lt;a href=&quot;/googleformadv/&quot; title=&quot;客戶讀取、取消訂單&quot;&gt;客戶讀取、取消訂單&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[SEO優化 google教學guideline介紹]]></title><description><![CDATA[SEO 優化是什麼，SEO 是 Search Engine Optimization 的簡稱，中文叫做搜尋引擎優化，簡單講就是使用 google、yahoo、bing 等搜尋引擎搜尋時，網站能排在前面，更容易使用者被看到點擊。 SEO 跟大家常看到的 adword…]]></description><link>https://ianccy.com/2018-01-whatseo/</link><guid isPermaLink="false">https://ianccy.com/2018-01-whatseo/</guid><pubDate>Sun, 28 Jan 2018 14:45:21 GMT</pubDate><content:encoded>&lt;p&gt;SEO 優化是什麼，SEO 是 Search Engine Optimization 的簡稱，中文叫做搜尋引擎優化，簡單講就是使用 google、yahoo、bing 等搜尋引擎搜尋時，網站能排在前面，更容易使用者被看到點擊。&lt;/p&gt;
&lt;p&gt;SEO 跟大家常看到的 adword 關鍵字廣告是完全不同東西，adword 是可以依靠花錢就排在最前面，但 SEO 沒辦法 (這裡不提黑帽)，他只能透過各種方式來提升排名。長話短說就是你要讓你的網站夠好夠棒夠棒棒，讓這些搜尋引擎跑演算法的時候，權重分數夠高讓你排在上面。&lt;/p&gt;
&lt;!--- ![google search](../images/google_search.png &quot;google search&quot;) ---&gt;
&lt;p&gt;來簡單的介紹一些關於 google guildline 的部分內容。
(以下都針對 google)&lt;/p&gt;
&lt;h2&gt;SEO google 官方教學&lt;/h2&gt;
&lt;p&gt;看外面文章一百篇一千篇，不如先看這一個官方文件&lt;a href=&quot;https://support.google.com/webmasters/answer/7451184&quot; title=&quot;google seo guideline&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google seo guideline&lt;/a&gt;，裡面有最基礎重要的觀念。
(更詳細版本 &lt;a href=&quot;https://static.googleusercontent.com/media/www.google.cn/zh-TW/cn/intl/zh-TW/webmasters/docs/search-engine-optimization-starter-guide-zh-tw.pdf&quot; title=&quot;seo guide pdf&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;搜尋引擎最佳化初學者指南 - Google&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;下面介紹幾個重要的部分。&lt;/p&gt;
&lt;h3&gt;網站索引&lt;/h3&gt;
&lt;p&gt;你網站或新頁面做出來，要讓 google 知道並且被索引，才能在 google 搜尋的時候出現，如果沒索引出現機會是 0 啊，讓 google 索引有幾種方法，第一種是 sitemap，做出網站所有 url 的清單，讓 google 直接檢閱你的網站，提交地方在 google 網站管理員裡面的 sitemap 區塊。&lt;/p&gt;
&lt;p&gt;另外一個方法是 search suggest 手動一個一個 keyin 網址，大概一分鐘左右就會被索引了，最後就是依靠連結來索引，假設你的網址有分享連結到其他網站，當其他網站被爬的時候，透過連結也會順便索引你的網站。&lt;/p&gt;
&lt;p&gt;這需求容易發生在新官網剛上線時，搜尋品牌字可能一直都沒出現，老闆就開始靠北邊走 網站為啥沒出現啊？ 這時候記得提交網站吧。&lt;/p&gt;
&lt;br/&gt;
&lt;h2&gt;網站正確獨立標記&lt;/h2&gt;
&lt;p&gt;title 很重要、title 很重要、title 很重要，恩...過了這麼多年，一直都超級重要，每個 title 都要獨特不重複，讓 google 更懂你網頁的內容。&lt;/p&gt;
&lt;p&gt;另外不要以為你每頁都標同一個關鍵字就會有用(例如:馬克杯 - 高 CP 便宜 ptt 推薦送禮 後面當每頁標題)，會被當品牌字忽略掉，這頁內容再講什麼，當作大綱言之有物的來寫。&lt;/p&gt;
&lt;p&gt;至於 description 描述雖然並不列入排名要素，但它也很重要，搜尋的時候 可能 會照描述列出來，剩下的 meta og title image...等都是社群使用的標記，例如 line twitter facebook 用的，一樣也記得寫上。&lt;/p&gt;
&lt;p&gt;剩下還有網站語言標記 hreflang 的，就做好做滿吧。&lt;/p&gt;
&lt;p&gt;還有 google 這幾年推出的結構化標記，讓你的網站在搜尋結果能顯示不一樣的內容(評分、時間、價格等等)，要依 google 列出的產品分類&lt;a href=&quot;https://developers.google.com/search/docs/guides/search-gallery&quot; title=&quot;google search gallery&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google search gallery&lt;/a&gt;使用不同的標記，(兩年前剛推出我有用過螢光筆，恩...那時候是毫無反應，有空會在測試 json 標記看看。)&lt;/p&gt;
&lt;br/&gt;
&lt;h2&gt;針對內容優化&lt;/h2&gt;
&lt;p&gt;決定排名的是複雜的演算法，所以要讓程式容易辨認內容，你網頁要能被 google robot 爬到內容，盡量避免用 javascript 產生內容(要的話請用 SSR 或是 PSR)，不要整個網頁都用圖片，google 不會理你圖片裡面寫啥米(能爬得懂也不理)，記得要利用圖片搭上文字做定位排版。&lt;/p&gt;
&lt;p&gt;推薦使用 html5 的標籤，h1 nav section footer 等等，還有圖片、影片、連結都要確實加上 alt 介紹，圖片加上 alt 也可以在圖片搜尋時出現。&lt;/p&gt;
&lt;p&gt;剩下就是[優質]內容，我個人看法就是言之有物，不要標題打 最便宜 macbook，實際上點進來卻沒比較便宜。&lt;/p&gt;
&lt;p&gt;最重要的是不要複製貼上別人內容，這很重要，google 一直都很重視原創，假設你網站整個都是 copy 別人的內容，就算你網站上來了哪天還是會退到下面。&lt;/p&gt;
&lt;br/&gt;
&lt;h2&gt;rwd 手機版網頁&lt;/h2&gt;
&lt;p&gt;google 在 15 年 宣告手機版搜尋獨立計算排名，&lt;a href=&quot;https://webmaster-tcn.googleblog.com/2015/02/blog-post.html&quot; title=&quot;rwd announce&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;rwd 排名宣告&lt;/a&gt;，意味著網站要能兼容手機變得非常重要，手機版網頁有幾種實作，最簡單的是響應式設計，依靠 css media query 針對螢幕來變換寬度，另一種是手機版網頁，實際上存在兩個頁面，一個 for 桌機另一個 for mobile，這記得要互相宣告。&lt;/p&gt;
&lt;p&gt;方法如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//桌機版網頁標記
&amp;#x3C;link rel=&quot;alternate&quot; media=&quot;only screen and (max-width: 640px)&quot;  href=&quot;http://手機版URL&quot;&gt;
//行動版網頁
&amp;#x3C;link rel=&quot;canonical&quot; href=&quot;http://桌機版URL&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;製作網頁記得要同時製作好手機版，現在使用者使用手機比重已超過桌機一半以上，沒做手機版等於流量少了一半。&lt;/p&gt;
&lt;br/&gt;
&lt;h2&gt;網站速度&lt;/h2&gt;
&lt;p&gt;google 最近宣布，要將網站速度加入手機排名要素&lt;a href=&quot;https://webmasters.googleblog.com/2018/01/using-page-speed-in-mobile-search.html&quot; title=&quot;mobile speed google ranking&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;手機排名速度列素計算&lt;/a&gt;，不過說實在，網站載入速度本來就很重要了，通常影響最大應該就 hosting、網站圖片影片，記得主機商不要買太遠的，或一天到晚掛掉的，圖片影片記得要壓縮過或用 cdn，我曾經放過一堆 1.5M 的圖片，載入過程整個像幻燈片一樣卡。&lt;/p&gt;
&lt;p&gt;假設你網站載入過慢，就去請教工程師遇到哪些問題，或是利用 google 的工具，跑完檢測後去針對問題修改。&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;實際上要完全符合 google 建議，還滿需要網頁工程師的幫忙，有些東西是蠻細枝末節，例如圖片要加上 alt 拉，有些是會影響開發流程或是壓縮圖片、css、js 等，因為一些團隊因素，我也沒壓縮 css、js。&lt;/p&gt;
&lt;p&gt;寫上正確的標題、描述，這對技術來說滿困擾的，文案專業的還是行銷大大啊，今天同樣活動頁面工程師可能 title 只會打上 (優惠券抽獎 - xxx)，行銷可能就 (限時限量 5 折優惠券，要搶要快 - xxx)，title 會大大影響 seo 排名啊，這在公司常常被忽略掉。網站上線 enginer 也不一定會提交網頁。&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;以前當行銷時，還用過一些方式快速衝排名，利用 facebook 社團分享來炸流量，排名瞬間撐到前面，不過前年用這方法已無感，還是先好好處理好網站架構、內容最實在。&lt;/p&gt;
&lt;p&gt;假設是要做內容行銷，記得利用 adword 內的關鍵字規劃工具，來判斷使用者都搜尋哪些關鍵字，記得『沒有需求就沒有流量』。&lt;/p&gt;
&lt;br/&gt;
&lt;h2&gt;SEO 實用工具&lt;/h2&gt;
&lt;p&gt; 最後來介紹一些好用的工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;google analytics&lt;/p&gt;
&lt;p&gt;必裝工具之一，做網站最基本的 ga，觀看整體流量，超重要超重要。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;google webmaster&lt;/p&gt;
&lt;p&gt;必裝工具之二，裡面功能都可以直接影響 google robot，或網站搜尋相關設定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;紀錄排名的工具 &lt;a href=&quot;http://myrankaware.com/&quot; title=&quot;rankware&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;rankaware&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;實用工具，讓你輸入需要追蹤的關鍵字，會自動爬出排名。rankaware 有缺點，是用你 ip 爬，太頻繁搜尋會被 google block，所以無法一次爬完所有關鍵字，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;線上壓縮圖片網站 &lt;a href=&quot;http://optimizilla.com/&quot; title=&quot;優化圖片&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;optimizilla&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前用過，唯一壓縮圖片可以過關(google 檢查網頁)的工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;adword 關鍵字規劃&lt;/p&gt;
&lt;p&gt;輸入關鍵字規劃，看出最近使用者搜尋次數。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.com/speed/pagespeed/insights/&quot; title=&quot;google pagespeed&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google pagespeed tool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;檢核網站速度 google 的線上工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://search.google.com/test/mobile-friendly&quot; title=&quot;mobile-friendly&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;mobile-friendly&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;檢核網站是否符合 mobile friendly。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---以下台灣本土工具---
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.awoo.org/intro/poa&quot; title=&quot;awoo球來就打&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;awoo 球來就打&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;檢查網頁需要修正的部分，可免費試用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://seo-rank.tw/&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;seo tw&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;追蹤關鍵字的工具，每天有免費使用額度，會自動換 ip 爬完全部。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最後推薦你看 google webmaster 官方 youtube 直播，會有 google 官方人員線上問答，大概時間都是台灣晚上，雖然是全英文，但其實用詞差不多，除非是印度人講話...。&lt;/p&gt;
&lt;p&gt;另外可以追蹤官方的 blog - &lt;a href=&quot;https://webmasters.googleblog.com/&quot; title=&quot;google wemaster blog&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;webmaster blog&lt;/a&gt;，通常會有最快的消息公告。&lt;/p&gt;
&lt;p&gt;還有更多包括 301 轉址、不同網址重複內容處理、cache 設定、ajax 處理爬蟲等等等等等。就先不在這篇介紹，有興趣可以自己先 google 哩。&lt;/p&gt;
&lt;br/&gt;
&lt;h2&gt;SEO 工作感想&lt;/h2&gt;
&lt;p&gt;做 seo 一兩年的感想就是，當你執行的網頁，沒爬到第一頁、或前幾名，都是你得問題，有做到就是好棒棒，殊不知要做到前幾名背後付出多少血淚。做到第一名，更要花時間去維持排名。&lt;/p&gt;
&lt;p&gt;假設你還沒做出成績還菜菜得，拿著這些文件找工程師討論，工程師也不太會理你，還覺得你找麻煩。做 seo 就是一場戰爭啊。&lt;/p&gt;
&lt;p&gt;也許是之前待小公司，常讓我覺得 seo 是不被重視，好不容易做出成績，公司好像也覺得 恩...很好很好，然後大家回頭繼續做原本事情。然後就結束了...，沒有很珍惜這些成長兩三倍的流量啊。&lt;/p&gt;
&lt;p&gt;(以上抱怨中)&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;真的看完上面一大串內容，就先感謝你了！&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Javascript Array sort 陣列排序分類處理]]></title><description><![CDATA[javascript 在實務上最常用 array 處理多筆資料，因為彈性大好運用，不論在 api 取資料、cookie、local storage 等，幾乎的用的到。 這邊介紹 Array sort…]]></description><link>https://ianccy.com/2017-12-arrayhandle/</link><guid isPermaLink="false">https://ianccy.com/2017-12-arrayhandle/</guid><pubDate>Sat, 16 Dec 2017 17:42:18 GMT</pubDate><content:encoded>&lt;p&gt;javascript 在實務上最常用 array 處理多筆資料，因為彈性大好運用，不論在 api 取資料、cookie、local storage 等，幾乎的用的到。&lt;/p&gt;
&lt;p&gt;這邊介紹 Array sort，現代網頁技術快速發展，前端經常要用到非同步來取得資料，拿到的陣列資料，經常會需要排序功能，ie.價格排序、新舊排序、同類型排序等。&lt;/p&gt;
&lt;!--- ![JavaScript](../images/JavaScript-logo.png &quot;JavaScript&quot;) ---&gt;
&lt;h2&gt;Array sort 陣列概念&lt;/h2&gt;
&lt;p&gt;根據 w3c 介紹 array.sort(compareFunction)，參數依照需求帶入不同，另外直接改變陣列資料。&lt;/p&gt;
&lt;p&gt;sort 會對陣列跑兩個數跑比對條件。例如下面範例第一次會 a 參數會是 Arr[0]、b 是 Arr[1]，然後 return a.price-b.price 回傳正數或負數或 0，再依據回傳數值調換位置，左至右重複跑到完全符合條件的順序。這就是 sort 執行的方式。&lt;/p&gt;
&lt;p&gt;題外話下面 sort 內的 function 則是跑了 9 次。&lt;/p&gt;
&lt;p&gt;ps.return 小於 0 將 a 放在左邊 b 在右邊、&lt;br/&gt;
大於 0 將 a 放在右邊 b 在左邊、&lt;br/&gt;
等於 0 不變更位置。&lt;/p&gt;
&lt;h2&gt;Array sort 範例&lt;/h2&gt;
&lt;p&gt;針對 price 數字 陣列排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let Arr = [
    { name: &apos;apple&apos;, price: 50 },
    { name: &apos;watermelon&apos;, price: 30 },
    { name: &apos;mango&apos;, price: 90 },
    { name: &apos;banana&apos;, price: 10 },
    { name: &apos;peer&apos;, price: 10 }
];
let times = 0;
Arr.sort(function(a, b) {
    times++; // 紀錄跑幾次
    return a.price - b.price;
}); //會針對陣列跑回圈比對
console.log(Arr);
// [{name: &quot;banana&quot;, price: 10},
// {name: &quot;peer&quot;, price: 20}
// ......
// {name: &quot;mango&quot;, price: 90}]
console.log(times); // 9次
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;針對字串 name 陣列排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let Arr = [
    { name: &apos;apple&apos;, price: 50 },
    { name: &apos;watermelon&apos;, price: 30 },
    { name: &apos;mango&apos;, price: 90 },
    { name: &apos;banana&apos;, price: 10 },
    { name: &apos;peer&apos;, price: 10 }
];
Arr.sort(function(a, b) {
    if (a.name &gt; b.name) {
        return 1; //a 往右 b往左
    } else if (a.name &amp;#x3C; b.name) {
        return -1; //a 往左 b往右
    } else {
        return 0; // 不變順序
    }
});
console.log(Arr);
// [{name: &quot;apple&quot;, price: 50},
// ......
// {name: &quot;watermelon&quot;, price: 30}]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上就是 javascript sort 的排序，如果不希望重新要資料，前端是可以用這方法處理排序，如果不是上萬筆的話，是可以來用用 client 端效能。&lt;/p&gt;
&lt;p&gt;建議實際跑一次 sort function，用 chrome debug 來看看到底葫蘆裡再跑啥米東西。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Google Map marker cluster 標記使用教學]]></title><description><![CDATA[大家好我是 Ian，目前是負責網頁前端，每天工作都在處理各種問題(pm 奇形需求)，順便分享一些相關的解法。
最近剛好專注在 google map 工具的使用，需要將大量的資料撒上 google map，資料也帶滿多資訊，讓 user 點擊 marker…]]></description><link>https://ianccy.com/2017-12-mapcluster/</link><guid isPermaLink="false">https://ianccy.com/2017-12-mapcluster/</guid><pubDate>Mon, 11 Dec 2017 23:53:19 GMT</pubDate><content:encoded>&lt;p&gt;大家好我是 Ian，目前是負責網頁前端，每天工作都在處理各種問題&lt;del&gt;(pm 奇形需求)&lt;/del&gt;，順便分享一些相關的解法。
最近剛好專注在 google map 工具的使用，需要將大量的資料撒上 google map，資料也帶滿多資訊，讓 user 點擊 marker 在拉開 infowindow，又嫌太慢。於是開始研究 marker group 概念的工具，也發現關於 marker library 中文的文件比較少一點，所以就順手寫了 marker 延伸使用範例，也可以直接點開範例看 code。&lt;/p&gt;
&lt;p&gt;分為內建 google map 工具操作，還有運用 google map 團隊所開發的工具，達到更多的功能。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;google map 搭配內建 marker infowindow&lt;/h2&gt;
&lt;p&gt;首先先運用比較常用到的功能，google map 下多個 marker，再搭配 marker 的 event 來互動，以下是打開 infowindow 的運用。&lt;/p&gt;
&lt;p&gt;簡單創建多筆經緯度資料，呈現的是搭計程車到地點的價格。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//我只標出比較重要部分，其他就codepen點開來看唄
var marker = new google.maps.Marker({
    position: { lat: item.lat, lng: item.lng },
    map: map,
    title: item.name,
    icon: image,
    data: &apos;Go to &apos; + item.name + &apos;&amp;#x3C;br/&gt; Taxi price: &apos; + item.price
});
marker.addListener(&apos;click&apos;, function() {
    infowindow.setContent(this.data);
    infowindow.open(map, this);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比較特別的是這個寫法，在每個 marker 加入 data 物件，讓 marker 延伸操作性。&lt;br&gt;
以下圖片實際呼叫 marker 所印出來的資料，可以看到畫線處，出現我們剛剛加入的 data，這樣你就可以利用 marker 來帶一些資料，例如說點擊 marker 可以 call function 然後帶互動，這方法變得方便又輕巧。
ps.可以利用指定某個 marker markerArr[i].setOptions({data=&quot;/change/image&quot;})變換 marker 資料。&lt;/p&gt;
&lt;!--- ![google map marker console](../images/markerconsole.png &quot;google map marker console&quot;) ---&gt;
&lt;h2&gt;實際運作範例 infowindow&lt;/h2&gt;
&lt;iframe height=&apos;360&apos; scrolling=&apos;no&apos; title=&apos;Multipel google map marker with info (basic)&apos; src=&apos;//codepen.io/chu1228/embed/rpNzBb/?height=360&amp;theme-id=light&amp;default-tab=result&amp;embed-version=2&apos; frameborder=&apos;no&apos; allowtransparency=&apos;true&apos; allowfullscreen=&apos;true&apos; style=&apos;width: 100%;&apos;&gt;See the Pen &lt;a href=&apos;https://codepen.io/chu1228/pen/rpNzBb/&apos;&gt;Multipel google map marker with info (basic)&lt;/a&gt; by ianchu (&lt;a href=&apos;https://codepen.io/chu1228&apos;&gt;@chu1228&lt;/a&gt;) on &lt;a href=&apos;https://codepen.io&apos;&gt;CodePen&lt;/a&gt;.
&lt;/iframe&gt;
&lt;br&gt;
&lt;h2&gt;google map 運用 library&lt;/h2&gt;
&lt;p&gt;感謝 google 大大，其實 googlemap 官方 github 有整理滿多 library &lt;a href=&quot;https://github.com/googlemaps/v3-utility-library&quot; title=&quot;google map library&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;google map library&lt;/a&gt;，建議下載使用，因為滿多工具 demo 頁面都呈現 404...。&lt;/p&gt;
&lt;p&gt;這邊要用的是&lt;a href=&quot;https://github.com/googlemaps/v3-utility-library/tree/master/markerwithlabel&quot; title=&quot;google map library&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;markerwithlabel&lt;/a&gt; 還有 &lt;a href=&quot;https://github.com/googlemaps/v3-utility-library/tree/master/markerclusterer&quot; title=&quot;google map library&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;markercluster&lt;/a&gt;這兩個 library，markerwithlabel 讓我們更簡單設計不同的 marker，例如讓他帶自訂的 image，再來是重點 markercluster，它讓我們可以解決 marker 過多，同時重疊的問題。&lt;/p&gt;
&lt;p&gt;首先處理單一個 marker 用的是 MarkerWithLabel，原本呼叫 google.maps.Marker 改成 MarkerWithLabel，然後就搞定了，非常快速簡單，他可以用的 event 滿多的，基本上都可以處理 marker 的互動，甚至也可以像一般的 marker 設定物件上去。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//更多變數請點選說明文件，基本上可以用class 搭配 css操作，或是labelStyle 處理icon style
var marker = new MarkerWithLabel({
    draggable: false,
    raiseOnDrag: false,
    map: map,
    labelContent: &apos;&amp;#x3C;span&gt;&apos; + item.name + &apos;&amp;#x3C;br/&gt;&apos; + item.price + &apos;&amp;#x3C;/span&gt;&apos;,
    labelAnchor: new google.maps.Point(40, 32),
    labelClass: &apos;labels&apos;, // the CSS class for the label
    labelStyle: { opacity: 1 },
    position: { lat: item.lat, lng: item.lng },
    data: &apos;Go to &apos; + item.name + &apos;&amp;#x3C;br/&gt; Taxi price: &apos; + item.price
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;實際範例 markerwithlabel&lt;/h2&gt;
&lt;p data-height=&quot;259&quot; data-theme-id=&quot;light&quot; data-slug-hash=&quot;eyYVJz&quot; data-default-tab=&quot;result&quot; data-user=&quot;chu1228&quot; data-embed-version=&quot;2&quot; data-pen-title=&quot;google map marker cluster (markercluster &amp; markerlabel)&quot; class=&quot;codepen&quot;&gt;See the Pen &lt;a href=&quot;https://codepen.io/chu1228/pen/eyYVJz/&quot;&gt;google map marker cluster (markercluster &amp; markerlabel)&lt;/a&gt; by ianchu (&lt;a href=&quot;https://codepen.io/chu1228&quot;&gt;@chu1228&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;script async src=&quot;https://production-assets.codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt;
&lt;p&gt;最後是使用 markercluster 工具，這工具目前還有另一版 markerclusterplus，這邊就只用來一般版來操作。&lt;/p&gt;
&lt;p&gt;markercluster 主要是處理 marker 下完後，call function 渲染畫面，快速的判斷每個 marker 之間是否接近到某個程度，在創造出屬性這區塊的聚合 marker，簡單的就是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;下 marker -&gt; markerArr.markercluster({})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立 Cluster 的方法，這個版本無法帶入 className，需要打開.js 檔案，直接在 style.push 區塊修改，我這邊有修改 background-repeat:no-repeat。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//arr 是剛剛marker的 array 需要建立帶入 其餘是內建option
markerCluster = new MarkerClusterer(map, arr, {
    gridSize: 50,
    maxZoom: 15,
    zoomOnClick: true,
    styles: imgArr,
    imagePath: &apos;https://googlemaps.github.io/js-marker-clusterer/images/m&apos;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊是客製化 Cluster icon 的方法，這個 function 會抓到這個建立中的 cluster 內包含的 marker，會用陣列帶進來，這時候我們就跑迴圈，將 marker 內的資料帶出來，在看你想呈現的方式處理，我這邊是計算裡面的平均價格（這範例下方有 click event 寫法，不過我直接寫進 codepen 導致跑不動)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 稍微修改 cluster.js的檔案  讓聚合變得更客製化
MarkerClusterer.prototype.calculator_ = function(markers, numStyles) {
    //省略
    var price = 0;
    for (var i = 0; i &amp;#x3C; markers.length; i++) {
        price += Number(markers[i].dataPrice);
    }
    price = Math.floor(price / count);
    //省略
    return {
        text: count + &apos; 筆&amp;#x3C;br/&gt;A. NT&apos; + price,
        index: index
    };
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;實際範例 markercluster&lt;/h2&gt;
&lt;iframe height=&apos;350&apos; scrolling=&apos;no&apos; title=&apos;google map marker cluster (markercluster &amp; markerlabel)&apos; src=&apos;//codepen.io/chu1228/embed/opgwQK/?height=313&amp;theme-id=light&amp;default-tab=result&amp;embed-version=2&apos; frameborder=&apos;no&apos; allowtransparency=&apos;true&apos; allowfullscreen=&apos;true&apos; style=&apos;width: 100%;&apos;&gt;See the Pen &lt;a href=&apos;https://codepen.io/chu1228/pen/opgwQK/&apos;&gt;google map marker cluster (markercluster &amp; markerlabel)&lt;/a&gt; by ianchu (&lt;a href=&apos;https://codepen.io/chu1228&apos;&gt;@chu1228&lt;/a&gt;) on &lt;a href=&apos;https://codepen.io&apos;&gt;CodePen&lt;/a&gt;.
&lt;/iframe&gt;
&lt;p&gt;上面簡單講解一下 google map marker 過多的處理方法，沒想到最麻煩的是寫範例＋建立假資料最耗時間，快寫完剛好看到更新版的...&lt;a href=&quot;https://gmaps-marker-clusterer.github.io/gmaps-marker-clusterer/index.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;最新版更新&lt;/a&gt;（os:...，為啥跟 github 版本差那麼多...)，
大家可以直接試用看看，看介紹貌似支援 call option 直接修改 icon 還有增加 className，能直接略過我上面硬改 cluster.js 這段是最好，畢竟改 plugin 缺乏前端最重要的沿用性。&lt;/p&gt;
&lt;p&gt;感謝大家閱讀！！希望能解決 google map 麻煩的 marker 問題，
一起來讓 google map 好用一點點點點點點點 XD。&lt;/p&gt;</content:encoded></item></channel></rss>