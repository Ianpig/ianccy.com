{"componentChunkName":"component---src-templates-blog-post-js","path":"/reduxdispatch/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"5fd0f9ef-def8-5b95-9be4-d20722eddeac","fields":{"slug":"/2019-11-reduxdispatch/"},"headings":[{"value":"redux batch","id":"redux-batch","depth":2},{"value":"redux thunk","id":"redux-thunk","depth":2}],"excerpt":"redux 核心更新 flow dispatch action => reducer => store，當你用 redux 運行多個 dispatch 時，每一個 dispatch 都會獨立更新下去的，這代表著你會 update component…","html":"<p>redux 核心更新 flow <code>dispatch action => reducer => store</code>，當你用 redux 運行多個 dispatch 時，每一個 dispatch 都會獨立更新下去的，這代表著你會 update component 多次，如果你的更新資料又彼此關聯，就可能會發生錯誤。</p>\n<p>目前執行的專案，資料都是 linked list，若沒有注意好 dispatch 更新執行順序的話，時常會遇到問題。</p>\n<!--- ![redux-dispatch](../images/redux-dispatch.png \"redux-dispatch\") --->\n<ul>\n<li>多個 dispatch 更新</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">function initINFO (){\n  fetch(`API_URL/getCommentList`)\n    .then(res =&gt; res.json)\n    .then(data =&gt;\n      // if ADD_USERCOMMENT update component\n      // and it depends userInfo data\n      // component maybe happen error\n      dispatch({type: ADD_USERCOMMENT, payload: data.list})\n      if (data.userInfo) {\n        dispatch({type: INIT_INFO, payload: data.userInfo})\n      }\n    )\n    .catch(err =&gt; showError(err))\n}</code>\n        </deckgo-highlight-code>\n<p>處理的做法就是直接封裝整個 dispatch，讓每個 dispatch 都先不要往下執行 update component。</p>\n<h2 id=\"redux-batch\" style=\"position:relative;\"><a href=\"#redux-batch\" aria-label=\"redux batch permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>redux batch</h2>\n<p>react redux v7 有提供 batch，讓我們能直接封裝多個 dispatch，這是依賴 react 的 unstable<em>batchedUpdate，讓 rerender 這件事情能夠被卡住，react 實現方法大致上就是用 shouldBatchUpdates 變數搭配 fiber schedule 來判斷更新，讓更新這件事變成同步，詳細可直接看下方 react unstable</em>batchedUpdates source code。</p>\n<ul>\n<li>batch 使用方法</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import { batch } from &#39;react-redux&#39;;\nfunction myThunk() {\n    return (dispatch, getState) =&gt; {\n        // should only result in one combined re-render, not two\n        batch(() =&gt; {\n            dispatch(increment());\n            dispatch(increment());\n        });\n    };\n}</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://github.com/reduxjs/redux/blob/a5739d9455afbed663a4ca1fcac002988c885fcb/docs/faq/Performance.md#how-can-i-reduce-the-number-of-store-update-events\" title=\"react redux github batch Q&#x26;A\">react redux github batch Q&#x26;A</a></p>\n<p><a href=\"https://github.com/facebook/react/commit/b41883fc708cd24d77dcaa767cde814b50b457fe\" title=\"react unstable_batchedUpdates source code\">react unstable_batchedUpdates source code</a></p>\n<h2 id=\"redux-thunk\" style=\"position:relative;\"><a href=\"#redux-thunk\" aria-label=\"redux thunk permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>redux thunk</h2>\n<p>redux thunk 同樣可以幫助我們處理多個 dispatch，但是與 batch 原理不大相同，redux thunk，是將 dispatch 往後延遲到最後一次執行。</p>\n<p>乍聽之下可能覺得這有點魔幻，但我貼上 redux thunk 的介紹你一定會恍然大悟。redux thunk 就是將 dispatch 封裝起來在最後一次真正執行 store.dispatch，所以你就只會觸發一次的 redux store update，進而達到只 rerender 一次。</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// calculation of 1 + 2 is immediate\n// x === 3\nlet x = 1 + 2;\n\n// calculation of 1 + 2 is delayed\n// foo can be called later to perform the calculation\n// foo is a thunk!\nlet foo = () =&gt; 1 + 2;</code>\n        </deckgo-highlight-code>\n<ul>\n<li>what is thunk</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// calculation of 1 + 2 is immediate\n// x === 3\nlet x = 1 + 2;\n\n// calculation of 1 + 2 is delayed\n// foo can be called later to perform the calculation\n// foo is a thunk!\nlet foo = () =&gt; 1 + 2;</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Add thunk on redux middleWare</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import { createStore, applyMiddleware } from &#39;redux&#39;;\nimport thunk from &#39;redux-thunk&#39;;\nimport reducers from &#39;../redux/reducers&#39;;\n\nconst store = createStore(reducers, applyMiddleware(thunk));\n\nfunction fetchUser(data) {\n    return (dispatch, getState) =&gt; {\n        dispatch({ type: ADD_USERCOMMENT, payload: data.list });\n        if (data.userInfo) {\n            dispatch({ type: INIT_INFO, payload: data.userInfo });\n        }\n    };\n}</code>\n        </deckgo-highlight-code>\n<p>extraArgument 不用理會，這是新功能讓使用者客製化增加 thunk 的參數，action 會是我們傳入的 action creator，當 action creator 是一個 function，就執行 action creator function，如果不是就執行 next 帶入 action creator，正常的執行 dispatch。</p>\n<p><a href=\"https://redux.js.org/api/applymiddleware\" title=\"redux applymiddleware\">redux applymiddleware</a></p>\n<ul>\n<li>thunk source code</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">function createThunkMiddleware(extraArgument) {\n    return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {\n        if (typeof action === &#39;function&#39;) {\n            return action(dispatch, getState, extraArgument);\n        }\n\n        return next(action);\n    };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://github.com/reduxjs/redux-thunk/blob/master/src/index.js\" title=\"redux thunk\">redux thunk</a></p>\n<ul>\n<li>舊版 applyMiddleWare (github 只剩 typescript…)</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// middlewares argument is pass thunk\nexport default function(...middlewares) {\n    return createStore =&gt; (reducers, initialState, enhancer) =&gt; {\n        const store = createStore(reducers, initialState, enhancer);\n        const dispatch = store.dispatch;\n        const chain = [];\n        const middleWareAPI = {\n            getState: store.getState,\n            dispatch: action =&gt; dispatch(action)\n        };\n\n        chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));\n        dispatch = compose(...chain)(store.dispatch); // store.dispatch or dispatch both work\n        // compose will do following thing:\n        /*\n         * a, b, c ==&gt; a(b(c())), indeed, it is just a reduce and store.dispatch will be an initial value\n         */\n        return {\n            ...store,\n            dispatch\n        };\n    };\n}</code>\n        </deckgo-highlight-code>\n<p>redux thunk code 很優美，完美的示範如何使用 redux 的 middleWare，邏輯清楚又不複雜。我一定不會說這篇文章是為了分享 redux thunk。</p>\n<p>改天再來研究、分享更優美的 redux。</p>\n<p>這兩個方法 <code>batch</code>、<code>redux thunk</code> 都是目前專案都有用到的方法，至於其他就改天再另外介紹。 batch 因為與 react fiber 更新 component 機制有關，這部分較複雜，我對這塊沒有特別研究…，無法提供太多看法。</p>\n<p>感謝閱讀，以上有錯誤再麻煩留言或私訊。</p>","frontmatter":{"title":"Redux multiple dispatch，batch redux-thunk","date":"November 30, 2019","description":"redux 核心流程 dispatch action => reducer => store，當你用 redux 運行多個 dispatch 時，每一個 dispatch 都會獨立更新下去的，如果你的更新資料又彼此關聯，就可能會發生錯誤。","categories":"javascript","tags":["react.js"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACeElEQVQozz2S61MSYRjF919qbKzUyiy1xGLS8lYKiiAgLggsFwnjIle5CHITUBERQapxcsbpZlNTTjP9U6fDfujDmWdnd57fe87ZV+h9tYZbr0XcXbJjgLqnkfDI+EbW6OomJl3b0EUrsOea2Np/D40/i361FXfmzeidM6Fn2oAbU3rcnDFyrkDoX7RhgLqvdWJQ58JD/QYei36MWbYwbg1h1rsDbawKR7EFMV7GrCOCwWUHBggd5E7fgkUGd431ECr8Bxk8hHkwYnpLWBBKKYZntjCeEPzSk8JSuARDrIJFbwrDK24mkpjAiwfcvU23/ap19FHCEB0NG70EbWLM7IeCgKe2CNSBHPY/XmGz3EKqeYHAfge+Shszzijm3HFMbySgtIWgZIo+tU2uoVuXMEpHCoK6zkbWfISFMU7glCcNabcBX7UD/8E7ebrzDTwnxBQrw1NoYsIZh9IelXeH6LpblzDOeApLALpwAWKyChVLl7J16OMVrCYPsBwtQ8ufIuUa0BNkSR0iQPh24wKu/AmWQiWog0WZoaQZYdIRlbvqRjq4+I7s2SXK599w/OkXGp9/o3h+hVTrEqdfr3Hy5RoffvxF5+oPmvxev/wJd6mNOV+OwCBeSBEIs54kZHnTWPDvQhXMYyFYoLtDGBJUsgYjn1dTNbhKZ7CzBnO6xhTHsltnoQV7viWbUvB2CCpfBosEaQhaDhWhi+zBsF2FiYC19BHEnbosK++ha68DG4FWVuLMncCcqEKzVeTBNd7XBLr1CbowX8T2YGRnRoJEnirSgSVzjPVsAzYuWilHsQ2pcIr1TB0uzi7QkTmClkZWaGLen8OEI4Z/6QroMnomXWYAAAAASUVORK5CYII=","aspectRatio":2.073170731707317,"src":"/static/98774fcb9185ece7c2ac182e96d70db5/ee604/redux-dispatch.png","srcSet":"/static/98774fcb9185ece7c2ac182e96d70db5/c972b/redux-dispatch.png 340w,\n/static/98774fcb9185ece7c2ac182e96d70db5/27625/redux-dispatch.png 680w,\n/static/98774fcb9185ece7c2ac182e96d70db5/ee604/redux-dispatch.png 800w","sizes":"(max-width: 800px) 100vw, 800px"}}}},"timeToRead":4,"parent":{"__typename":"File","modifiedTime":"2021-05-16T08:19:40.155Z"}}},"pageContext":{"slug":"/2019-11-reduxdispatch/","previous":{"fields":{"slug":"/2019-09-jestunit/"},"frontmatter":{"title":"React Unit Test with Jest 單元測試","tags":["react.js","testing"]}},"next":{"fields":{"slug":"/2019-12-iframeblockcookie/"},"frontmatter":{"title":"阻擋第三方(Block third-party) Cookie，各瀏覽器狀態","tags":["javascript"]}}}},"staticQueryHashes":["1481458783","63159454"]}