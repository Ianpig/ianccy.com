{"componentChunkName":"component---src-templates-blog-post-js","path":"/reduxdispatch/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"5fd0f9ef-def8-5b95-9be4-d20722eddeac","fields":{"slug":"/2019-11-reduxdispatch/"},"headings":[{"value":"redux batch","id":null,"depth":2},{"value":"redux thunk","id":null,"depth":2}],"excerpt":"redux 核心更新 flow dispatch action => reducer => store，當你用 redux 運行多個 dispatch 時，每一個 dispatch 都會獨立更新下去的，這代表著你會 update component…","html":"<p>redux 核心更新 flow <code>dispatch action => reducer => store</code>，當你用 redux 運行多個 dispatch 時，每一個 dispatch 都會獨立更新下去的，這代表著你會 update component 多次，如果你的更新資料又彼此關聯，就可能會發生錯誤。</p>\n<p>目前執行的專案，資料都是 linked list，若沒有注意好 dispatch 更新執行順序的話，時常會遇到問題。</p>\n<!--- ![redux-dispatch](../images/redux-dispatch.png \"redux-dispatch\") --->\n<ul>\n<li>多個 dispatch 更新</li>\n</ul>\n<pre><code class=\"language-javascript\">function initINFO (){\n  fetch(`API_URL/getCommentList`)\n    .then(res => res.json)\n    .then(data =>\n      // if ADD_USERCOMMENT update component\n      // and it depends userInfo data\n      // component maybe happen error\n      dispatch({type: ADD_USERCOMMENT, payload: data.list})\n      if (data.userInfo) {\n        dispatch({type: INIT_INFO, payload: data.userInfo})\n      }\n    )\n    .catch(err => showError(err))\n}\n</code></pre>\n<p>處理的做法就是直接封裝整個 dispatch，讓每個 dispatch 都先不要往下執行 update component。</p>\n<h2>redux batch</h2>\n<p>react redux v7 有提供 batch，讓我們能直接封裝多個 dispatch，這是依賴 react 的 unstable<em>batchedUpdate，讓 rerender 這件事情能夠被卡住，react 實現方法大致上就是用 shouldBatchUpdates 變數搭配 fiber schedule 來判斷更新，讓更新這件事變成同步，詳細可直接看下方 react unstable</em>batchedUpdates source code。</p>\n<ul>\n<li>batch 使用方法</li>\n</ul>\n<pre><code class=\"language-javascript\">import { batch } from 'react-redux';\nfunction myThunk() {\n    return (dispatch, getState) => {\n        // should only result in one combined re-render, not two\n        batch(() => {\n            dispatch(increment());\n            dispatch(increment());\n        });\n    };\n}\n</code></pre>\n<p><a href=\"https://github.com/reduxjs/redux/blob/a5739d9455afbed663a4ca1fcac002988c885fcb/docs/faq/Performance.md#how-can-i-reduce-the-number-of-store-update-events\" title=\"react redux github batch Q&#x26;A\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">react redux github batch Q&#x26;A</a></p>\n<p><a href=\"https://github.com/facebook/react/commit/b41883fc708cd24d77dcaa767cde814b50b457fe\" title=\"react unstable_batchedUpdates source code\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">react unstable_batchedUpdates source code</a></p>\n<h2>redux thunk</h2>\n<p>redux thunk 同樣可以幫助我們處理多個 dispatch，但是與 batch 原理不大相同，redux thunk，是將 dispatch 往後延遲到最後一次執行。</p>\n<p>乍聽之下可能覺得這有點魔幻，但我貼上 redux thunk 的介紹你一定會恍然大悟。redux thunk 就是將 dispatch 封裝起來在最後一次真正執行 store.dispatch，所以你就只會觸發一次的 redux store update，進而達到只 rerender 一次。</p>\n<pre><code class=\"language-javascript\">// calculation of 1 + 2 is immediate\n// x === 3\nlet x = 1 + 2;\n\n// calculation of 1 + 2 is delayed\n// foo can be called later to perform the calculation\n// foo is a thunk!\nlet foo = () => 1 + 2;\n</code></pre>\n<ul>\n<li>what is thunk</li>\n</ul>\n<pre><code class=\"language-javascript\">// calculation of 1 + 2 is immediate\n// x === 3\nlet x = 1 + 2;\n\n// calculation of 1 + 2 is delayed\n// foo can be called later to perform the calculation\n// foo is a thunk!\nlet foo = () => 1 + 2;\n</code></pre>\n<ul>\n<li>Add thunk on redux middleWare</li>\n</ul>\n<pre><code class=\"language-javascript\">import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport reducers from '../redux/reducers';\n\nconst store = createStore(reducers, applyMiddleware(thunk));\n\nfunction fetchUser(data) {\n    return (dispatch, getState) => {\n        dispatch({ type: ADD_USERCOMMENT, payload: data.list });\n        if (data.userInfo) {\n            dispatch({ type: INIT_INFO, payload: data.userInfo });\n        }\n    };\n}\n</code></pre>\n<p>extraArgument 不用理會，這是新功能讓使用者客製化增加 thunk 的參數，action 會是我們傳入的 action creator，當 action creator 是一個 function，就執行 action creator function，如果不是就執行 next 帶入 action creator，正常的執行 dispatch。</p>\n<p><a href=\"https://redux.js.org/api/applymiddleware\" title=\"redux applymiddleware\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">redux applymiddleware</a></p>\n<ul>\n<li>thunk source code</li>\n</ul>\n<pre><code class=\"language-javascript\">function createThunkMiddleware(extraArgument) {\n    return ({ dispatch, getState }) => next => action => {\n        if (typeof action === 'function') {\n            return action(dispatch, getState, extraArgument);\n        }\n\n        return next(action);\n    };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n</code></pre>\n<p><a href=\"https://github.com/reduxjs/redux-thunk/blob/master/src/index.js\" title=\"redux thunk\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">redux thunk</a></p>\n<ul>\n<li>舊版 applyMiddleWare (github 只剩 typescript...)</li>\n</ul>\n<pre><code class=\"language-javascript\">// middlewares argument is pass thunk\nexport default function(...middlewares) {\n    return createStore => (reducers, initialState, enhancer) => {\n        const store = createStore(reducers, initialState, enhancer);\n        const dispatch = store.dispatch;\n        const chain = [];\n        const middleWareAPI = {\n            getState: store.getState,\n            dispatch: action => dispatch(action)\n        };\n\n        chain = middlewares.map(middleware => middleware(middlewareAPI));\n        dispatch = compose(...chain)(store.dispatch); // store.dispatch or dispatch both work\n        // compose will do following thing:\n        /*\n         * a, b, c ==> a(b(c())), indeed, it is just a reduce and store.dispatch will be an initial value\n         */\n        return {\n            ...store,\n            dispatch\n        };\n    };\n}\n</code></pre>\n<p>redux thunk code 很優美，完美的示範如何使用 redux 的 middleWare，邏輯清楚又不複雜。我一定不會說這篇文章是為了分享 redux thunk。</p>\n<p>改天再來研究、分享更優美的 redux。</p>\n<p>這兩個方法 <code>batch</code>、<code>redux thunk</code> 都是目前專案都有用到的方法，至於其他就改天再另外介紹。 batch 因為與 react fiber 更新 component 機制有關，這部分較複雜，我對這塊沒有特別研究...，無法提供太多看法。</p>\n<p>感謝閱讀，以上有錯誤再麻煩留言或私訊。</p>","frontmatter":{"title":"Redux multiple dispatch，batch redux-thunk","date":"November 30, 2019","description":"redux 核心流程 dispatch action => reducer => store，當你用 redux 運行多個 dispatch 時，每一個 dispatch 都會獨立更新下去的，如果你的更新資料又彼此關聯，就可能會發生錯誤。","categories":"javascript","tags":["react.js"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACeElEQVQozz2S61MSYRjF919qbKzUyiy1xGLS8lYKiiAgLggsFwnjIle5CHITUBERQapxcsbpZlNTTjP9U6fDfujDmWdnd57fe87ZV+h9tYZbr0XcXbJjgLqnkfDI+EbW6OomJl3b0EUrsOea2Np/D40/i361FXfmzeidM6Fn2oAbU3rcnDFyrkDoX7RhgLqvdWJQ58JD/QYei36MWbYwbg1h1rsDbawKR7EFMV7GrCOCwWUHBggd5E7fgkUGd431ECr8Bxk8hHkwYnpLWBBKKYZntjCeEPzSk8JSuARDrIJFbwrDK24mkpjAiwfcvU23/ap19FHCEB0NG70EbWLM7IeCgKe2CNSBHPY/XmGz3EKqeYHAfge+Shszzijm3HFMbySgtIWgZIo+tU2uoVuXMEpHCoK6zkbWfISFMU7glCcNabcBX7UD/8E7ebrzDTwnxBQrw1NoYsIZh9IelXeH6LpblzDOeApLALpwAWKyChVLl7J16OMVrCYPsBwtQ8ufIuUa0BNkSR0iQPh24wKu/AmWQiWog0WZoaQZYdIRlbvqRjq4+I7s2SXK599w/OkXGp9/o3h+hVTrEqdfr3Hy5RoffvxF5+oPmvxev/wJd6mNOV+OwCBeSBEIs54kZHnTWPDvQhXMYyFYoLtDGBJUsgYjn1dTNbhKZ7CzBnO6xhTHsltnoQV7viWbUvB2CCpfBosEaQhaDhWhi+zBsF2FiYC19BHEnbosK++ha68DG4FWVuLMncCcqEKzVeTBNd7XBLr1CbowX8T2YGRnRoJEnirSgSVzjPVsAzYuWilHsQ2pcIr1TB0uzi7QkTmClkZWaGLen8OEI4Z/6QroMnomXWYAAAAASUVORK5CYII=","aspectRatio":2.073170731707317,"src":"/static/98774fcb9185ece7c2ac182e96d70db5/ee604/redux-dispatch.png","srcSet":"/static/98774fcb9185ece7c2ac182e96d70db5/c972b/redux-dispatch.png 340w,\n/static/98774fcb9185ece7c2ac182e96d70db5/27625/redux-dispatch.png 680w,\n/static/98774fcb9185ece7c2ac182e96d70db5/ee604/redux-dispatch.png 800w","sizes":"(max-width: 800px) 100vw, 800px"}}}},"timeToRead":4,"parent":{"__typename":"File","modifiedTime":"2021-05-16T08:19:40.155Z"}}},"pageContext":{"slug":"/2019-11-reduxdispatch/","previous":{"fields":{"slug":"/2019-09-jestunit/"},"frontmatter":{"title":"React Unit Test with Jest 單元測試","tags":["react.js","testing"]}},"next":{"fields":{"slug":"/2019-12-iframeblockcookie/"},"frontmatter":{"title":"阻擋第三方(Block third-party) Cookie，各瀏覽器狀態","tags":["javascript"]}}}},"staticQueryHashes":["1481458783","63159454"]}