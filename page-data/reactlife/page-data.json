{"componentChunkName":"component---src-templates-blog-post-js","path":"/reactlife/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"f798b61f-9b32-56c3-914d-af6e90ce931e","fields":{"slug":"/2018-07-reactlife/"},"headings":[{"value":"React Life Cycle","id":null,"depth":2},{"value":"Mounting","id":null,"depth":2},{"value":"constructor() :","id":null,"depth":4},{"value":"componentWillMount() -> 17 版將丟棄 :","id":null,"depth":4},{"value":"get­Derived­State­From­Props(nextProps, prevState) -> 新增","id":null,"depth":4},{"value":"render()","id":null,"depth":4},{"value":"componentDidMount()","id":null,"depth":4},{"value":"componentWillReceiveProps(nextProps) -> 17 版將丟棄","id":null,"depth":4},{"value":"static getDerivedStateFromProps(nextProps, prevState) -> 新增","id":null,"depth":4},{"value":"shouldComponentUpdate(nextProps, nextState)：","id":null,"depth":4},{"value":"componentWillUpdate（nextProps, nextState) -> 17 版將丟棄","id":null,"depth":4},{"value":"render","id":null,"depth":3},{"value":"getSnapshotBeforeUpdate(prevProps, prevState) -> 新增","id":null,"depth":3},{"value":"componentDidUpdate(prevProps, prevState, snapshot)","id":null,"depth":4},{"value":"componentWillUnmount()","id":null,"depth":4},{"value":"元件渲染順序","id":null,"depth":2}],"excerpt":"如果在開發上是用 React，最常用到就是一定是處理 state、props，而其中最重要的莫過於是生命週期 lifeCycle，可以在每個元件渲染的過程，加入需要的處理，例如載入完元件後非同步抓取資料，更新 props 觸發處理事件等等。接下來就來介紹 life Cycle…","html":"<p>如果在開發上是用 React，最常用到就是一定是處理 state、props，而其中最重要的莫過於是生命週期 lifeCycle，可以在每個元件渲染的過程，加入需要的處理，例如載入完元件後非同步抓取資料，更新 props 觸發處理事件等等。接下來就來介紹 life Cycle，順便了解新版本多的功能，還有未來會移除的功能。</p>\n<!--- ![react lifecycle](../images/react.png \"react lifecycle\") --->\n<h2>React Life Cycle</h2>\n<p>大致上可分類為 Mounting 增加、Updating 更新、Unmounting 移除增加。</p>\n<p><img src=\"../images/react-life.png\" alt=\"react lifecycle\" title=\"react lifecycle\">\n大推 Dan Abramov 的圖表， <a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" title=\"React Life Cycle\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">網站版 React Life Cycle 網友製</a></p>\n<p>PS.React 官方已經在 2018/03/27 宣告 不推薦使用:\ncomponentWillMount、componentWillReceiveProps、componentWillUpdate 並且 react 16.3 版本以後這些 method 會加上前綴 UNSAFE_，17 版本會丟棄。提醒使用的時候要特別小心。</p>\n<p>另外在看下面的時候可以搭配使用 <a href=\"https://codesandbox.io/s/xp7lk14x4w\" title=\"React Life Cycle\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">react life Cycle sample</a>，點開 console.log 查看執行順序，裡面操作主要兩個，一個是父元件更新傳遞的 props，還有元件自己 setState。</p>\n<h2>Mounting</h2>\n<p>Mounting 會在元件被建立時被執行。</p>\n<h4>constructor() :</h4>\n<p>這是 es6 的 class 語法糖，可以說是建構並初始化物件，這邊會繼承 React.Component，假設你元件要使用到 props，就必須這樣寫 super(props)來繼承父類別。這階段簡單說就是開始建立這個物件。如果你沒有要定義 state、或是在這邊綁定 method (另可以選用 arrow function 綁定 method)，就不需要用到 constructor。</p>\n<pre><code class=\"language-javascript\">// get parents props\nconstructor(props) {\n  super(props);\n}\n</code></pre>\n<h4>componentWillMount() -> 17 版將丟棄 :</h4>\n<p>緊接在 constructor 後執行 componentWillMount，提醒只會在初始執行一次，移除後重新建立元件也不會在執行 componentWillMount。另外是唯一會在 server side render 時執行的 life Cycle method，關於 WillMount 最多的討論就是，在這邊擺放 fetch api 是否正確。</p>\n<p>官方表示，因為 server side 會執行一次，client side 也會再多執行一次，造成重複要資料動作。另外在這邊做 async api 處理，是無法暫停 render 動作，你一樣要等 render 完成後，你還是必須等待類似 loading 空畫面跑出來，才能在更新畫面，所以會更推薦在 componentDidMount 做 fetch api。</p>\n<h4>get­Derived­State­From­Props(nextProps, prevState) -> 新增</h4>\n<p>get­Derived­State­From­Props 主要是對比到 componentWillReceiveProps，get­Derived­State­From­Props 帶有兩個參數 nextProps, prevState，更新後的 props，先前的 state，這個 method 會在初始 render 調用，還有父元件重新 render，也會調用到。</p>\n<p>還有當你使用了 get­Derived­State­From­Props，要更新 state 就需要回傳物件，如果不更新就必須回傳 null。</p>\n<p>PS.當你使用 get­Derived­State­From­Props，也同時使用 componentWillMount，WillMount 會不執行，並且 console 會傳出警告，另外就算改用 UNSAFE_componentWillMount 也不會執行。</p>\n<pre><code class=\"language-javascript\">class ExampleComponent extends React.Component {\n  // Initialize state in constructor,\n  state = {\n    isScrollingDown: false,\n    lastRow: null,\n  };\n  // means you can not use \"this.setState\"\n  // return will update state\n  static getDerivedStateFromProps(props, state) {\n    if (props.currentRow !== state.lastRow) {\n      return {\n        isScrollingDown: props.currentRow > state.lastRow,\n        lastRow: props.currentRow,\n      };\n    }\n    // Return null to indicate no change to state.\n    return null;\n  }\n}\nby officical react\n</code></pre>\n<p>官方介紹使用情境: <a href=\"https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props\" title=\"get­Derived­State­From­Props example\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">get­Derived­State­From­Props example</a></p>\n<p>移動到 Update 部分: <a href=\"#static-getDerivedStateFromProps-nextProps-prevState-gt-%E6%96%B0%E5%A2%9E\" title=\"get­Derived­State­From­Prop\">get­Derived­State­From­Prop</a></p>\n<h4>render()</h4>\n<p>執行 setState、更新父元件傳遞的 props，都會執行 render()，假設 shouldComponentUpdate()回傳 false，則是阻止 render 執行。使用 render 必須回傳 react element(JSX、createClass、react 元件)、或 Fragment、Portals(可以綁定 render 到其他 Dom root)、如果不回傳內容則回傳 boolean、或是 null。</p>\n<p><a href=\"https://reactjs.org/docs/portals.html\" title=\"Portals\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Portals</a></p>\n<p>然後使用 render 盡量保持 pure，例如盡量少在這邊額外處理 props 以及 state，在外面處理保持 render 內乾淨。(這點我也沒做到...)</p>\n<pre><code class=\"language-javascript\">class App extends React.Component {\n  filterProps = () => {\n    const { personList } = this.props\n    return (\n      {personList.filter(elem => elem.age > 20)}\n    )\n  }\n  render() {\n    return (\n      &#x3C;div>\n        older than 20 years:\n        {this.filterProps()}\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<h4>componentDidMount()</h4>\n<p>componentDidMount 會在 render 執行完成後調用。這應該是最多人用到的生命週期，舉凡綁定 DOM 事件，執行 ajax，多半會在這邊使用。提醒在這邊使用 setState 會迫使 render 執行兩次，盡量在 constructor 內設定好初始 state，避免過多 render 執行。</p>\n<p>另外提醒在這邊綁定 DOM eventListener，記得在 willUnMount 取消綁定 EventListener，如果重新 render 元件會再次執行 DidMount，造成過多的綁定事件。</p>\n<br/>\n## Updating\n主要是在父元件更新傳遞的props，或是元件中使用到setState，會開始整個Update的生命週期。另外setState({xxxx},callback)，則是會在整個週期執行完成才會執行callback。\n<h4>componentWillReceiveProps(nextProps) -> 17 版將丟棄</h4>\n<p>componentWillReceiveProps(nextProps)，會回傳更新過的 props，並且可以使用 setState 來更新 state，提醒在這邊使用 setstate，並不會驅使重跑 componentWillReceiveProps，因為 ReceiveProps 只會在更新傳遞的 props 時被調用。</p>\n<p>react 官方是創建 get­Derived­State­From­Prop 來替代掉 WillReceiveProps，主要明顯差異在於 get­Derived­State­From­Prop 必須使用 static，且會在 Mounting 階段執行，\b\b\b 但是會自動傳遞更新 state，而 componentWillReceiveProps 則是純粹執行，\b 不依靠 return 更新。</p>\n<h4>static getDerivedStateFromProps(nextProps, prevState) -> 新增</h4>\n<p>Updating 階段中，getDerivedStateFromProps 則是在父元件更新傳遞的 props 時調用，提醒一下這時候 this.props state 還會是未更新的。</p>\n<p>移動到 Mounting 部分: <a href=\"#get%C2%ADDerived%C2%ADState%C2%ADFrom%C2%ADProps-nextProps-prevState-gt-%E6%96%B0%E5%A2%9E\" title=\"get­Derived­State­From­Prop\">get­Derived­State­From­Prop</a></p>\n<h4>shouldComponentUpdate(nextProps, nextState)：</h4>\n<p>執行 receive props 後調用，這時候 this.props state 還會是未更新的。主要是判斷元件是否要往下繼續執行 willUpdate、render、componentDidUpdate，如果回傳 false，則會中斷整個更新循環，回傳 true 則是繼續往下執行，默認值為 true。</p>\n<p>一般會使用 shouldComponentUpdate 來優化效能，避免執行沒必要的 render。</p>\n<h4>componentWillUpdate（nextProps, nextState) -> 17 版將丟棄</h4>\n<p>Update 到 render 前最後一個，\b 提醒在這邊使用 setState 的話，會導致重跑回 update 的生命週期，然後在跑到 componentWillUpdate，若沒有設定好判斷，就會再 setState，再重跑回一遍，變成反覆 infinite 執行。</p>\n<h3>render</h3>\n<p>Update 階段中開始處理 react 的畫面架構。提醒在這邊 setState 也同樣會重跑 Update，也同樣不建議在這邊執行 setState，容易產生無限迴圈。</p>\n<p>其餘跟 Mounting 階段一樣，回傳 react element，或是 react 相關的物件。</p>\n<h3>getSnapshotBeforeUpdate(prevProps, prevState) -> 新增</h3>\n<p>能夠抓取 render 到執行渲染畫面更新前，所保持的畫面狀態，然後再傳第一個新值給 componentDidUpdate 當參數使用。</p>\n<h4>componentDidUpdate(prevProps, prevState, snapshot)</h4>\n<p>Updating 階段最後一個執行，在畫面渲染更新後調用，新版本的還多加 getSnapshotBeforeUpdate 傳遞的參數。</p>\n<p>在這邊可以處理 call api 動作，或是 setState，促使重新更新，但提醒記得要判斷執行時機，否則一樣會進入無限迴圈。</p>\n<pre><code class=\"language-javascript\">componentDidUpdate(prevProps) {\n    if (this.props.name !== prevProps.name) {\n        updateUser(this.props.id);\n    }\n}\n</code></pre>\n<br/>\n## Unmounting\n移除的時候會執行這個生命週期\n<h4>componentWillUnmount()</h4>\n<p>元件要被移除的時候會執行，可以做清除綁定 eventlistener，或是清除 cookie、local storage 等等，提醒在這邊 setState 是不會重新執行 render。</p>\n<p>以上就是關於 react 新版的生命週期，看過一遍後更能理解，在哪個階段做什麼處理會更適合。</p>\n<h2>元件渲染順序</h2>\n<p>大型開發滿常遇到這個問題，子元件先執行 render 還是父元件先，還有 lifeCycle 在父子元件的調用順序。稍微試跑了一下流程。\n請查看 console <a href=\"https://codesandbox.io/s/5kpvvkqx7k\" title=\"react life Cycle parents child order\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">react life Cycle parents child order</a></p>\n<ul>\n<li>Mounting\b: 簡單講就是父元件先執行到 render 後，再來開始執行子元件的 Mounting 生命週期，最後執行完子元件的 componentDidMount 後，再回頭執行父元件的 componentDidMount。</li>\n<li>Updating: 父元件執行到 render 後，換子元件執行直到 getSnapshotBeforeUpdate()，會再回父元件執行 getSnapshotBeforeUpdate()，然後再執行子元件的 componentDidUpdate，再回父元件執行 componentDidUpdate。</li>\n<li>UnMounting: 父元件先執行 componentWillUnmount，再來是子元件執行。</li>\n</ul>\n<p>以上就是關於 react 的新版生命週期，還有父子元件執行的順序。實際研究才發現各階段德每個 method 有許多細節，例如說 mounting 階段，componentWillMount 執行 fetch api，因為他只會在第一次 Mounting 被調用的特性，如果是抓取後續不會更新的資料，其實也是一種選擇，但今天如果你後面還可能會再次 call api，或許 componentDidMount 會更適合使用。</p>\n<p>--以上如果有錯誤，歡迎留言。感謝!--</p>","frontmatter":{"title":"React Life Cycle 生命週期更新版，父子元件執行順序","date":"July 27, 2018","description":"開發上用到React，而其中最重要的莫過於是生命週期lifeCycle，可以在每個元件渲染的過程，加入需要的處理，例如載入完元件後非同步抓取資料，更新props觸發處理事件等等。接下來介紹一下新版本的life Cycle。","categories":"javascript","tags":["react.js"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABPUlEQVQoz2OQxwRycvJy8gpKSrKSErJSkgrKKnKyMvLYAAO6gIICUKlBWKJpZoWGnbOOV5B5bq2WkyfQFKAUXs1AnTIyShqaBhEpshLizlPWmmVXAR1iGJUGdIW8giIBzUA9mnYuto1TrSp7LIqarSq6rat6rCq7lTS05aSl0CxH0qygCDRe1ydMPyjWPL/eurrXuroPyLDvnGcQkWwUm61mZi2H6ngkzYqKsuKiRnHZmg7uRtHppmmlLtM3WFZ0WZa1a9g6G0ZnaDl7y4qLITueATMM9YJiHLoXOk5YbpyYZ1HU5DR5lU3DFA07F7zOhgSYtLSimoZhZAqQ5zhppVlujaKyCijAJMQIhTbEBCVl48R8o7gcoFOB2kxSCvUCo4GGEqEZFFvSShpawOCRERcBCqhb2AKDA5RyMAAAiZhuqh37UK0AAAAASUVORK5CYII=","aspectRatio":1.9428571428571428,"src":"/static/49f3722d7cadbd2be8eefba27f6a5890/b7e46/react.png","srcSet":"/static/49f3722d7cadbd2be8eefba27f6a5890/c972b/react.png 340w,\n/static/49f3722d7cadbd2be8eefba27f6a5890/27625/react.png 680w,\n/static/49f3722d7cadbd2be8eefba27f6a5890/b7e46/react.png 732w","sizes":"(max-width: 732px) 100vw, 732px"}}}},"timeToRead":7,"parent":{"__typename":"File","modifiedTime":"2021-05-15T08:14:04.647Z"}}},"pageContext":{"slug":"/2018-07-reactlife/","previous":{"fields":{"slug":"/2018-06-gautm/"},"frontmatter":{"title":"Google analytics UTM設定參數，追蹤facebook廣告、簡訊、EDM","tags":["google_analytics"]}},"next":{"fields":{"slug":"/2018-07-gasession/"},"frontmatter":{"title":"Google Analytics 工作階段介紹、定義","tags":["google_analytics"]}}}},"staticQueryHashes":["1481458783","63159454"]}