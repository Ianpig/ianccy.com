{"componentChunkName":"component---src-templates-blog-post-js","path":"/reactcontextapi/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"3a0923f4-7d65-5d94-bf19-7b04c6fe94de","fields":{"slug":"/2019-07-reactcontextapi/"},"headings":[{"value":"createContext 建立資料","id":null,"depth":2},{"value":"Provider 提供 value","id":null,"depth":2},{"value":"Consumer 提取 value","id":null,"depth":2},{"value":"context 更新 rerender 取用元件","id":null,"depth":2},{"value":"contextType 取值","id":null,"depth":2},{"value":"Hooks useContext","id":null,"depth":2},{"value":"心得","id":null,"depth":2}],"excerpt":"React 是單向資料流，利用 React.createElement 建構出整個 element tree 結構，使用者利用 state 及 props 處理元件資料，並搭配觸發 react 更新元件。因為 props 是需要傳遞的，所以時常會遇到 props 需要傳很多層。React…","html":"<p>React 是單向資料流，利用 React.createElement 建構出整個 element tree 結構，使用者利用 state 及 props 處理元件資料，並搭配觸發 react 更新元件。因為 props 是需要傳遞的，所以時常會遇到 props 需要傳很多層。React 為了解決這問題，建立了 context API 的功能，要功能就是跨元件傳遞資料，像是知名的 state 管理工具 react-redux 就是依賴 context 實現的。</p>\n<p>最近就遇到所有 API Error handle 都需要用到新欄位的值，這個值就幾乎傳到到所有元件，中間還不小心遺漏傳遞一個元件，發生些問題...。現在回過頭想想用 context 處理問題會少很多。</p>\n<!--- ![React Context](../images/react.png \"React Context\") --->\n<ul>\n<li>Pass props Hell</li>\n</ul>\n<pre><code class=\"language-javascript\">&#x3C;Header islogin={islogin}/>\n// inside Header Element\n  &#x3C;Navbar islogin={islogin} />\n  // inside Navbar Element\n    &#x3C;Account islogin={islogin} />\n    // inside Account Element\n      &#x3C;User islogin={islogin} />\n        {islogin ?\n          &#x3C;Button onClick={Logout}>Logout&#x3C;/Button>\n        :\n\n// Pass all props\n// it will make child Components rerender by all props update\n&#x3C;Header {...props}/>\n</code></pre>\n<h2>createContext 建立資料</h2>\n<p>首先必須先在需要使用的元件內，先執行<code>React.createContext</code>建立一個 context，其中參數 defaultValue 只會在沒有 Provider 傳遞 value 才會使用到。</p>\n<ul>\n<li>React.createContext return object</li>\n</ul>\n<pre><code class=\"language-javascript\">// React.createContext(defaultValue);\nconst MyContext = React.createContext({isLogin: false});\n\n$$typeof: Symbol(react.context)\nConsumer: {$$typeof: Symbol(react.context), _context: {…}, _calculateChangedBits: null, …}\nProvider: {$$typeof: Symbol(react.provider), _context: {…}}\n_calculateChangedBits: null\n_currentRenderer: {}\n_currentRenderer2: null\n_currentValue: {isLogin: false}\n_currentValue2: {isLogin: false}\n_threadCount: 0\n__proto__: Object\n</code></pre>\n<h2>Provider 提供 value</h2>\n<p>調用 createContext 後，回傳的物件會帶有 Provider、Consumer 元件，Provider 可以提供 value，給相對應最接近的 Consumer 使用 value，最特別的是 Provider 更新 value 後，會觸發相對應的 Consumer 更新元件，並且無視 shouldComponentUpdate 限制 (這在舊版 Context 無法達到)。</p>\n<p>記得要 export React.createContext 回傳值，讓其他元件可以直接 import 使用 Consumer。還有提醒要注意 Provider 的 update 狀態，如果 Provider 的元件會頻繁更新，但 Provider 的 value 會每次都是新物件，會促使有 Cosumer 的元件每次都 update。</p>\n<ul>\n<li>當元件 rerender 會同時更新 Consumer 調用的元件</li>\n</ul>\n<pre><code class=\"language-javascript\">// isLogin will forever new one\n  render() {\n    return (\n      &#x3C;MyContext.Provider value={{ isLogin: isLogin }}>\n</code></pre>\n<ul>\n<li>傳遞的值保持同一參考 MyContext Provider</li>\n</ul>\n<pre><code class=\"language-javascript\">export const MyContext = React.createContext({ isLogin: false });\n\nexport default class Container extends Component {\n  state = {\n    isLoginStatus: { isLogin: true }\n  };\n\n  render() {\n    const { isLoginStatus } = this.state;\n    return (\n      &#x3C;MyContext.Provider value={isLoginStatus}>\n...\n</code></pre>\n<h2>Consumer 提取 value</h2>\n<p>Consumer 元件可以獲取 context 資料，假設沒有最接近的 Provider 提供 value，Cosumer 會取到 createContext 的 defaultvalue。若有 Provider 提供值，則是會保持訂閱更新，也就是達到跨元件同步資料，並 update component。</p>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport { MyContext } from '../Container';\n\nexport default function Account() {\n    return (\n        &#x3C;div className=\"account\">\n            &#x3C;MyContext.Consumer>\n                {({ isLogin }) => {\n                    return isLogin ? 'Logout' : 'Login';\n                }}\n            &#x3C;/MyContext.Consumer>\n        &#x3C;/div>\n    );\n}\n</code></pre>\n<p><a href=\"https://codesandbox.io/s/relaxed-banzai-su39f\" title=\"Consumer codesandbox\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Consumer codesandbox</a></p>\n<iframe src=\"https://codesandbox.io/embed/relaxed-banzai-su39f?fontsize=12,result\" width=\"100%\" height=\"400\"></iframe>\n<h2>context 更新 rerender 取用元件</h2>\n<p>context 的 Provider 更新 value 時，會一起更新 context Consumer 的取用元件，並且無視於 shouldComponentUpdate。</p>\n<p><a href=\"https://codesandbox.io/s/happy-moon-ypeqm\" title=\"Consumer shouldComponentUpdate codesandbox\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Consumer shouldComponentUpdate codesandbox</a></p>\n<iframe src=\"https://codesandbox.io/embed/happy-moon-ypeqm?fontsize=12,result\" width=\"100%\" height=\"400\"></iframe>\n<h2>contextType 取值</h2>\n<p>contextType 是直接在 react 的 component 的 instance 再加上 context，所以只能用在 class Component，一個元件只能使用一個 context。</p>\n<pre><code class=\"language-javascript\">import React, { Component } from 'react';\nimport MyContext from '../context/MyContext';\n\nexport default class Account extends Component {\n    static contextType = MyContext;\n    render() {\n        const { isLogin, setLogin } = this.context;\n        return (\n            &#x3C;div className=\"account\">\n                &#x3C;div>\n                    {isLogin ? 'Logout' : 'Login'}\n                    &#x3C;button onClick={setLogin}>toggleLogin&#x3C;/button>\n                &#x3C;/div>\n            &#x3C;/div>\n        );\n    }\n}\n</code></pre>\n<p>我在這邊有遇到一個問題，在 Container component export context，並在 Account 引用 Container export 的 context 時，會發生我取不到值得問題，這是因為循環依賴的關係，在我們 Account 引用 Container 內的 MyContext 時，ES6 只會是 referrence MyContext undefined 狀態，實際在 Container 還尚未建立 createContext，這個 Account 又會再初始化階段就執行 MyContext，導致拿到 empty object。</p>\n<p>解法就是獨立建 MyContext ，解除與 Container 關係，就可以避免掉循環依賴的問題。至於 Consumer 會沒有問題，因為 Consumer 是在 render 時才會調用參考，所以會拿到正確的值。</p>\n<pre><code class=\"language-javascript\">// Container File\nimport Account from \"./components/Account\";\nexport const MyContext = React.createContext({\n  isLogin: false\n});\nexport default class Container extends Component {\n  state = {\n    isLogin: true\n  };\n...\n      &#x3C;MyContext.Provider value={{ isLogin: isLogin, setLogin: this.setLogin }}>\n        &#x3C;Account />\n      &#x3C;/MyContextProvider>\n}\n\n// Account File\n\nimport MyContext from \"../Container\";\n\nexport default class Account extends Component {\n  // MyContext undefined\n  static contextType = MyContext;\n  render() {\n    // empty object\n    console.log(this.context);\n...\n</code></pre>\n<p>Dan 神表示: <a href=\"https://github.com/facebook/react/issues/13969#issuecomment-474373021\" title=\"16.6 Context API not working in class component \" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React contextType undefined GitHub issue</a></p>\n<p><a href=\"https://railsware.com/blog/how-to-analyze-circular-dependencies-in-es6/\" title=\"how-to-analyze es6 circular-dependencies\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">how-to-analyze es6 circular-dependencies</a></p>\n<ul>\n<li>\n<p>獨立建立引用 context\n<a href=\"https://codesandbox.io/s/relaxed-fermat-c097p\" title=\"file context codesandbox\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">file context codesandbox</a>\n{% iframe <a href=\"https://codesandbox.io/embed/relaxed-fermat-c097p?fontsize=12,result\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://codesandbox.io/embed/relaxed-fermat-c097p?fontsize=12,result</a> 100% 400px %}</p>\n<iframe src=\"https://codesandbox.io/embed/relaxed-fermat-c097p?fontsize=12,result\" width=\"100%\" height=\"400\"></iframe>\n</li>\n</ul>\n<h2>Hooks useContext</h2>\n<p>React Hooks 有可以直接調用 Context 的方法，useContext 與 Consumer 特性相似，當沒有 Provider 提供 value，就會以 defaultValue 為值，提醒有用到 useContext 的元件當 value 更新時皆會 rerender，rerender 效能不好的話，建議搭配 Memo 來做 memorize。</p>\n<pre><code class=\"language-javascript\">const value = useContext(MyContext);\n</code></pre>\n<p>Preventing rerenders with React.memo and useContext hook.\n<a href=\"https://github.com/facebook/react/issues/15156#issuecomment-474590693\" title=\"Preventing rerenders with React.memo and useContext hook.\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Preventing rerenders with React.memo and useContext hook.</a></p>\n<pre><code class=\"language-javascript\">import React, { useContext, useMemo } from 'react';\nimport MyContext from '../context/MyContext';\n\nexport default function Account() {\n    const { isLogin, setLogin } = useContext(MyContext);\n    return useMemo(() => {\n        return (\n            &#x3C;div className=\"account\">\n                &#x3C;div>\n                    {isLogin ? 'Logout' : 'Login'}\n                    &#x3C;button onClick={setLogin}>toggleLogin&#x3C;/button>\n                &#x3C;/div>\n            &#x3C;/div>\n        );\n    }, [isLogin, setLogin]);\n}\n</code></pre>\n<p><a href=\"https://codesandbox.io/s/gifted-wood-8ot48\" title=\"useContext with useMemo codesandbox\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">useContext with useMemo codesandbox</a></p>\n<iframe src=\"https://codesandbox.io/embed/gifted-wood-8ot48?fontsize=12,result\" width=\"100%\" height=\"400\"></iframe>\n<h2>心得</h2>\n<p>會特別研究寫關於 context API 內容，是因為目前專案幾乎都沒用到，多半還是以 redux 居多，redux 更新版 hooks 也有 useSelector，也是非常好用，雖然常聽到 useReucer、useContext 幾乎可以取代 redux。</p>\n<p>但 redux 有極好用的 debug 工具，devtool 觀看變化、history、dispatch，這些都是無法取代的功能。與夥伴討論過後，認為某些無狀態不需要更新值，我們才會考慮用 context API，因為不需要 update，也沒有隨之的監控更新需求。</p>","frontmatter":{"title":"React Context API 跨元件傳遞資料","date":"July 28, 2019","description":"React為了解決props 需要傳很多層問題，就在v16.3 更新 context API 的功能，context API 主要功能就是跨元件傳遞資料。利用createContext 建立context，並搭配Provider、Consumer、contexttype、usecontext 跨元件取值。","categories":"javascript","tags":["react.js"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABPUlEQVQoz2OQxwRycvJy8gpKSrKSErJSkgrKKnKyMvLYAAO6gIICUKlBWKJpZoWGnbOOV5B5bq2WkyfQFKAUXs1AnTIyShqaBhEpshLizlPWmmVXAR1iGJUGdIW8giIBzUA9mnYuto1TrSp7LIqarSq6rat6rCq7lTS05aSl0CxH0qygCDRe1ydMPyjWPL/eurrXuroPyLDvnGcQkWwUm61mZi2H6ngkzYqKsuKiRnHZmg7uRtHppmmlLtM3WFZ0WZa1a9g6G0ZnaDl7y4qLITueATMM9YJiHLoXOk5YbpyYZ1HU5DR5lU3DFA07F7zOhgSYtLSimoZhZAqQ5zhppVlujaKyCijAJMQIhTbEBCVl48R8o7gcoFOB2kxSCvUCo4GGEqEZFFvSShpawOCRERcBCqhb2AKDA5RyMAAAiZhuqh37UK0AAAAASUVORK5CYII=","aspectRatio":1.9428571428571428,"src":"/static/49f3722d7cadbd2be8eefba27f6a5890/b7e46/react.png","srcSet":"/static/49f3722d7cadbd2be8eefba27f6a5890/c972b/react.png 340w,\n/static/49f3722d7cadbd2be8eefba27f6a5890/27625/react.png 680w,\n/static/49f3722d7cadbd2be8eefba27f6a5890/b7e46/react.png 732w","sizes":"(max-width: 732px) 100vw, 732px"}}}},"timeToRead":5,"parent":{"__typename":"File","modifiedTime":"2021-05-16T08:19:40.152Z"}}},"pageContext":{"slug":"/2019-07-reactcontextapi/","previous":{"fields":{"slug":"/2019-06-gauserid/"},"frontmatter":{"title":"Google Analytics 自訂UserId 追蹤數據","tags":["google_analytics"]}},"next":{"fields":{"slug":"/2019-08-gacrossdomain/"},"frontmatter":{"title":"GA跨網域追蹤 google analytics cross-domain tracking","tags":["google_analytics"]}}}},"staticQueryHashes":["1481458783","63159454"]}