{"componentChunkName":"component---src-templates-blog-post-js","path":"/closure/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"6f1a16aa-0136-532e-8156-1dc356e0725b","fields":{"slug":"/2020-06-closure/"},"headings":[{"value":"Closure 封裝變數","id":null,"depth":2},{"value":"JavaScript 作用域","id":null,"depth":2},{"value":"setTimeout 解法","id":null,"depth":3},{"value":"心得","id":null,"depth":2}],"excerpt":"JavsScript 的 closure (閉包) 是什麼？ 假設你有在寫 javascript 的話，你可能每天都在用，但你只是沒特別查覺而已。 Clousre 在 MDN 上解釋為 這個解釋是我看過比較簡單直白的。 而我自己對 closure 白話解釋的話，就是利用 return…","html":"<p>JavsScript 的 closure (閉包) 是什麼？ 假設你有在寫 javascript 的話，你可能每天都在用，但你只是沒特別查覺而已。</p>\n<!--- ![javascript closure](../images/closure.png \"javascript closure\") --->\n<p>Clousre 在 MDN 上解釋為</p>\n<pre><code class=\"language-javascript\">A closure is the combination of a function bundled together (enclosed)\nwith references to its surrounding state (the lexical environment).\n</code></pre>\n<p>這個解釋是我看過比較簡單直白的。</p>\n<p>而我自己對 closure 白話解釋的話，就是利用 return 回傳值，並且做一個作用域環境封裝。</p>\n<h2>Closure 封裝變數</h2>\n<p>以下我建立一個變數 a，是一個 object value 是 { name: 'ian'}，function getValueA 則會回傳 a，javascript 特性，會在 function 建立時，就以同層尋找變數，找不到就一層一層往外。接下來建立變數 assignA 賦予 getValueA() 回傳值。</p>\n<p>嘗試 log 出來後，會發現第一次會是 {name: \"ian\"}，但是接下來重新賦予 a 的值，神奇的事發生了，發現 assignA 的值並沒有被改變。但嘗試直接 log 回傳 getValueA() 會發現，a 是有成功被改變了。</p>\n<ul>\n<li>封裝 lexical environment ( 作用域環境 )</li>\n</ul>\n<pre><code class=\"language-javascript\">var a = { name: 'ian' };\nfunction getValueA() {\n    return a;\n}\nvar assignA = getValueA();\nconsole.log(assignA); // {name: \"ian\"}\n\na = 2;\nconsole.log(assignA); // {name: \"ian\"}\nconsole.log(getValueA()); // 2\n</code></pre>\n<p>這是因為 closure 幫我們做封裝記憶體，javascript 的記憶體管理機制，幫我們把第一次 return a 時，這個 { name: 'ian' }，封裝起來避免被記憶體回收，假設要回收 { name: 'ian' } 的方法就是讓 assignA 指向新的參考。</p>\n<ul>\n<li>javascript 記憶體回收</li>\n</ul>\n<pre><code class=\"language-javascript\">「沒有其他任何物件參考它」。如果一個物件不在被任何物件參考，它將被視為可回收記憶體的垃圾。\n</code></pre>\n<p>MDN: <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Memory_Management\" title=\"記憶體生命週期\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">記憶體生命週期</a></p>\n<h2>JavaScript 作用域</h2>\n<p>下面的這個問題，相信大家面試的時候，都被問到爛了，聽到問題是 forLoop 跟 setTimeout 開頭都快可以直接反射背出答案 X Ｄ。</p>\n<ul>\n<li>經典 (<del>面試</del>) 問題</li>\n</ul>\n<pre><code class=\"language-javascript\">for (var i = 0; i &#x3C; 3; i++) {\n    setTimeout(function() {\n        console.log(i);\n    }, 0);\n}\n// 3\n// 3\n// 3\n</code></pre>\n<p>這問題又與 javascript event loop 有關，setTimeout 是 web API，在 javascript 執行緒時，碰到 setTimeout 會被特別放到另一個 stack，等到最後才會來執行，邏輯上就是 i 已經被重新更新到 3 了，但是我才要來開始 log i，那結果當然是 3 出現三次。</p>\n<p>MDN: <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/EventLoop\" title=\"Event Loop\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Event Loop</a></p>\n<h3>setTimeout 解法</h3>\n<p>還是簡單講一下，其中簡單的方法是 var 改用 let，讓每次 let 的作用域被包覆所以記憶起來。另一個就是利用記憶體封裝概念 ，同樣原理也與 let 差不多，利用 function logI(i) 傳入變數，來讓 i 當下的值被封裝。</p>\n<pre><code class=\"language-javascript\">for (var i = 0; i &#x3C; 3; i++) {\n    function logI(i) {\n        setTimeout(function() {\n            console.log(i);\n        }, 0);\n    }\n    logI(i);\n}\n// 0\n// 1\n// 2\n</code></pre>\n<p>如果你將 logI function 的 argument 拿掉，又會出現三次的 3，因為沒有封裝變數 i。</p>\n<pre><code class=\"language-javascript\">...\n    function logI() {\n        setTimeout(function() {\n            console.log(i)\n        }, 0);\n    }\n    logI();\n...\n// 3\n// 3\n// 3\n</code></pre>\n<h2>心得</h2>\n<p>稍微整理一下最近面試常會問的問題，順便整理一下自己對 closure 基本觀念。在找 setTimeout forLoop 除了 let、立即函示外的解法，才找到 function pass argument，也發現自己也不夠了解 function argument 對於 memory 機制這部分。</p>\n<p>雖然說 react 開發上，比較少會因為 closure 踩到雷，但相信<code>每多懂一點，未來雷就少踩一點</code>。</p>\n<p>感謝閱讀，有錯誤或意見歡迎留言。</p>","frontmatter":{"title":"JavaScript Closure 你一定有用過的閉包","date":"June 27, 2020","description":"JavsScript 的 closure (閉包) 是什麼？ 假設你有在寫 javascript 的話，你可能每天都在用，但你只是沒特別查覺而已。","categories":"javascript","tags":["javascript"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAARlAAAEZQAGA43XUAAABwklEQVQoz01R227TQBD1zyLxihA/0apIpVRCfeGhKqDED73QIBKSkASUuLk1SZX4bu863pudVEg0EartMl4HiaOzo9Guz8yZseLajud5OAhnN50fF+/73fZo0LctK4CrZUgIMMdyGWKEQkJDSgmlxYPiOq5jmVpVrZ0e1M8OauWTRvXLYj5fwuc74U6MECL/QYptxzaMZum4/vGwqb5rq8e1y5JhWATq52AAiJDlRiiDs+scgtiyfM/XJ4Nvp3ut0lEU4u3vhyRJ0zRLkwySx8e0SLL06WGzlW4oKHMxQoFj6p7j3P6savWrOL7HmOCA+gg6MUIFIQIHhPE4JGJ9/4tzVliCGkq79KZVUU1dxwhTJkDZ00a9m3F/OOsPp6Pbue3iwWgGhBvGRBQJOUVO5fr18/PDV91mFfuIhHS7+VOYhAg+wXySZKlM0uxps9kWi5Akyte3L672n32//IB9/65zsehWJloH4yCOV8AVcLUGxqs1Z1wImILKXcqZPx+9bJ6fWYbp6VNN3e+V9yqfTgzT4nI4BvEfAoyL5cv9y5kX0zH8ate2zLvxpKFOGuVhtxXArnLwvJeIgJxHspTgEoX+L7rxBR444xreAAAAAElFTkSuQmCC","aspectRatio":2.0481927710843375,"src":"/static/d823d2c008518badcd4d3c8af9842dc0/40a76/closure.png","srcSet":"/static/d823d2c008518badcd4d3c8af9842dc0/c972b/closure.png 340w,\n/static/d823d2c008518badcd4d3c8af9842dc0/27625/closure.png 680w,\n/static/d823d2c008518badcd4d3c8af9842dc0/40a76/closure.png 1360w,\n/static/d823d2c008518badcd4d3c8af9842dc0/3e40c/closure.png 1719w","sizes":"(max-width: 1360px) 100vw, 1360px"}}}},"timeToRead":3,"parent":{"__typename":"File","modifiedTime":"2021-05-16T08:19:40.157Z"}}},"pageContext":{"slug":"/2020-06-closure/","previous":{"fields":{"slug":"/2020-04-immutable/"},"frontmatter":{"title":"Immutable 對於 React 重要性","tags":["javascript","react.js"]}},"next":{"fields":{"slug":"/2020-12-thirtyyearsold/"},"frontmatter":{"title":"30 歲的我","tags":[null]}}}},"staticQueryHashes":["1481458783","63159454"]}