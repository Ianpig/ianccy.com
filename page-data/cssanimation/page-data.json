{"componentChunkName":"component---src-templates-blog-post-js","path":"/cssanimation/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"81a15036-d922-55b2-af5b-24ea60d51b05","fields":{"slug":"/2021-05-cssanimation/"},"headings":[{"value":"browser 60fps","id":null,"depth":2},{"value":"避免使用過於負擔的 css style","id":null,"depth":2},{"value":"CSS animation 專案","id":null,"depth":2},{"value":"React reupdate 影響 animation","id":null,"depth":4},{"value":"Javascript 阻塞 rendering-queue","id":null,"depth":2},{"value":"心得","id":null,"depth":2}],"excerpt":"前一篇介紹了關於 CSS DOM painting performance，再來分享個關於 CSS animation performance 相關資訊，後面會提到自己在專案上遇到相關的問題。 前一篇: cssperformance 先提一下，以下沒有要介紹 CSS animation…","html":"<p>前一篇介紹了關於 CSS DOM painting performance，再來分享個關於 CSS animation performance 相關資訊，後面會提到自己在專案上遇到相關的問題。</p>\n<p>前一篇: <a href=\"../cssperformance/\" title=\"cssperformance\">cssperformance</a></p>\n<p>先提一下，以下沒有要介紹 CSS animation 有哪些寫法，或是什麼炫砲特效的。</p>\n<h2>browser 60fps</h2>\n<p>先介紹一下何謂動畫卡頓感，人眼在 60 frames per seconds 更新下會是順暢感的，下方影片就是 60 fps vs 30 fps vs 24 fps 的比較，會明顯發現 fps 越低會越有卡頓感。</p>\n<p>避免 fps 太低的方法，大概是因為避免頻繁的更新畫面，例如 scroll 搭配複雜的更新 css，或是 javascript 過度的佔用資源，或是 setInterval 頻繁更新畫面等等。</p>\n<p>除非你用插件，否則畫面卡頓你通常會知道是為什麼，因為這些寫法都頗暴力。</p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/_SzGQkI-IwM?start=19\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<h2>避免使用過於負擔的 css style</h2>\n<p>一個頁面效果的更新，通常會有五個 thread， javascript 觸發變化，接下來會在執行 Style 計算，後面會執行 Layout 計算，再來執行 Paint 收集需要繪製的部分，最後會執行 Composite，如果前面有需要更新 paint，都收集起來更新到畫面上。</p>\n<pre><code>JavaScript: 利用 javasScript 執行促使畫面產生變化，例如 onClick slide，或是拖拉 element\n\nstyle: 透過 browser selector ( 例如 .article-content p )，計算出 element 最後應用的 css style。\n\nLayout: 計算 element 因為 style 套用，而可能產生的位移，並且找出相互影響的 element，或是 dom tree 變化等等。\n\nPaint: 搜集 element 所應用的 style，並且運算出 style 結果。\n\nComposite: 將各個 layer 做組合，並渲染更新到畫面上。\n</code></pre>\n<p>google 教學: <a href=\"https://developers.google.com/web/fundamentals/performance/rendering\" title=\"performance rendering\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">performance rendering</a></p>\n<p><img src=\"../images/css_render.png\" alt=\"render step\" title=\"render step\"></p>\n<p>CSS 執行部分主要分為 Layout、Paint、Composite 這三個。其中 Layout 付出的成本最高，會促使 CSSOM tree 更新重繪，至於 painting 也是高成本的計算，最節省資源的是 Composite，能幫助優化 GPU 效能。</p>\n<p>另外 CSS 每個屬性背後所要付出的成本其實不大相同，top 跟 transform 就不一樣。top 會造成整個畫面需要重新繪製位移，負擔較大，至於 transform 則是只需要 composite。詳細每個 style 在下方連結有列出。</p>\n<p>提醒如果你需要使用 animation 的話，盡量能用<code>只需要 composite 的 style</code>，避免對畫面造成可能的負擔。</p>\n<p>文件: <a href=\"https://csstriggers.com/visibility\" title=\"csstrigger\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">csstriggers</a></p>\n<h2>CSS animation 專案</h2>\n<p>最近完成一個有趣東西，是關於動畫效果的，需求就是要落下紅包雨，然後要讓 user 點擊開獎。在有開發時間壓力，其它種種因素之下，決定簡單用 css animation 簡單處理。</p>\n<h4>React reupdate 影響 animation</h4>\n<p>因為專案是全用 react 開發的，所以我也打算用 react 處理這個特效，在一開始是依賴 requestAnimationFrame 來針對每一組紅包 component 在動畫完成落下，再抹殺重建立產生新的動畫落下，不過因為更新過於頻繁，html dom 一直不斷在更新，造成畫面卡頓感嚴重。</p>\n<p>那時候發現 fps 在遭遇大量的 component update 時，fps 會落到 30~40 不等，後面就直接拋棄 react 處理，直接改用 react build component，後面就不盡量不依賴 javascript 去接觸 animation 更新，我這邊是直接用 animation-iteration-count infinite，再一開始 init 計算，用一些方式製造出時間差，讓落下有錯開的錯覺。</p>\n<p>結果就如下方，因為需求就是要多個紅包，設計還要有分離感，最後還是使用了多個 animation...。實務上務必能減少同時 animation 就減少，能減少大量效能負擔。</p>\n<p><img src=\"../images/red_envelope.gif\" alt=\"red envelope\" title=\"red envelope\">\n壓縮 gif 後，有產生點卡頓感</p>\n<h2>Javascript 阻塞 rendering-queue</h2>\n<p>這是正在進行的專案，利用 canvas 處理圖片 (感謝同事 jason carry canvas 部分)。嘗試非常極端的情境，上傳超級大的圖片跟 webp，結果如下方 gif 畫面，有兩個 loading 引導，下方是用 css animation 的，上方是 loading gif，可以看得出來下方的 css animation 十分卡頓。</p>\n<p><img src=\"../images/animation-stuck.gif\" alt=\"animation stuck\" title=\"animation stuck\"></p>\n<p>於是打開 chrome devtool 的 performance 去錄製，由報告中可以發現到 scripting 幾乎佔滿了整個線程，導致我們頁面的 rendering 幾乎沒資源可以執行，</p>\n<p>另外也可以發現 CPU usage 直接跑到 100%。中間區塊的 Compositor 也像是幻燈片一樣，沒有連續的執行，很多執行中斷點。</p>\n<p><img src=\"../images/devtool_render_stuck.png\" alt=\"devtool render stuck\" title=\"devtool render stuck\"></p>\n<p>render 更新又與 render-queue 有關，這會牽涉到 event loop。如果不大理解 event loop 的話，可以看下方這段影片，激推、神清楚。</p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/8aGhZQkoFbQ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n<p>google chrome update: <a href=\"https://frarizzi.science/journal/web-engineering/browser-rendering-queue-in-depth\" title=\"browser-rendering-queue-in-depth\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">browser-rendering-queue-in-depth</a></p>\n<p>卡頓問題的解法可以用 web worker api，讓我們執行序 (thread) 在背景運行，這樣就避免畫面中斷與 user 互動，還可以避免畫面 fps 爆炸產生卡頓感。</p>\n<p>但 web worker 沒支援 ie11...，也知道能不能撐受這麼大的執行運算，還在思考解法中。</p>\n<p>mdn: <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/Web_Workers_API/Using_web_workers\" title=\"mdn web workers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">web workers</a></p>\n<p>google chrome update: <a href=\"https://developers.google.com/web/updates/2018/08/offscreen-canvas\" title=\"web worker handle canvas\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">web worker handle canvas</a></p>\n<h2>心得</h2>\n<p>這個議題是在專案上遇到的，才開始研究 css style animation，所以才會提到專案。畢竟由實務切入，比較能理解相關技術運用的地方，找問題，解決問題。\b</p>\n<p>以上有問題歡迎留言。</p>","frontmatter":{"title":"CSS animation Performance","date":"May 08, 2021","description":"分享個關於 CSS animation performance，後面會提到自己在專案上遇到相關的問題。提醒如果你需要使用 animation 的話，盡量能用只需要 Composite 的 style，避免對畫面造成可能的負擔。","categories":"javascript","tags":["css"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABfUlEQVQoz42Sy07CQBSGfRFBEgu0JISwKcElPgC4w53uFDeArtS48ZJoAi0XBblWLkpFLbeEoLISdaOJT/Q7U1JC5RIXX86ZOZn//DNzFliWhdVqhRYpNpvtX3A2bnRWY0FLaIHjOBWjwQjDokHFOJVh3bRk0hmZEKRdeZcLgb0dhA7DCB6EprMfRPhoFxtbm7BYLLMd2u12+NZ8aAxa6H718PTWgvLeRvOjA2UwjA2yVkj9+aePtJwBwzCzBalDr8+Lu14NmUcJx8kIYuU0hJsULnJxRKUrnGfjOEsLKHdrEKXYbEFN1L/uh/xSh9x/UIUS1WvESmkkb7Mkz6ik7vPEaQtCcY6glSWfwnLwrHogv9bR/OxAaldRaFWQb1ZQJHlWKSFHoHvd7x4S5Uswy4zO0MSV3StunMRPES2IEAhikRIjbkT1impO9iN5AfFCAoHtAJxO5+hzdII0UlFapJjN5hkMaw6HAzzPq6OmG5u/gz3+JvOgTekbjp//BYhlgbSkXZMbAAAAAElFTkSuQmCC","aspectRatio":2.0606060606060606,"src":"/static/fb548587746e32189dd72f687ab6cd99/40a76/chrome-crash.png","srcSet":"/static/fb548587746e32189dd72f687ab6cd99/c972b/chrome-crash.png 340w,\n/static/fb548587746e32189dd72f687ab6cd99/27625/chrome-crash.png 680w,\n/static/fb548587746e32189dd72f687ab6cd99/40a76/chrome-crash.png 1360w,\n/static/fb548587746e32189dd72f687ab6cd99/bb71f/chrome-crash.png 1866w","sizes":"(max-width: 1360px) 100vw, 1360px"}}}},"timeToRead":4,"parent":{"__typename":"File","modifiedTime":"2021-05-16T16:18:12.956Z"}}},"pageContext":{"slug":"/2021-05-cssanimation/","previous":{"fields":{"slug":"/2021-02-cssperformance/"},"frontmatter":{"title":"Critical Rendering Path 關鍵渲染路徑優化","tags":["css"]}},"next":null}},"staticQueryHashes":["1481458783","63159454"]}