{"componentChunkName":"component---src-templates-blog-post-js","path":"/reacthooks/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"80e5e5f8-4792-5a95-a1e9-819e1baca1e4","fields":{"slug":"/2019-06-reacthooks/"},"headings":[{"value":"React PureComponent","id":"react-purecomponent","depth":2},{"value":"React hooks functional","id":"react-hooks-functional","depth":2},{"value":"React hooks 實現 todoList","id":"react-hooks-實現-todolist","depth":2},{"value":"React hooks 效能處理","id":"react-hooks-效能處理","depth":2},{"value":"增加 Redux","id":"增加-redux","depth":2},{"value":"心得","id":"心得","depth":2}],"excerpt":"React 發布了幾個月的 Hooks，最近也開始嘗試接觸，後面會稍微提一下 PureComponent，不會介紹 hooks 各種特殊用法，就只針對 hooks performance 優化做介紹，還有搭配 redux 的處理。 因為前陣子有處理過 React…","html":"<p>React 發布了幾個月的 Hooks，最近也開始嘗試接觸，後面會稍微提一下 PureComponent，不會介紹 hooks 各種特殊用法，就只針對 hooks performance 優化做介紹，還有搭配 redux 的處理。</p>\n<p>因為前陣子有處理過 React 優化效能，對於這件事情也開始在意，讓人絕望的 google page speed…。</p>\n<!--- ![react lifecycle](../images/reacthooks.png \"react lifecycle\") --->\n<h2 id=\"react-purecomponent\" style=\"position:relative;\"><a href=\"#react-purecomponent\" aria-label=\"react purecomponent permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React PureComponent</h2>\n<p>如果有在注意效能的話，你應該會聽過 shouldComponentUpdate 或 PureComponent，這是較常見的處理方法，Purecomponent 只關注 state、props 並作 shallow equal 比較，當不同值才會觸發 rerender。</p>\n<p><a href=\"https://reactjs.org/docs/shallow-compare.html\" title=\"shallow-compare\">React shallow-compare</a></p>\n<p>以下是有無使用 Purecomponent 的比較，當我更新某個 state，而這個 state 沒有傳進作為 props，PureComponent 會過濾掉更新。</p>\n<p>使用教學: 你可以嘗試更新 input text，會發現 Purecomponent 數字不會增加，而一般 component 則是會增加。這數字增加代表著 react 嘗試 update Component 次數。</p>\n<p>這數字不代表是否真的更新 dom，因為 react 會比較 render 後 dom 結構的不同，再決定是否更新某節點 dom，但嚴格來說這也算是種浪費效能。</p>\n<iframe src=\"https://codesandbox.io/embed/serene-murdock-t7ih2?fontsize=14,result\" width=\"100%\" height=\"400\"></iframe>\n<ul>\n<li>PureComponent code</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import React, { PureComponent } from &#39;react&#39;;\n\nclass CheckboxPure extends PureComponent {\n    constructor(props) {\n        super(props);\n        this.state = {\n            done: true\n        };\n        this.times = 0;\n    }\n    changeCheck = e =&gt; {\n        this.setState({\n            done: e.target.checked\n        });\n    };\n    componentWillUpdate() {\n        this.times = this.times + 1;\n    }\n    render() {\n        const { done } = this.state;\n        const { text } = this.props;\n        return (\n            &lt;div&gt;\n                &lt;div&gt;PureComponent component Try Update time {this.times}&lt;/div&gt;\n                &lt;div&gt;\n                    &lt;input onClick={this.changeCheck} type=&quot;checkbox&quot; checked={done} /&gt;\n                    {text}\n                &lt;/div&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n\nexport default CheckboxPure;</code>\n        </deckgo-highlight-code>\n<p>ps. PureComponent 不是全部都用，需要注意 props 的更新關係。假設你上層的 update，一定會更動到 PureCompoent 的 props，那你應該避免使用 PureComponent，因為每次接受到 props 時，PureComponent 還會多做一次 shallow compare，那因為每次都一定更新 props，多做比較就等於浪費效能，比起用一般方法還不好。</p>\n<h2 id=\"react-hooks-functional\" style=\"position:relative;\"><a href=\"#react-hooks-functional\" aria-label=\"react hooks functional permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React hooks functional</h2>\n<p>前面會提到 PureComponent，是因為 react hooks 是全面的使用 functional Component，這代表我們不會在使用 Class，以往 Class 使用是繼承 React 並讓我們建立 instance，有 instance 就代表有 memory 位置，可以讓我們處理資料比較。functional 代表我們只要調用一次更新，所有的 react hooks function 都會再被調用一次。</p>\n<p>舉例來說，將關注點變到更小，所以 useEffect 才能實現像是 componentDidUpdate 的功能。</p>\n<ul>\n<li>Hooks like componentDidUpdate</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">useEffect(() =&gt; {\n  document.title = `You clicked ${count} times`;\n};\n// it will setting title everytime when render function</code>\n        </deckgo-highlight-code>\n<p>useEffect 就是一個例子，你看到 useEffect 的額外第二個參數，useEffect 會綁定 count 更新，才會調用 callback。</p>\n<ul>\n<li>Hooks useEffect bind count</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">useEffect(() =&gt; {\n    document.title = `You clicked ${count} times`;\n}, [count]);\n// Only setting title if count changes</code>\n        </deckgo-highlight-code>\n<h2 id=\"react-hooks-實現-todolist\" style=\"position:relative;\"><a href=\"#react-hooks-%E5%AF%A6%E7%8F%BE-todolist\" aria-label=\"react hooks 實現 todolist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React hooks 實現 todoList</h2>\n<p>嘗試建立一個 toDo List，方便我們來看怎樣讓 React hooks 實現 PureComponent 的特性。我們會需要建立三個檔案，分別是是 container/todoView、component/todoLis、hooks/useTodoList。</p>\n<p>假設你已經用過 react hooks，這部分可以直接略過。</p>\n<p>首先建立 container/TodoView，我們會需要建立 toDo 的 Array，這邊我們會用到 useState，還有 useRe\bf，讓我們能夠取得 input value，剩下部份就是更新處理 todoList state。</p>\n<ul>\n<li>React hooks function</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// toDo array\nconst [todoList, setTodoList] = useState([]);\n\n// create inputRef\nconst inputEl = useRef(null);\n\n// add Array\nconst addTodo = event =&gt; {\n    event.preventDefault();\n    if (!inputEl.current.value) {\n        return;\n    }\n    const mergeArr = [...todoList, inputEl.current.value];\n    inputEl.current.value = &#39;&#39;;\n    return setTodoList(mergeArr);\n};\n\n// delete Array by index\nconst deleteToDo = index =&gt; {\n    const newArr = [...todoList];\n    newArr.splice(index, 1);\n    return setTodoList(newArr);\n};</code>\n        </deckgo-highlight-code>\n<p>建立 hooks/useTodoList，並把上面這些 hooks function 移動過去。就完成了 todoList 的自製 hooks。</p>\n<ul>\n<li>hooks/useTodoList.js</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import { useState, useCallback } from &#39;react&#39;;\n\nfunction useTodoList(value, inputEl) {\n    const [todoList, setTodoList] = useState(value);\n    const addTodo = event =&gt; {\n        event.preventDefault();\n        if (!inputEl.current.value) {\n            return;\n        }\n        const mergeArr = [...todoList, inputEl.current.value];\n        inputEl.current.value = &#39;&#39;;\n        return setTodoList(mergeArr);\n    };\n\n    const deleteToDo = index =&gt; {\n        const newArr = [...todoList];\n        newArr.splice(index, 1);\n        return setTodoList(newArr);\n    };\n\n    return [todoList, addTodo, deleteToDo];\n}\n\nexport default useTodoList;</code>\n        </deckgo-highlight-code>\n<p>會多建立一個 <code class=\"language-text\">const [count, setCount] = useState(0);</code>，讓我們在這層 setState，並觀察 TodoList 更新狀況。</p>\n<ul>\n<li>container/TodoView.js</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import React, { useState, useRef } from &#39;react&#39;;\nimport TodoList from &#39;../component/TodoList&#39;;\nimport useTodoList from &#39;../hooks/useTodoList&#39;;\n\nfunction TodoView() {\n    const inputEl = useRef(null);\n    const [todoList, addTodo, deleteToDo] = useTodoList([], inputEl);\n\n    // use to update TodoView\n    // let us check TodoList update situation\n    const [count, setCount] = useState(0);\n\n    return (\n        &lt;&gt;\n            &lt;span&gt;Counter : {count}&lt;/span&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Add Counter&lt;/button&gt;\n            &lt;form className=&quot;input-container&quot; onSubmit={addTodo}&gt;\n                &lt;input ref={inputEl} placeholder=&quot;Type your to Do&quot; /&gt;\n                &lt;button className=&quot;add-button&quot;&gt;Create&lt;/button&gt;\n            &lt;/form&gt;\n            &lt;TodoList todoList={todoList} deleteToDo={deleteToDo} /&gt;\n        &lt;/&gt;\n    );\n}\n\nexport default TodoView;</code>\n        </deckgo-highlight-code>\n<p>額外再加上 toDoList.js 加上計算器，每次的 render function 都會加上 1，方便我們看 toDoList 重新 render 的次數。</p>\n<ul>\n<li>component/TodoList.js</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import React from &#39;react&#39;;\nlet count = 0;\n\nfunction TodoList(props) {\n    const { todoList, deleteToDo } = props;\n    count = count + 1;\n    return (\n        &lt;div className=&quot;list&quot;&gt;\n            TodoList render Times {count}\n            {todoList.map((value, index) =&gt; (\n                &lt;li className=&quot;list-item&quot; key={`to_${index}`}&gt;\n                    &lt;div&gt;\n                        {index + 1}. {value}\n                    &lt;/div&gt;\n                    &lt;span onClick={() =&gt; deleteToDo(index)}&gt;-&lt;/span&gt;\n                &lt;/li&gt;\n            ))}\n        &lt;/div&gt;\n    );\n}\n\nexport default TodoList;</code>\n        </deckgo-highlight-code>\n<iframe src=\"https://codesandbox.io/embed/fervent-gould-qyekg?fontsize=14,result\" width=\"100%\" height=\"400\"></iframe>\n<h2 id=\"react-hooks-效能處理\" style=\"position:relative;\"><a href=\"#react-hooks-%E6%95%88%E8%83%BD%E8%99%95%E7%90%86\" aria-label=\"react hooks 效能處理 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React hooks 效能處理</h2>\n<p>我們已經完成了簡易版的 todoList，當你輸入 input 建立後，會發現 TodoList 會更新一次，但是你點擊 count 後，會發現 TodoList 居然也會更新，這是因為所有的 component 已經都是純 functional component，當我們最上層更新 state，都會一路往下更新到底層。</p>\n<p>這時候我們就必須依賴 React.memo，React.memo 是一個 high Order Component，功能就像是 PureComponent，讓我們擋住調用更新 function，但差異在於 memo 是用在於 function components，並會幫我們 memory 住 props，只在 props 更新才會往下更新。</p>\n<p><a href=\"https://reactjs.org/docs/react-api.html#reactmemo\" title=\"React memo\">React memo</a></p>\n<ul>\n<li>component/TodoList</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// use React memo for TodoList;\nexport default React.memo(TodoList);</code>\n        </deckgo-highlight-code>\n<p>更新上去後，讓我們在嘗試點擊 count，觀察 TodoList 是否就卡住更新了。</p>\n<p>你會發現數字還是增加。</p>\n<p>查看上層傳進的 props 後，發現還有一個問題，就是傳進去的 function，每次都會是一個新的 function。因為沒有 function 沒有 memory 住，導致每次都會 render 後都會重新建立 addTodo、deleteToDo，所以對 toDoList 的 memo 來說，你每次都給我新的 props function，當然會每次都更新 component。</p>\n<iframe src=\"https://codesandbox.io/embed/adoring-dream-j01do?fontsize=14,result\" width=\"100%\" height=\"400\"></iframe>\n<p>幸好 react hooks 有提供 useCallback，讓我們可以把 function memory 起來，useCallback 會需要依賴第二個參數，讓他比較判斷是否要更新 function。</p>\n<ul>\n<li>React hooks useCallback</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const memoizedCallback = useCallback(() =&gt; {\n    doSomething(a, b);\n}, [a, b]);</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://reactjs.org/docs/hooks-reference.html#usecallback\" title=\"React usecallback\">React hooks usecallback</a></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const addTodo = useCallback(\n    event =&gt; {\n        event.preventDefault();\n        if (!inputEl.current.value) {\n            return;\n        }\n        const mergeArr = [...todoList, inputEl.current.value];\n        inputEl.current.value = &#39;&#39;;\n        return setTodoList(mergeArr);\n    },\n    [todoList, inputEl]\n);\n\nconst deleteToDo = useCallback(\n    index =&gt; {\n        const newArr = [...todoList];\n        newArr.splice(index, 1);\n        return setTodoList(newArr);\n    },\n    [todoList]\n);</code>\n        </deckgo-highlight-code>\n<p>更新上去後，再嘗試點擊 count 看看，會發現 toDoList 終於沒有更新數字了。這樣就完成了 hooks 的 render 效能處理。使用 React.memo 實現了類似 PureComponent 的功能，再解決掉 function components 沒有 memory 的問題，讓我們 todo、delete function，都不會因為 function component 被更新而重新被建立。</p>\n<iframe src=\"https://codesandbox.io/embed/floral-bash-dv708?fontsize=14,result\" width=\"100%\" height=\"400\"></iframe>\n<h2 id=\"增加-redux\" style=\"position:relative;\"><a href=\"#%E5%A2%9E%E5%8A%A0-redux\" aria-label=\"增加 redux permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>增加 Redux</h2>\n<p>另外改用 redux 管理 todo 資料，沒有特別用最新 react-redux 的 hooks 版本，因為還在 alpha 階段。基本上就移除掉 useState，建立 store、reducer，再建立 Provider，還有 state、dispatch 傳遞到需要使用的元件上。</p>\n<p>不想偏離主題就直接貼上作法了。</p>\n<p>Source code: <a href=\"https://github.com/Ianpig/hooks-try\" title=\"React hooks with redux\">React hooks with redux</a></p>\n<h2 id=\"心得\" style=\"position:relative;\"><a href=\"#%E5%BF%83%E5%BE%97\" aria-label=\"心得 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>心得</h2>\n<p>因為準備要開始運用 hooks 在專案上，才發現 function components 要注意的問題，遠比我想像的還多。以往 react class 的寫法，react 處理了 component 的 rerender 問題，但改為 function components 後，多了處理 rerender 的問題。</p>\n<p>個人覺得用過 class 在轉用 hooks 後，lifeCycle 的部分最不習慣，感覺拉高了點 React 的學習門檻。hooks 讓 react 的複用單位拉到在更小，用得好確實能夠加速開發，期待日後實際運用 hooks 在專案上後能有更多心得分享。</p>","frontmatter":{"title":"React Hooks Performance 效能處理","date":"June 01, 2019","description":"React發布了幾個月的Hooks，最近也開始嘗試接觸，後面會稍微提一下PureComponent，不會介紹hooks各種特殊用法，就只針對hooks performance優化做介紹。","categories":"javascript","tags":["react.js"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABTUlEQVQoz2NQQgBlRUUFRQV5JWVlRXk5JdxAWUlJXVkZiBjgQooKCqpa2mp6BopyshpGpkAjSNAMVG0UGGUSGmeemGMcEqfn4q0gI62sogKUUQEDZbBxEBaSZqA75WTV9Y2sMkos04pc22eax2cBjVCUlVFUUlJQUJCRkZGSkpaVlQWypaSl5eTkNFRUoJpBDtbWNQ6Ns8mtcm6a4ljT49I0xTg6zTYyISs1OTU5KTwsxNfHOzI8ND8328/Xx9XZSVEWpB9Jc0isTV61c/Nkx5pu5+YpJtFpdhEJKQlxmempTXU1tVXlNZVlna1N9bVVGanJMpKSmqqqyM42tEoHOdulY5Z5XKZFQrairDTQ2YqKipqaQJWqampqQLVAtrqaqpqyEo4AS8gGknouXvAAA3pVERSNQKOU5BUUgOahhbYyMIYpiCpwIlEiJZEAAL1oc611LwT/AAAAAElFTkSuQmCC","aspectRatio":1.9540229885057472,"src":"/static/ef923c6861937178eebcde2d6d04f7df/ee604/reacthooks.png","srcSet":"/static/ef923c6861937178eebcde2d6d04f7df/c972b/reacthooks.png 340w,\n/static/ef923c6861937178eebcde2d6d04f7df/27625/reacthooks.png 680w,\n/static/ef923c6861937178eebcde2d6d04f7df/ee604/reacthooks.png 800w","sizes":"(max-width: 800px) 100vw, 800px"}}}},"timeToRead":7,"parent":{"__typename":"File","modifiedTime":"2021-04-03T11:16:59.786Z"}}},"pageContext":{"slug":"/2019-06-reacthooks/","previous":{"fields":{"slug":"/2019-05-googleformadv/"},"frontmatter":{"title":"Google Sheet RESTful API 試算表表單","tags":["google_form"]}},"next":{"fields":{"slug":"/2019-06-firstjob/"},"frontmatter":{"title":"第一份工作","tags":[null]}}}},"staticQueryHashes":["1481458783","63159454"]}