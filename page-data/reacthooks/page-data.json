{"componentChunkName":"component---src-templates-blog-post-js","path":"/reacthooks/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"80e5e5f8-4792-5a95-a1e9-819e1baca1e4","fields":{"slug":"/2019-06-reacthooks/"},"headings":[{"value":"React PureComponent","id":null,"depth":2},{"value":"React hooks functional","id":null,"depth":2},{"value":"React hooks 實現 todoList","id":null,"depth":2},{"value":"React hooks 效能處理","id":null,"depth":2},{"value":"增加 Redux","id":null,"depth":2},{"value":"心得","id":null,"depth":2}],"excerpt":"React 發布了幾個月的 Hooks，最近也開始嘗試接觸，後面會稍微提一下 PureComponent，不會介紹 hooks 各種特殊用法，就只針對 hooks performance 優化做介紹，還有搭配 redux 的處理。 因為前陣子有處理過 React…","html":"<p>React 發布了幾個月的 Hooks，最近也開始嘗試接觸，後面會稍微提一下 PureComponent，不會介紹 hooks 各種特殊用法，就只針對 hooks performance 優化做介紹，還有搭配 redux 的處理。</p>\n<p>因為前陣子有處理過 React 優化效能，對於這件事情也開始在意，讓人絕望的 google page speed...。</p>\n<!--- ![react lifecycle](../images/reacthooks.png \"react lifecycle\") --->\n<h2>React PureComponent</h2>\n<p>如果有在注意效能的話，你應該會聽過 shouldComponentUpdate 或 PureComponent，這是較常見的處理方法，Purecomponent 只關注 state、props 並作 shallow equal 比較，當不同值才會觸發 rerender。</p>\n<p><a href=\"https://reactjs.org/docs/shallow-compare.html\" title=\"shallow-compare\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React shallow-compare</a></p>\n<p>以下是有無使用 Purecomponent 的比較，當我更新某個 state，而這個 state 沒有傳進作為 props，PureComponent 會過濾掉更新。</p>\n<p>使用教學: 你可以嘗試更新 input text，會發現 Purecomponent 數字不會增加，而一般 component 則是會增加。這數字增加代表著 react 嘗試 update Component 次數。</p>\n<p>這數字不代表是否真的更新 dom，因為 react 會比較 render 後 dom 結構的不同，再決定是否更新某節點 dom，但嚴格來說這也算是種浪費效能。</p>\n<iframe src=\"https://codesandbox.io/embed/serene-murdock-t7ih2?fontsize=14,result\" width=\"100%\" height=\"400\"></iframe>\n<ul>\n<li>PureComponent code</li>\n</ul>\n<pre><code class=\"language-javascript\">import React, { PureComponent } from 'react';\n\nclass CheckboxPure extends PureComponent {\n    constructor(props) {\n        super(props);\n        this.state = {\n            done: true\n        };\n        this.times = 0;\n    }\n    changeCheck = e => {\n        this.setState({\n            done: e.target.checked\n        });\n    };\n    componentWillUpdate() {\n        this.times = this.times + 1;\n    }\n    render() {\n        const { done } = this.state;\n        const { text } = this.props;\n        return (\n            &#x3C;div>\n                &#x3C;div>PureComponent component Try Update time {this.times}&#x3C;/div>\n                &#x3C;div>\n                    &#x3C;input onClick={this.changeCheck} type=\"checkbox\" checked={done} />\n                    {text}\n                &#x3C;/div>\n            &#x3C;/div>\n        );\n    }\n}\n\nexport default CheckboxPure;\n</code></pre>\n<p>ps. PureComponent 不是全部都用，需要注意 props 的更新關係。假設你上層的 update，一定會更動到 PureCompoent 的 props，那你應該避免使用 PureComponent，因為每次接受到 props 時，PureComponent 還會多做一次 shallow compare，那因為每次都一定更新 props，多做比較就等於浪費效能，比起用一般方法還不好。</p>\n<h2>React hooks functional</h2>\n<p>前面會提到 PureComponent，是因為 react hooks 是全面的使用 functional Component，這代表我們不會在使用 Class，以往 Class 使用是繼承 React 並讓我們建立 instance，有 instance 就代表有 memory 位置，可以讓我們處理資料比較。functional 代表我們只要調用一次更新，所有的 react hooks function 都會再被調用一次。</p>\n<p>舉例來說，將關注點變到更小，所以 useEffect 才能實現像是 componentDidUpdate 的功能。</p>\n<ul>\n<li>Hooks like componentDidUpdate</li>\n</ul>\n<pre><code class=\"language-javascript\">useEffect(() => {\n  document.title = `You clicked ${count} times`;\n};\n// it will setting title everytime when render function\n</code></pre>\n<p>useEffect 就是一個例子，你看到 useEffect 的額外第二個參數，useEffect 會綁定 count 更新，才會調用 callback。</p>\n<ul>\n<li>Hooks useEffect bind count</li>\n</ul>\n<pre><code class=\"language-javascript\">useEffect(() => {\n    document.title = `You clicked ${count} times`;\n}, [count]);\n// Only setting title if count changes\n</code></pre>\n<h2>React hooks 實現 todoList</h2>\n<p>嘗試建立一個 toDo List，方便我們來看怎樣讓 React hooks 實現 PureComponent 的特性。我們會需要建立三個檔案，分別是是 container/todoView、component/todoLis、hooks/useTodoList。</p>\n<p>假設你已經用過 react hooks，這部分可以直接略過。</p>\n<p>首先建立 container/TodoView，我們會需要建立 toDo 的 Array，這邊我們會用到 useState，還有 useRe\bf，讓我們能夠取得 input value，剩下部份就是更新處理 todoList state。</p>\n<ul>\n<li>React hooks function</li>\n</ul>\n<pre><code class=\"language-javascript\">// toDo array\nconst [todoList, setTodoList] = useState([]);\n\n// create inputRef\nconst inputEl = useRef(null);\n\n// add Array\nconst addTodo = event => {\n    event.preventDefault();\n    if (!inputEl.current.value) {\n        return;\n    }\n    const mergeArr = [...todoList, inputEl.current.value];\n    inputEl.current.value = '';\n    return setTodoList(mergeArr);\n};\n\n// delete Array by index\nconst deleteToDo = index => {\n    const newArr = [...todoList];\n    newArr.splice(index, 1);\n    return setTodoList(newArr);\n};\n</code></pre>\n<p>建立 hooks/useTodoList，並把上面這些 hooks function 移動過去。就完成了 todoList 的自製 hooks。</p>\n<ul>\n<li>hooks/useTodoList.js</li>\n</ul>\n<pre><code class=\"language-javascript\">import { useState, useCallback } from 'react';\n\nfunction useTodoList(value, inputEl) {\n    const [todoList, setTodoList] = useState(value);\n    const addTodo = event => {\n        event.preventDefault();\n        if (!inputEl.current.value) {\n            return;\n        }\n        const mergeArr = [...todoList, inputEl.current.value];\n        inputEl.current.value = '';\n        return setTodoList(mergeArr);\n    };\n\n    const deleteToDo = index => {\n        const newArr = [...todoList];\n        newArr.splice(index, 1);\n        return setTodoList(newArr);\n    };\n\n    return [todoList, addTodo, deleteToDo];\n}\n\nexport default useTodoList;\n</code></pre>\n<p>會多建立一個 <code>const [count, setCount] = useState(0);</code>，讓我們在這層 setState，並觀察 TodoList 更新狀況。</p>\n<ul>\n<li>container/TodoView.js</li>\n</ul>\n<pre><code class=\"language-javascript\">import React, { useState, useRef } from 'react';\nimport TodoList from '../component/TodoList';\nimport useTodoList from '../hooks/useTodoList';\n\nfunction TodoView() {\n    const inputEl = useRef(null);\n    const [todoList, addTodo, deleteToDo] = useTodoList([], inputEl);\n\n    // use to update TodoView\n    // let us check TodoList update situation\n    const [count, setCount] = useState(0);\n\n    return (\n        &#x3C;>\n            &#x3C;span>Counter : {count}&#x3C;/span>\n            &#x3C;button onClick={() => setCount(count + 1)}>Add Counter&#x3C;/button>\n            &#x3C;form className=\"input-container\" onSubmit={addTodo}>\n                &#x3C;input ref={inputEl} placeholder=\"Type your to Do\" />\n                &#x3C;button className=\"add-button\">Create&#x3C;/button>\n            &#x3C;/form>\n            &#x3C;TodoList todoList={todoList} deleteToDo={deleteToDo} />\n        &#x3C;/>\n    );\n}\n\nexport default TodoView;\n</code></pre>\n<p>額外再加上 toDoList.js 加上計算器，每次的 render function 都會加上 1，方便我們看 toDoList 重新 render 的次數。</p>\n<ul>\n<li>component/TodoList.js</li>\n</ul>\n<pre><code class=\"language-javascript\">import React from 'react';\nlet count = 0;\n\nfunction TodoList(props) {\n    const { todoList, deleteToDo } = props;\n    count = count + 1;\n    return (\n        &#x3C;div className=\"list\">\n            TodoList render Times {count}\n            {todoList.map((value, index) => (\n                &#x3C;li className=\"list-item\" key={`to_${index}`}>\n                    &#x3C;div>\n                        {index + 1}. {value}\n                    &#x3C;/div>\n                    &#x3C;span onClick={() => deleteToDo(index)}>-&#x3C;/span>\n                &#x3C;/li>\n            ))}\n        &#x3C;/div>\n    );\n}\n\nexport default TodoList;\n</code></pre>\n<iframe src=\"https://codesandbox.io/embed/fervent-gould-qyekg?fontsize=14,result\" width=\"100%\" height=\"400\"></iframe>\n<h2>React hooks 效能處理</h2>\n<p>我們已經完成了簡易版的 todoList，當你輸入 input 建立後，會發現 TodoList 會更新一次，但是你點擊 count 後，會發現 TodoList 居然也會更新，這是因為所有的 component 已經都是純 functional component，當我們最上層更新 state，都會一路往下更新到底層。</p>\n<p>這時候我們就必須依賴 React.memo，React.memo 是一個 high Order Component，功能就像是 PureComponent，讓我們擋住調用更新 function，但差異在於 memo 是用在於 function components，並會幫我們 memory 住 props，只在 props 更新才會往下更新。</p>\n<p><a href=\"https://reactjs.org/docs/react-api.html#reactmemo\" title=\"React memo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React memo</a></p>\n<ul>\n<li>component/TodoList</li>\n</ul>\n<pre><code class=\"language-javascript\">// use React memo for TodoList;\nexport default React.memo(TodoList);\n</code></pre>\n<p>更新上去後，讓我們在嘗試點擊 count，觀察 TodoList 是否就卡住更新了。</p>\n<p>你會發現數字還是增加。</p>\n<p>查看上層傳進的 props 後，發現還有一個問題，就是傳進去的 function，每次都會是一個新的 function。因為沒有 function 沒有 memory 住，導致每次都會 render 後都會重新建立 addTodo、deleteToDo，所以對 toDoList 的 memo 來說，你每次都給我新的 props function，當然會每次都更新 component。</p>\n<iframe src=\"https://codesandbox.io/embed/adoring-dream-j01do?fontsize=14,result\" width=\"100%\" height=\"400\"></iframe>\n<p>幸好 react hooks 有提供 useCallback，讓我們可以把 function memory 起來，useCallback 會需要依賴第二個參數，讓他比較判斷是否要更新 function。</p>\n<ul>\n<li>React hooks useCallback</li>\n</ul>\n<pre><code class=\"language-javascript\">const memoizedCallback = useCallback(() => {\n    doSomething(a, b);\n}, [a, b]);\n</code></pre>\n<p><a href=\"https://reactjs.org/docs/hooks-reference.html#usecallback\" title=\"React usecallback\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React hooks usecallback</a></p>\n<pre><code class=\"language-javascript\">const addTodo = useCallback(\n    event => {\n        event.preventDefault();\n        if (!inputEl.current.value) {\n            return;\n        }\n        const mergeArr = [...todoList, inputEl.current.value];\n        inputEl.current.value = '';\n        return setTodoList(mergeArr);\n    },\n    [todoList, inputEl]\n);\n\nconst deleteToDo = useCallback(\n    index => {\n        const newArr = [...todoList];\n        newArr.splice(index, 1);\n        return setTodoList(newArr);\n    },\n    [todoList]\n);\n</code></pre>\n<p>更新上去後，再嘗試點擊 count 看看，會發現 toDoList 終於沒有更新數字了。這樣就完成了 hooks 的 render 效能處理。使用 React.memo 實現了類似 PureComponent 的功能，再解決掉 function components 沒有 memory 的問題，讓我們 todo、delete function，都不會因為 function component 被更新而重新被建立。</p>\n<iframe src=\"https://codesandbox.io/embed/floral-bash-dv708?fontsize=14,result\" width=\"100%\" height=\"400\"></iframe>\n<h2>增加 Redux</h2>\n<p>另外改用 redux 管理 todo 資料，沒有特別用最新 react-redux 的 hooks 版本，因為還在 alpha 階段。基本上就移除掉 useState，建立 store、reducer，再建立 Provider，還有 state、dispatch 傳遞到需要使用的元件上。</p>\n<p>不想偏離主題就直接貼上作法了。</p>\n<p>Source code: <a href=\"https://github.com/Ianpig/hooks-try\" title=\"React hooks with redux\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React hooks with redux</a></p>\n<h2>心得</h2>\n<p>因為準備要開始運用 hooks 在專案上，才發現 function components 要注意的問題，遠比我想像的還多。以往 react class 的寫法，react 處理了 component 的 rerender 問題，但改為 function components 後，多了處理 rerender 的問題。</p>\n<p>個人覺得用過 class 在轉用 hooks 後，lifeCycle 的部分最不習慣，感覺拉高了點 React 的學習門檻。hooks 讓 react 的複用單位拉到在更小，用得好確實能夠加速開發，期待日後實際運用 hooks 在專案上後能有更多心得分享。</p>","frontmatter":{"title":"React Hooks Performance 效能處理","date":"June 01, 2019","description":"React發布了幾個月的Hooks，最近也開始嘗試接觸，後面會稍微提一下PureComponent，不會介紹hooks各種特殊用法，就只針對hooks performance優化做介紹。","categories":"javascript","tags":["react.js"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABTUlEQVQoz2NQQgBlRUUFRQV5JWVlRXk5JdxAWUlJXVkZiBjgQooKCqpa2mp6BopyshpGpkAjSNAMVG0UGGUSGmeemGMcEqfn4q0gI62sogKUUQEDZbBxEBaSZqA75WTV9Y2sMkos04pc22eax2cBjVCUlVFUUlJQUJCRkZGSkpaVlQWypaSl5eTkNFRUoJpBDtbWNQ6Ns8mtcm6a4ljT49I0xTg6zTYyISs1OTU5KTwsxNfHOzI8ND8328/Xx9XZSVEWpB9Jc0isTV61c/Nkx5pu5+YpJtFpdhEJKQlxmempTXU1tVXlNZVlna1N9bVVGanJMpKSmqqqyM42tEoHOdulY5Z5XKZFQrairDTQ2YqKipqaQJWqampqQLVAtrqaqpqyEo4AS8gGknouXvAAA3pVERSNQKOU5BUUgOahhbYyMIYpiCpwIlEiJZEAAL1oc611LwT/AAAAAElFTkSuQmCC","aspectRatio":1.9540229885057472,"src":"/static/ef923c6861937178eebcde2d6d04f7df/ee604/reacthooks.png","srcSet":"/static/ef923c6861937178eebcde2d6d04f7df/c972b/reacthooks.png 340w,\n/static/ef923c6861937178eebcde2d6d04f7df/27625/reacthooks.png 680w,\n/static/ef923c6861937178eebcde2d6d04f7df/ee604/reacthooks.png 800w","sizes":"(max-width: 800px) 100vw, 800px"}}}},"timeToRead":7,"parent":{"__typename":"File","modifiedTime":"2021-04-03T11:16:59.786Z"}}},"pageContext":{"slug":"/2019-06-reacthooks/","previous":{"fields":{"slug":"/2019-05-googleformadv/"},"frontmatter":{"title":"Google Sheet RESTful API 試算表表單","tags":["google_form"]}},"next":{"fields":{"slug":"/2019-06-firstjob/"},"frontmatter":{"title":"第一份工作","tags":[null]}}}},"staticQueryHashes":["1481458783","63159454"]}