{"componentChunkName":"component---src-templates-blog-post-js","path":"/reactssr/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"431c50f8-9e92-548f-a9e7-c301d634eda0","fields":{"slug":"/2019-01-reactssr/"},"headings":[{"value":"Server-side rendering SEO","id":null,"depth":2},{"value":"React server-side render","id":null,"depth":2},{"value":"使用 create-react-app cli","id":null,"depth":3},{"value":"安裝使用 express","id":null,"depth":3},{"value":"express render REACT","id":null,"depth":2},{"value":"建立 server.js、render.js","id":null,"depth":2},{"value":"index.js 功能","id":null,"depth":2},{"value":"server.js 功能","id":null,"depth":2},{"value":"render.js 功能","id":null,"depth":2},{"value":"心得","id":null,"depth":2}],"excerpt":"先來稍微介紹一下為什麼要做 server side render，另外這邊不會使用 next.js，雖然公司目前專案有用到，但我滿推薦用 next.js 的，很好導入並且解決很多需要處理的問題。(雖然有一些 bug、還會頻繁更新，兩年內 version 3 -> 7...) Server-side rendering…","html":"<p>先來稍微介紹一下為什麼要做 server side render，另外這邊不會使用 next.js，雖然公司目前專案有用到，但我滿推薦用 next.js 的，很好導入並且解決很多需要處理的問題。(雖然有一些 bug、還會頻繁更新，兩年內 version 3 -> 7...)</p>\n<!--- ![react lifecycle](../images/react.png \"react lifecycle\") --->\n<h2>Server-side rendering SEO</h2>\n<p>傳統網站內容是依靠後端 php、jsp 等產生 html 內容，稱之為 Server-side rendering，但隨著前端技術演進，所有動態內容不再是連接資料庫取資料，轉變為使用非同步請求，依照不同需要依靠 JavaScript 直接請求 API，然後更新需要改動的 html，雖然說這樣處理很方便，使用者不用換網址發請求，整個畫面重新閃動。</p>\n<p>但這方法背後也產生 SEO 的缺點，動態內容的核心是執行 JavaScript，而網頁爬蟲卻不一定會載入執行網頁上的 JavaScript，雖然 google 官方表示爬蟲會<code>盡可能</code>的執行 script，但實務上當你要優化 SEO\u001c，就可能會避免用非同步拉資料，或是處理其他細節。這方式又稱為 Client-side rendering。</p>\n<p>PS.google 官方表示爬蟲邏輯大概是 索引 -> (有資源後) -> 執行 JavaScript，核心價值在於 URL，不同內容必須要有對應的 URL，才有可能幫你每個分頁分開索引。</p>\n<p>影片推薦觀看，能更了解 JavaScript 與爬蟲之間關係。\n<a href=\"https://www.youtube.com/watch?v=PFwUbgvpdaQ\" title=\"Google I/O &#x27;18 javascript website\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Google I/O '18 javascript website</a></p>\n<h2>React server-side render</h2>\n<p>使用 React 框架，但又需要讓爬蟲能索引得到 html，就需要轉為使用 server-side render，核心概念就是，原本 JavaScript 是用戶端執行產生內容，轉向依靠 server 來產生內容，請求 API 的部分也交由 server 端處理，直接在 server 端拿到畫面相關的資料，這樣爬蟲來索引的同時，就已經拿到了內容了。</p>\n<p>接下來來試著架構出 React server-side render 的架構，會使用到 react 官方的 cli create-react-app，以及 node.js 作為 server。</p>\n<h3>使用 create-react-app cli</h3>\n<pre><code class=\"language-javascript\">npx create-react-app react-ssr\ncd react-ssr\n</code></pre>\n<h3>安裝使用 express</h3>\n<p>server side render 需要後端執行 javascript，因此這邊使用 node 來處理，npm i express，再來建立 server folder，在建立一個 index.js，作為我們 server 執行的 root。</p>\n<ul>\n<li>src</li>\n<li>\n<p>server</p>\n<ul>\n<li>index.js</li>\n</ul>\n</li>\n</ul>\n<p>純粹只是 client side render，就只要執行 npm run build，再來我們針對 build 出來的資源，用 express 來控制。</p>\n<pre><code class=\"language-javascript\">const express = require('express');\nconst app = express();\nconst path = require('path');\n\n// host build foler resource\napp.use(express.static(path.join(__dirname, '../build')));\n\n// settting router\napp.get('*', (req, res) => {\n    res.sendFile(path.join(__dirname + '../build/index.html'));\n});\n\napp.listen(8080);\n</code></pre>\n<p><img src=\"../images/csr.png\" alt=\"react csr\" title=\"react csr\"></p>\n<h2>express render REACT</h2>\n<p>先談談用 node 執行 javascript 會遇到哪些難解問題。</p>\n<ul>\n<li>首先 node 無法執行 import。\n依靠 @babel/register 搭配 @babel/plugin-syntax-dynamic-import、@babel-plugin-dynamic-import-node，讓 express 執行轉譯過的 i\nmport。</li>\n<li>node 無法讀取 css、image 會出現 object\n利用 style-ignore，避開執行 css 內容，並在這邊處理好 image hash name。</li>\n<li>render react\n透過 react-dom/server 的 renderToString 或 renderToStaticMarkup 執行 react。</li>\n</ul>\n<p>剩下 react-router、redux、檔案加入 hash name、hot reload 等等，就先不在這邊討論。\n(置底 medium 文章有用到 redux、react-router)</p>\n<h2>建立 server.js、render.js</h2>\n<p>再建立 server.js loader.js 兩個檔案，<code>server.js</code> 主要負責 express，<code>index.js</code>則是處理 server 設定 babel、各種預處理修正，<code>render.js</code> 負責 render 內容。</p>\n<h2>index.js 功能</h2>\n<p>md5File 是為了讀取 image file name，搭配 ignoreStyles 使用，讓 server 讀取到 npm build 出來的 file name。這邊最黑魔法的是 babel/register，也是第一次看過這個用法，很輕鬆不需要 eject 就導入 babel 到 create react app 內。</p>\n<p><code>npm install md5-file ignore-styles</code></p>\n<pre><code class=\"language-javascript\">const md5File = require('md5-file');\nconst path = require('path');\n\nconst ignoreStyles = require('ignore-styles');\nconst register = ignoreStyles.default;\n\nconst extensions = ['.gif', '.jpeg', '.jpg', '.png', '.svg'];\n\n// ignore image and style request\nregister(ignoreStyles.DEFAULT_EXTENSIONS, (module, filename) => {\n    if (!extensions.find(f => filename.endsWith(f))) {\n        // use for style\n        return ignoreStyles.noOp();\n    } else {\n        // use for image and add hash follow react cli\n        const hash = md5File.sync(filename).slice(0, 8);\n        const bn = path.basename(filename).replace(/(\\.\\w{3})$/, `.${hash}$1`);\n        module.exports = `/static/media/${bn}`;\n    }\n});\nrequire('@babel/polyfill');\nrequire('@babel/register')({\n    ignore: [/\\/(build|node_modules)\\//],\n    presets: ['@babel/preset-env', '@babel/preset-react'],\n    plugins: ['@babel/plugin-syntax-dynamic-import', 'dynamic-import-node', 'react-loadable/babel']\n});\n\n// it will run express\nrequire('./server');\n</code></pre>\n<h2>server.js 功能</h2>\n<p>這邊主要就是處理 express 路由，static file 路徑，非常簡單的基本設定，比較特別的是用到 Loadable 來確保有 render component 有執行完成。</p>\n<p><code>npm install react-loadable express</code></p>\n<pre><code class=\"language-javascript\">import express from 'express';\nimport path from 'path';\nimport Loadable from 'react-loadable';\n\nimport render from './render';\n\nconst app = express();\nconst PORT = process.env.PORT || 4000;\n\napp.use(express.Router().get('/', render));\napp.use(express.static(path.resolve(__dirname, '../build')));\napp.use(render);\n\n// Loadable listener to make sure that all of your loadable components are already loaded\n// https://github.com/jamiebuilds/react-loadable#preloading-all-your-loadable-components-on-the-server\nLoadable.preloadAll().then(() => {\n    app.listen(PORT, console.log(`App listening on port ${PORT}!`));\n});\n</code></pre>\n<h2>render.js 功能</h2>\n<p>這邊就是實際 render react，主要依賴 renderToString 來取得 react 執行後的 html，之後再將 react 的 html 組裝成完整頁面的資料。</p>\n<p>這邊我有傳遞資料給 App wording，假設直接看 view-source:<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://localhost:4000/</a> 會看到 THIS IS Server Side Render ，但是 client side init 會瞬間不見，這邊可以讓你做一些 call api 後的資料傳遞，但這邊要記得要設定成某個變數名，讓 client 抓取這個變數。</p>\n<p>ps.client 指的是使用者載入時。</p>\n<pre><code class=\"language-javascript\">import path from 'path';\nimport fs from 'fs';\n\nimport React from 'react';\nimport { renderToString } from 'react-dom/server';\nimport Helmet from 'react-helmet';\n\nimport App from '../src/app';\n\nexport default (req, res) => {\n    fs.readFile(path.resolve(__dirname, '../build/index.html'), 'utf8', (err, htmlData) => {\n        if (err) {\n            console.error(`Error page ${err}`);\n            return res.status(404).end();\n        }\n\n        const helmet = Helmet.renderStatic();\n\n        const html = injectHTML(htmlData, {\n            html: helmet.htmlAttributes.toString(),\n            title: helmet.title.toString(),\n            meta: helmet.meta.toString(),\n            body: renderToString(&#x3C;App wording=\"THIS IS Server Side Render\" />)\n        });\n        res.send(html);\n    });\n};\n\nconst injectHTML = (data, { html, title, meta, body, state }) => {\n    data = data.replace('&#x3C;html>', `&#x3C;html ${html}>`);\n    data = data.replace(/&#x3C;title>.*?&#x3C;\\/title>/g, title);\n    data = data.replace('&#x3C;/head>', `${meta}&#x3C;/head>`);\n    data = data.replace('&#x3C;div id=\"root\">&#x3C;/div>', `&#x3C;div id=\"root\">${body}&#x3C;/div>`);\n    return data;\n};\n</code></pre>\n<ul>\n<li>package.json</li>\n</ul>\n<pre><code class=\"language-javascript\">  \"dependencies\": {\n    \"@babel/core\": \"^7.1.2\",\n    \"@babel/plugin-syntax-dynamic-import\": \"^7.0.0\",\n    \"@babel/polyfill\": \"^7.0.0\",\n    \"@babel/register\": \"^7.0.0\",\n    \"babel-plugin-dynamic-import-node\": \"^2.1.0\",\n    \"ignore-styles\": \"^5.0.1\",\n    \"md5-file\": \"^4.0.0\",\n    \"react-frontload\": \"^1.0.3\",\n    \"react-helmet\": \"^5.2.0\",\n    \"react-loadable\": \"^5.5.0\",\n    \"react\": \"^16.7.0\",\n    \"react-dom\": \"^16.7.0\",\n    \"react-scripts\": \"2.1.3\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\",\n    \"dev\": \"NODE_ENV=development node ./server/index.js\",\n    \"prod\": \"NODE_ENV=production node ./server/index.js\"\n  },\n</code></pre>\n<p><a href=\"https://github.com/Ianpig/react-sample-ssr\" title=\"Source Code Github\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Source Code Github</a></p>\n<h2>心得</h2>\n<p>整個寫完只需要三個檔案，看似簡單，但其實還有非常多部分還未處理，例如 router，要能夠在 server 處理各種路徑 render。開發時需要 hot reload，否則每次更新都要 build。這邊有看到有人有使用 nodeman 處理。各種檔案資源的壓縮優化，這就要依靠 webpack。</p>\n<p>以上問題 next.js 都有提供方法處理，官方還有各種工具整合的 sample code，雖然我自己不太愛 next.js，但它真的解決不少問題。(但是 safari back 存在各種 bug...)</p>\n<p>如果有錯誤的地方，還麻煩提出，感謝閱讀。</p>\n<ul>\n<li><a href=\"https://medium.com/@cereallarceny/server-side-rendering-in-create-react-app-with-all-the-goodies-without-ejecting-4c889d7db25e\" title=\"參考資料 medium cereallarceny\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">參考資料 medium cereallarceny</a></li>\n</ul>","frontmatter":{"title":"React Server-side rendering SEO處理","date":"January 30, 2019","description":"不使用next.js，來試著依靠原生方法，架構出React server-side render，會使用到react官方的cli create-react-app，以及node.js作為server。","categories":"javascript","tags":["react.js","seo"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABPUlEQVQoz2OQxwRycvJy8gpKSrKSErJSkgrKKnKyMvLYAAO6gIICUKlBWKJpZoWGnbOOV5B5bq2WkyfQFKAUXs1AnTIyShqaBhEpshLizlPWmmVXAR1iGJUGdIW8giIBzUA9mnYuto1TrSp7LIqarSq6rat6rCq7lTS05aSl0CxH0qygCDRe1ydMPyjWPL/eurrXuroPyLDvnGcQkWwUm61mZi2H6ngkzYqKsuKiRnHZmg7uRtHppmmlLtM3WFZ0WZa1a9g6G0ZnaDl7y4qLITueATMM9YJiHLoXOk5YbpyYZ1HU5DR5lU3DFA07F7zOhgSYtLSimoZhZAqQ5zhppVlujaKyCijAJMQIhTbEBCVl48R8o7gcoFOB2kxSCvUCo4GGEqEZFFvSShpawOCRERcBCqhb2AKDA5RyMAAAiZhuqh37UK0AAAAASUVORK5CYII=","aspectRatio":1.9428571428571428,"src":"/static/49f3722d7cadbd2be8eefba27f6a5890/b7e46/react.png","srcSet":"/static/49f3722d7cadbd2be8eefba27f6a5890/c972b/react.png 340w,\n/static/49f3722d7cadbd2be8eefba27f6a5890/27625/react.png 680w,\n/static/49f3722d7cadbd2be8eefba27f6a5890/b7e46/react.png 732w","sizes":"(max-width: 732px) 100vw, 732px"}}}},"timeToRead":6,"parent":{"__typename":"File","modifiedTime":"2021-05-16T08:19:40.147Z"}}},"pageContext":{"slug":"/2019-01-reactssr/","previous":{"fields":{"slug":"/2018-12-seoredirect/"},"frontmatter":{"title":"SEO 301、302轉址Redirect，canonical tag重複內容處理","tags":["seo"]}},"next":{"fields":{"slug":"/2019-02-promise/"},"frontmatter":{"title":"Javascript Promise example 簡易實作模擬","tags":["javascript"]}}}},"staticQueryHashes":["1481458783","63159454"]}