{"componentChunkName":"component---src-templates-blog-post-js","path":"/jsproto/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"cfdf141e-54a5-59a0-bd50-0b0021e2763a","fields":{"slug":"/2018-08-jsproto/"},"headings":[{"value":"JavaScript ProtoType 介紹","id":null,"depth":2},{"value":"JavaScript ProtoType 繼承鍊","id":null,"depth":2}],"excerpt":"因緣際會之下，最近剛經歷了招募前端，為了準備面試題目，所以整理了一些關於 JavaScript 的 觀念，其中比較抽象的題目應該是 ProtoType、Event loop、Bubbles Capture，這邊就先來介紹一下其中最抽象也比較難理解的 JavaScript ProtoType。 JavaScript…","html":"<p>因緣際會之下，最近剛經歷了招募前端，為了準備面試題目，所以整理了一些關於 JavaScript 的 觀念，其中比較抽象的題目應該是 ProtoType、Event loop、Bubbles Capture，這邊就先來介紹一下其中最抽象也比較難理解的 JavaScript ProtoType。</p>\n<!--- ![JavaScript](../images/JavaScript-logo.png \"JavaScript\") --->\n<h2>JavaScript ProtoType 介紹</h2>\n<p>JavaScript 沒有類的特性(class-based)，跟 Java 不一樣，雖然說 ES6 有 class 但它只是語法糖，每個 JavaScript 都具備有 prototype，只是分為公開、私有差異，而 JavaScript 就用 prototype 來處理繼承(prototype-based)，特性是延展性高。</p>\n<pre><code class=\"language-javascript\">// 使用解構復值作為參數  並且預設沒傳值預設給予字串\nfunction Family({ m = 'no person', w = 'no person', c = 'no child' } = {}) {\n    this.father = m;\n    this.mother = w;\n    this.chidren = c;\n}\n\nvar data = {\n    m: 'John Paul',\n    w: 'Mary Alice',\n    c: 'Chris Paul'\n};\n\n// 繼承 Family\nvar paul = new Family(data);\n// 等同於\n// var paul[[Prototype]] = Family.prototype;\n// Family.call(paul);\n// paul 的 __proto__ 等於 Family();\n\nconsole.log(paul);\n// chidren: \"Chris Paul\"\n// father: \"John Paul\"\n// mother: \"Mary Alice\"\n</code></pre>\n<p><a href=\"https://codepen.io/chu1228/pen/KxVoVz?editors=0001\" title=\"example codepen\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">example codepen</a></p>\n<p>console.log(paul) 截圖\n<img src=\"../images/family_proto.png\" alt=\"JavaScript proto\" title=\"family proto.proto\"></p>\n<p>接下來擴充一下 Family，增加一個 function。</p>\n<pre><code class=\"language-javascript\">// 增加一個 hi function\nFamily.prototype.hi = function() {\n    console.log(`Family's child is ${this.chidren}. Family's father is ${this.father}`);\n};\n\n// this 指向調用時的物件 paul\npaul.hi();\n// I am Chris Paul. My father is John Paul\n</code></pre>\n<p><a href=\"https://codepen.io/chu1228/pen/rZxdxm?editors=0011\" title=\"example codepen\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">example codepen</a></p>\n<p>JavaScript ProtoType 用來建立 function 也較不耗費記憶體，當我今天有多個的不同物件要產生，就不需要實際複製產生，而是轉向繼承核心的 function 使用 prototype，這特色在 es6 class 撰寫時會滿明顯感受。</p>\n<h2>JavaScript ProtoType 繼承鍊</h2>\n<p>每個物件都有一個連著其他原型（prototype）的私有屬性（private property）物件。原型物件也有著自己的原型，於是原型物件就這樣鏈結，直到撞見 null 為止。看範例可能會比較好理解，</p>\n<p>另外會發現到物件第一層會是 <code>__proto__</code> (隱式原型)，主要是瀏覽器會透過隱式原型指向該物件的 prototype。</p>\n<p>ps. <code>__proto__</code>稱為隱式原型) 與 prototype 顯式原型。</p>\n<p><img src=\"../images/chain.png\" alt=\"JavaScript protochain\" title=\"family protochain\"></p>\n<p>簡單的範例</p>\n<pre><code class=\"language-javascript\">var Person = function() {\n    this.name = `chu`;\n};\n\nvar Age = function() {\n    this.age = 18;\n};\n\nvar Gender = function() {\n    this.gender = 'male';\n};\n\nAge.prototype = new Person();\n\nGender.prototype = new Age();\n\nvar ian = new Gender();\nconsole.log(ian.name, ian.age, ian.gender); // chu 18 male\n// 會先查找 ian 的 name ，找不到找該物件的原型prototype，\n// 在找不到會在往上層去找 prototype.name 就會發現找到了停止向上查找\n// 直到找不到 prototype ，__proto__為null時停止\n// 整個流程稱之為 prototype chain\n</code></pre>\n<p><a href=\"https://codepen.io/chu1228/pen/LJGdGm?editors=0011\" title=\"example codepen\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">example codepen</a></p>\n<p><img src=\"../images/protochain.png\" alt=\"JavaScript protochain\" title=\"family protochain\"></p>\n<p>突然提到 prototype，主要是在 React 開發時，時常用到 ES6 class，才知道 class 背後處理了非常關於 prototype 繼承的細節。才知道 prototype 的概念形影不離。</p>\n<p>例如一個簡單的 class 如下</p>\n<pre><code class=\"language-javascript\">class Person {\n    constructor(name) {\n        this.name = name;\n    }\n    hello() {\n        console.log(`hello,i am ${this.name}`);\n    }\n}\nclass Age extends Person {\n    // constructor會在建立時倍呼叫\n    // 接受傳遞參數\n    constructor(name, age) {\n        // 繼承父層 prototype.name\n        super(name);\n        this.age = age;\n    }\n    intro() {\n        console.log(`i am ${this.name}, and ${this.age} years old,`);\n    }\n}\n\nconst ian = new Age(`chu`, 18);\nian.intro(); // i am chu, and 18 years old,\nian.hello(); // hello,i am chu\n</code></pre>\n<p><a href=\"https://codepen.io/chu1228/pen/dqGZxB?editors=0011\" title=\"example codepen\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">example codepen</a></p>\n<p>如果你有用過 react 的 class xxx extends React.component，就會發現到其中 super(props)，就在講繼承 React.component 的 props。es6 class 就先不在這邊講述了，</p>\n<p>以上就是 prototype 的簡單介紹，有錯誤或是問題歡迎留言。</p>","frontmatter":{"title":"JavaScript Prototype 繼承、原型鏈 Prototype chain","date":"August 25, 2018","description":"JavaScript沒有類的特性(class-based)，跟Java不一樣，雖然說ES6 有class但它只是語法糖，每個JavaScript都具備有prototype，只是分為公開、私有差異，而JavaScript就用prototype來處理繼承(prototype-based)，特性是延展性高。","categories":"javascript","tags":["javascript","prototype"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABvklEQVQoz2N4c80eE727YX9hr/XeNZb3T9sC2Z/vOFw/bLNxkfmuVRbPL4G4r6+ClDFg6nx1xf7rPYecZF0xcUWghv/PnVbMMtPXUxWTUJKUVvZ01Ti32/rjLZB+nJozk3QFhRW3LDUH2mxmqq6krNzXZJSZqAs0Zc8aC6DlQGV4NYso7lhh8eC0LVCntYX6p3sO3584ArmEnQ3ULCSquHmx+bf7Dr6emkBXeLtpLp5qClTw+a7DK4KahUUVNyw0//fM8dR2K083TQEhRT5BRVcnjeNbrUD60ZwNNO/DLQeQ2XccssCaN4Ft/vXIEejOJdNM/b00gYLuzprPLtq9vY6kGSj95a7DjSM2T87Z/X/lBLEZGNo/HzpuX25x94Tt/y8uH247AG1WUlI+tsUKqJgB2anblpmrqatkJ+uunmNmYaYmK6d8cZ/NsummvPwKQb5aa+ebz+g20dJU1dNVvX7EBhhbDHAHf7ztcHqnlZO9hrCokoCwIjBWizL1IckjNkxHXFIJGGZAcUVF5cntxl/Q/PwK7OzH5+yWTjcFSm9eYg70FVAcaMP7Gw47VlpM6zKe1WtyYps1UNlrsBYA70hbAl6wB1gAAAAASUVORK5CYII=","aspectRatio":1.8888888888888888,"src":"/static/e0505dfa26d1f0856cca4d8ca2e3fb29/997ff/JavaScript-logo.png","srcSet":"/static/e0505dfa26d1f0856cca4d8ca2e3fb29/c972b/JavaScript-logo.png 340w,\n/static/e0505dfa26d1f0856cca4d8ca2e3fb29/27625/JavaScript-logo.png 680w,\n/static/e0505dfa26d1f0856cca4d8ca2e3fb29/997ff/JavaScript-logo.png 796w","sizes":"(max-width: 796px) 100vw, 796px"}}}},"timeToRead":3,"parent":{"__typename":"File","modifiedTime":"2021-05-16T08:19:40.137Z"}}},"pageContext":{"slug":"/2018-08-jsproto/","previous":{"fields":{"slug":"/2018-07-gasession/"},"frontmatter":{"title":"Google Analytics 工作階段介紹、定義","tags":["google_analytics"]}},"next":{"fields":{"slug":"/2018-08-tagmanager/"},"frontmatter":{"title":"Google Tag Manager tracking code 安裝追蹤碼","tags":["tag_manager","google_analytics"]}}}},"staticQueryHashes":["1481458783","63159454"]}